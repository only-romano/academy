fH1=function(){if(!~getJ().search(/function\((\w+)\)\{\S*\1\.preventDefault\(\)\S*\}/)){document.querySelector('#view-after .card').classList.toggle('off');document.querySelector('#view-after .contacts-html').classList.toggle('off')}};
tb1=`<!DOCTYPE html>\n<html lang="ru">\n<head>\n  <meta charset="utf-8">\n  <title>CandyShop</title>\n  <link href="style.css" rel="stylesheet">\n</head>\n<body>\n  <section class="card">\n    <div class="card__content">\n      <h1 class="visually-hidden">Магазин мороженого CandyShop</h1>\n      <img class="card__logo" src="images/courses/58/candyshop.svg" width="205" height="63" alt="CandyShop">\n      <p class="card__text">Готовим мороженое из самых свежих сливок!</p>\n      <img class="card__img" src="images/courses/58/icecream.png" width="196" height="240" alt="Мороженое">\n    </div>\n    <div class="card__controls">\n      <a onclick="fH1()" class="card__button button-open">Показать контакты</a>\n    </div>\n  </section>\n\n  <div class="contacts-html off">\n    <h1>Контакты</h1>\n    <h2>Адрес:</h2>\n    <p>191186, Санкт-Петербург, ул. Большая Конюшенная, д. 19/8</p>\n    <h2>Телефон:</h2>\n    <p>+7 (812) 275-75-75</p>\n    <h2>Почта:</h2>\n    <p>mail@htmlacademy.ru</p>\n    <button onclick="fH1()">Назад</button>\n  </div>\n\n  <section class="modal">\n    <div class="modal__content">\n      <h2 class="visually-hidden">Контакты</h2>\n      <h3>Адрес:</h3>\n      <p>191186, Санкт-Петербург, ул. Большая Конюшенная, д. 19/8</p>\n      <h3>Телефон:</h3>\n      <p>+7 (812) 275-75-75</p>\n      <h3>Почта:</h3>\n      <p>mail@htmlacademy.ru</p>\n      <button class="modal__button button-close" type="button">Закрыть</button>\n    </div>\n  </section>\n\n  <script src="script.js"></script>\n</body>\n</html>`;
tc1=`h3 {\n  margin: 0.5em 0;\n}\n\np {\n  margin: 0.5em 0 2em;\n}\n\n.card {\n  width: 420px;\n  margin: 50px auto 0;\n}\n\n.card__content {\n  position: relative;\n  background-color: #fad400;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  padding-top: 15px;\n  padding-left: 20px;\n  box-shadow: 0 5px 8px 0 #e8e8e8;\n}\n\n.card__img {\n  align-self: flex-end;\n  margin-top: auto;\n}\n\n.card__logo {\n  position: absolute;\n}\n\n.card__text {\n  font-size: 16px;\n  line-height: 22px;\n  font-weight: bold;\n  position: absolute;\n  left: 20px;\n  top: 100px;\n  width: 190px;\n}\n\n.card__controls {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border: 2px solid #e8e8e8;\n  border-top: 0;\n  border-bottom-right-radius: 10px;\n  border-bottom-left-radius: 10px;\n  padding-top: 20px;\n  padding-bottom: 20px;\n}\n\n.card__button {\n  border: 0;\n  padding: 12px 0;\n  width: 230px;\n  text-transform: uppercase;\n  text-align: center;\n  border-radius: 50px;\n  color: #ffffff;\n  font-weight: bold;\n  font-size: 16px;\n  text-decoration: none;\n  background-color: #fad400;\n  cursor: pointer;\n}\n\n.contacts-html button {\n  cursor: pointer;\n}\n\n.card__button:hover,\n.card__button:focus {\n  background-color: #82da03;\n}\n\n.card__button:active {\n  color: rgba(255, 255, 255, 0.3);\n\n  background-color: #6cb502;\n}\n\n.modal {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.modal--show {\n  display: block;\n}\n\n.modal::after {\n  content: "";\n  position: fixed;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  background-color: rgba(0, 0, 0, 0.3);\n  z-index: 1;\n}\n\n.modal__content {\n  position: relative;\n  width: 300px;\n  margin: 100px auto;\n  padding: 30px 70px 15px;\n  background-color: #ffffff;\n  box-shadow: -1px 5px 12px 0 rgba(89, 90, 90, 0.3);\n  z-index: 2;\n}\n\n.modal__button {\n  position: absolute;\n  top: 20px;\n  right: 20px;\n\n  width: 20px;\n  height: 20px;\n\n  font-size: 0;\n\n  background: none;\n  border: 0;\n}\n\n.modal__button::after,\n.modal__button::before {\n  content: "";\n\n  position: absolute;\n  right: 0;\n  top: 20px;\n\n  width: 26px;\n  height: 6px;\n  margin: -13px -3px;\n\n  background-color: #7656de;\n}\n\n.modal__button::before {\n  transform: rotate(45deg);\n}\n\n.modal__button::after {\n  transform: rotate(-45deg);\n}\n\n.modal__button:hover::after,\n.modal__button:hover::before,\n.modal__button:focus::after,\n.modal__button:focus::before {\n  background-color: #9b7ff7;\n}\n\n.modal__button:active::after,\n.modal__button:active::before {\n  background-color: #4023a0;\n}\n\n.visually-hidden {\n  position: absolute;\n\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  border: 0;\n  padding: 0;\n\n  white-space: nowrap;\n\n  clip-path: inset(100%);\n  clip: rect(0 0 0 0);\n  overflow: hidden;\n}`;
th1=`body{font-weight:400;font-size:16px;font-family:"Open Sans","Arial",sans-serif;color:#3a3a3a;}`;
fH2=()=>{var p=document.querySelector('#view-after .popup');var c=document.querySelector("#view-after .contacts-html");var d=document.querySelector('#view-after .card');var s=[p.classList.contains('popup--open'),c.classList.contains("off"),d.classList.contains("off")];function r(a,i){s[0]?p.classList.add('popup--open'):p.classList.remove('popup--open');s[1]?c.classList.add('off'):c.classList.remove('off');s[2]?d.classList.add('off'):d.classList.remove('off');a?getR(true):getR(false,i)};p.classList.remove('popup--open');c.classList.add('off');d.classList.remove('off');document.querySelector('#view-after .button-show').click();if(!p.classList.contains('popup--open')||!c.classList.contains('off')){r(false,document.querySelector('#view-after .button-show'));return};document.querySelector('#view-after .button-hide').click();if(p.classList.contains('popup--open')||!c.classList.contains('off')){r(false);return};var k=new KeyboardEvent("keydown",{"keyCode":27});p.parentNode.focus();document.querySelector("#view-after .view-body").dispatchEvent(k);if(p.classList.contains('popup--open')||!c.classList.contains('off')){r(false);return};p.parentNode.focus();document.dispatchEvent(k);if(p.classList.contains('popup--open')||!c.classList.contains('off')){r(false);return};p.classList.add('popup--open');k=new KeyboardEvent("keydown",{"keyCode":13});p.parentNode.focus();document.dispatchEvent(k);if(!p.classList.contains('popup--open')||!c.classList.contains('off')){r(false);return};k=new KeyboardEvent("keydown",{"keyCode":32});p.parentNode.focus();document.dispatchEvent(k);if(!p.classList.contains('popup--open')||!c.classList.contains('off')){r(false);return};r(true)};
tb2=`<!DOCTYPE html>\n<html lang="ru">\n<head>\n  <meta charset="utf-8">\n  <title>Кексогалерея</title>\n  <link href="style.css" rel="stylesheet">\n</head>\n<body>\n  <section class="gallery">\n    <h1>Кексогалерея</h1>\n    <p class="gallery__photo-full">\n      <img class="full-photo" src="images/courses/58/laptop-large.jpg" width="550" height="367" alt="Фото большое">\n    </p>\n    <p class="gallery__photo-previews">\n      <button class="gallery__photo-preview" type="button">\n        <img src="images/courses/58/laptop.jpg" alt="Превью с ноутбуком">\n      </button>\n      <button class="gallery__photo-preview" type="button">\n        <img src="images/courses/58/microphone.jpg" alt="Превью с микрофоном">\n      </button>\n      <button class="gallery__photo-preview" type="button">\n        <img src="images/courses/58/keyboard.jpg" alt="Превью с клавиатурой">\n      </button>\n      <button class="gallery__photo-preview" type="button">\n        <img src="images/courses/58/signboard.jpg" alt="Превью с табличкой">\n      </button>\n      <button class="gallery__photo-preview" type="button">\n        <img src="images/courses/58/tree.jpg" alt="Превью с деревом">\n      </button>\n    </p>\n  </section>\n  <script src="script.js"></script>\n</body>\n</html>`;
tc2=`.gallery {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.gallery__photo-full {\n  margin-bottom: 12px;\n}\n\n.gallery__photo-full img {\n  display: block;\n}\n\n.gallery__photo-previews {\n  display: flex;\n  list-style-type: none;\n  margin: 0;\n  width: 550px;\n  padding: 0;\n  justify-content: space-between;\n}\n\n.gallery__photo-preview {\n  padding: 0;\n  border: 0;\n  border-radius: 0;\n  background: none;\n}\n\n.gallery__photo-preview:hover,\n.gallery__photo-preview:focus {\n  opacity: 0.7;\n}\n\n.gallery__photo-preview img {\n  display: block;\n  object-fit: cover;\n  width: 100px;\n  height: 100px;\n}\n\n.gallery__photo-preview--active img {\n  outline: 5px solid red;\n  outline-offset: -5px;\n}`;
th2=`body{font-weight:400;font-size:16px;font-family:"Open Sans","Arial",sans-serif;color:#3a3a3a;background:url("images/courses/58/leaves-pattern.png") 0 0 repeat;}p{margin:0;}.gallery{display:flex;flex-direction:column;align-items:center;}.gallery__photo-full{display:block;margin-bottom:12px;}.gallery__photo-previews{display:flex;list-style-type:none;margin:0;width:550px;padding:0;justify-content:space-between;}.gallery__photo-preview{padding:0;border:0;border-radius:0;background:none;}.gallery__photo-preview:hover,.gallery__photo-preview:focus{opacity:0.7;}.gallery__thumbnail{display:block;object-fit:cover;width:100px;height:100px;}.gallery__photo-preview--active .gallery__thumbnail{outline:5px solid red;outline-offset:-5px;}`;
tj1=`var photos = [\n    'images/courses/58/laptop-large.jpg',\n    'images/courses/58/microphone-large.jpg',\n    'images/courses/58/keyboard-large.jpg',\n    'images/courses/58/signboard-large.jpg',\n    'images/courses/58/tree.jpg'\n];\n`;
fH3=()=>{var m=['images/courses/58/tomato-red-large.jpg','images/courses/58/tomato-yellow-large.jpg','images/courses/58/tomato-strange-large.jpg'];var p=document.querySelector('#view-after .full-picture');var t=document.querySelectorAll('#view-after .gallery__picture-preview');for(var i=0;i<t.length;i++){t[i].click();if(!~p.getAttribute('src').indexOf(m[i])){getR(false);var l=t[i].offsetLeft+t[i].offsetWidth/2;var u=t[i].offsetTop+t[i].offsetHeight/2;var g=document.createElement('img');g.src="images/red-cross.png";g.style.width="64px";g.style.position="fixed";g.style.top=(u-32)+"px";g.style.left="calc(50% + "+(l-32)+"px)";document.querySelector('#view-after .view-body').appendChild(g);setTimeout(function(){document.querySelector('#view-after .view-body').removeChild(g);},2500);return}};getR(true);};

LessonsData={
'lesson1189':{theory:`<div><h1>Знакомимся с событиями</h1><p>Босс доволен вашим прогрессом и доверяет вам серьёзную задачу. Нужно запрограммировать всплывающее окно.Для краткости такое окно можно называть проще — попап.</p><blockquote><p>Мяу! Ты доказал, что можешь писать код и решать задачи. Пора переходить из стажёров в джуниоры!</p><p>Только не расслабляйся, работы много. Нужно оживлять интерфейсы и добавлять взаимодействие с пользователем.</p><p>Запрограммируй всплывающее окно с контактами компании. Тебе нужен элемент с классом <code>modal</code>.</p><p>При клике по кнопке с классом <code>button-open</code> попапу должен добавляться класс <code>modal--show</code>, так окно появится на странице.</p><p>По клику по кнопке с классом <code>button-close</code> у окна должен удаляться класс <code>modal--show</code>, и попап должен закрыться.</p><p>Ещё попап должен закрываться, если пользователь нажал клавишу <code>ESC</code>, пока окно было открыто.</p><p>Приступай к работе.</p></blockquote><p>Давайте сначала разберёмся, что значит «оживлять» интерфейс?</p><p>У нас уже есть готовая разметка и стили, все состояния элементов подготовлены верстальщиком. Но пока что страница статическая. Это просто набор тегов и текста. В разметке у нас есть попап с классом <code>modal</code>, его не видно на странице. Если мы добавим этому попапу класс <code>modal--show</code>, окно отобразится в интерфейсе. Но ведь пользователь не будет сам менять классы в разметке?</p><p>Если представить взаимодействие пользователя и страницы, получится примерно такой сценарий: <code>кнопка на странице, попап скрыт → пользователь нажимает на кнопку → попап появляется на странице</code>.</p><p>Этап, где пользователь нажимает на кнопку — связующее звено между состоянием закрытого и открытого попапа. Интерфейс становится «живым» и реагирует на действия пользователя. Действие, когда пользователь что-то делает с элементами страницы (например, кликает по кнопке или нажимает клавишу) называется <b>событием</b>. Именно с событиями мы и будем работать, чтобы выполнить задачу от Кекса.</p><p>Сначала с помощью <code>querySelector</code> найдём попап, с которым будем работать, и сохраним его в переменную. Затем проверим, как будет выглядеть окно в открытом состоянии.</p><p>Мы уже разбирали, как работает <code>querySelector</code>. Если вам нужно освежить знания, загляните в «Знакомство с JavaScript в браузере».</p></div>`,html:tb1,css:tc1,hidden:th1,js:``,tasks:[{message:"Cоздайте переменную <code class='keyvalue'>popup</code> и запишите в неё элемент с классом <code class='keyclass'>modal</code>.",check:(o)=>o&&o.popup&&o.popup===document.querySelector('#view-after .view-body .modal')},{message:"Ниже с помощью <code>classList.add()</code> добавьте элементу <code class='keyvalue'>popup</code> класс <code class='keyclass'>modal--show</code>",check:(o)=>o&&o.popup&&o.popup.classList&&o.popup.classList.contains('modal--show')}],blocked: "4",editorOff: ""},
'lesson1190':{theory:`<div><h1>Как добавить обработчик</h1><p>У нас есть кнопка, клик по которой должен вызвать появление попапа. План такой: нам нужно поймать тот момент, когда пользователь кликнет по кнопке. Когда это произойдёт, мы добавим попапу класс <code>modal--show</code>, чтобы окно появилось на странице.</p><p>Действие «поймать тот момент, когда пользователь кликнет по кнопке» можно назвать по-другому: добавить <b>обработчик события клика</b> по кнопке. Далее, для простоты, опустим слово «событие» и будем говорить так: <i>добавить обработчик клика по кнопке</i>.</p><p>Что значит добавить обработчик? Чтобы определить момент, когда происходит какое-то событие на странице, в нашем случае клик по кнопке, мы добавляем кнопке обработчик, который сработает, <b>когда произойдёт клик</b>.</p><p>Посмотрим на синтаксис добавления обработчика.</p><pre><code>var button = document.querySelector('.button');\n\n<mark>button.addEventListener('click', function () {\n  // Инструкции\n});</mark></code></pre><p>Функция <code>addEventListener()</code> говорит о том, что мы добавляем обработчик события на элемент. Дословно «добавляем слушатель события». Обработчик «слышит» всё, что происходит на странице и обязательно услышит, когда произойдёт то событие, которое нужно нам. Если мы правильно его настроим.</p><p>Дальше мы подробно разберём синтаксис обработчиков событий и их настройку, а пока найдём кнопку, клик по которой должен вызвать открытие попапа. Это кнопка с классом <code>button-open</code>. Добавим этой кнопке обработчик по аналогии с примером выше.</p></div>`,html:tb1,css:tc1,hidden:th1,js:`var popup = document.querySelector('.modal');\n`,tasks:[{message:`После переменной <code class='keyvalue'>popup</code> создайте переменную <code class='keyvalue'>openPopupButton</code> и запишите в неё кнопку с классом <code class='keyclass'>button-open</code>`,check:(o)=>o&&o.popup&&o.openPopupButton===document.querySelector('#view-after .button-open')},{message:"После объявления переменных, добавьте обработчик на кнопку: <code>openPopupButton.addEventListener(<code class='keytext'>'click', function () { }</code>);</code>",check:(o)=>o&&o.popup&&o.openPopupButton===document.querySelector('#view-after .button-open')&&~getJ().search(/(openPopupButton)\S+\1\.addEventListener\(('|"|`)click\2,function\(\)\{\}\)/)}],blocked:"4",editorOff:"4"},
'lesson1191':{theory:`<div><h1>Как устроены события</h1><p>Теперь подробно разберём, что означает подобная запись:</p><pre><code>button.addEventListener('click', function () {\n  // Инструкции\n});\n</code></pre><p><b>1. Элемент</b></p><p>В примере выше <code>button</code> — кнопка, на которой мы будем ждать пользовательское событие (клик, нажатие, ввод). Этот элемент указывается в самом начале.</p><p>Далее, через точку, мы добавляем <code>addEventListener</code>. То есть указываем, что хотим добавить «слушатель события».</p><p><b>2. Название события</b></p><p>Первый параметр функции <code>addEventListener</code> - название события, которое мы хотим поймать. Название записывается строкой, поэтому обязательно указывается в кавычках. Для всех событий есть специальные зафиксированные названия, поэтому мы не можем ловить событие клика, передав любую строку, которая придёт в голову, например, <code>'push'</code>. Список названий событий можно посмотреть <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener">здесь</a>.</p><p><b>3. Обработчик</b></p><p>Второй параметр <code>addEventListener</code> — функция. Это и есть обработчик события. Внутри этой функции мы указываем, что нужно сделать, когда произойдёт событие, как его нужно обработать. Инструкции внутри этой функции могут быть любыми: можно выводить сообщения в консоль (это может пригодиться при отладке кода), менять классы или содержимое элементов, вызывать другие функции. Внутри это такая же функция, как и любая другая, только с некоторыми особенностями, о которых мы поговорим позже.</p><p>Главное, на что нужно обратить внимание — функция, переданная в обработчик, <b>не выполняется сразу</b>. Действия из тела этой функции выполнятся только когда произойдёт установленное событие.</p><p>В итоге всю запись из примера можно прочитать так: добавим обработчик клика на кнопку <code>button</code>. При клике по кнопке должны выполниться какие-то инструкции.</p><p>Нужную кнопку мы уже нашли и записали в переменную <code>openPopupButton</code>, обработчик клика тоже добавили. Теперь запишем инструкции в обработчик. При клике будем выводить сообщение в консоль, чтобы убедиться, что событие действительно срабатывает.</p><p style="padding: 10px 15px; border: 1px solid #e84e1b;"><strong>Важно!</strong> Если вы перейдёте по ссылке внутри мини-браузера и захотите вернуться на первую страницу, кликните на кнопку <code>Назад</code> внизу новой страницы.</p></div>`,html:tb1,css:tc1,hidden:th1,js:`var popup = document.querySelector('.modal');\nvar openPopupButton = document.querySelector('.button-open');\n\nopenPopupButton.addEventListener('click', function () {\n\n});\n`,tasks:[{message:"Внутри обработчика добавьте вывод в консоль строки <code class='keytext'>'Клик по кнопке'</code>",check:()=>~getJ().search(/function\(\)\{console.log\(('|"|`)Кликпокнопке\1\)/)},{message:"Кликните по кнопке <code class='keytext'>«Показать контакты»</code> и проверьте сообщение в консоли.",check:(o)=>o&&o.log&&~o.log.indexOf('Клик по кнопке')}],blocked:"4",editorOff:"4"},
'lesson1192':{theory:`<div><h1>Действия по умолчанию</h1><p>Обработчик клика сработал, сообщение вывелось, но вместе с тем произошёл переход по ссылке на другую страницу.</p><p>Кнопка свёрстана ссылкой (тег <code>&lt;a&gt;</code>), а не кнопкой (тег <code>&lt;button&gt;</code>) на случай, если у пользователя не будут работать скрипты. Такое бывает редко, но наш верстальщик продумал такой сценарий. Мы не можем поменять вёрстку, наша задача — программировать логику. На практике это встречается часто: разработчик получает готовую вёрстку и должен решать свои задачи, не меняя разметку.</p><p>Что же делать?</p><p>Некоторые элементы страницы имеют <i>действия по умолчанию</i>. Их ещё называют <i>дефолтными действиями</i>. Например, клик по кнопке отправления формы вызывает отправку данных этой формы на сервер, а при клике по ссылке браузер переходит по этой ссылке. Это как раз наш случай!</p><p>Дефолтные действия можно отменять при необходимости, мы так и поступим. В этом поможет объект <code>event</code>.</p><p>Объект <code>event</code> — параметр функции-обработчика. Он всегда передаётся браузером в эту функцию <b>в момент наступления события</b>. Этот объект содержит много полезных свойств и методов, в частности метод, который отменяет действие по умолчанию: <code>preventDefault()</code>.</p><p>Чтобы использовать свойства и методы объекта <code>event</code>, достаточно указать этот объект параметром функции-обработчика и написать инструкции. Остальное сделает JavaScript. Среди некоторых разработчиков принято называть параметр сокращённо — <code>evt</code>. Это позволяет избежать некоторых ошибок, о которых мы поговорим в будущих курсах. Мы тоже будем называть параметр обработчика <code>evt</code>. Объект события будет передан в функцию, как только это событие случится.</p><pre><code>link.addEventListener('click', function(<mark>evt</mark>) {\n  // Отменяем действие по умолчанию\n  <mark>evt.preventDefault();</mark>\n\n  // Добавляем инструкции для события клика\n  console.log('Произошёл клик');\n});\n</code></pre><p>В примере мы отменили действие по умолчанию и при клике по ссылке переход не произойдёт. Вместо этого при клике выведется сообщение <code>'Произошёл клик'</code> в консоль.</p><p>Отменим дефолтное действие у ссылки <code>«Показать контакты»</code> в нашем проекте. Убедимся, что переход по ссылке не происходит. При этом мы не сломаем поведение, которое закладывал верстальщик: если у пользователя будут скрипты, попап появится на странице, а если нет, произойдёт переход по ссылке на заранее подготовленную для этого страницу.</p></div>`,html:tb1,css:tc1,hidden:th1,js:`var popup = document.querySelector('.modal');\nvar openPopupButton = document.querySelector('.button-open');\n\nopenPopupButton.addEventListener('click', function () {\n    console.log('Клик по кнопке');\n});\n`,tasks: [{message:"Добавьте в функцию-обработчик параметр <code class='keyvalue'>evt<code>",check:()=>~getJ().indexOf('function(evt)')},{message:"Внутри обработчика, перед выводом в консоль, отмените действие ссылки по умолчанию: <code>evt.preventDefault()</code>",check:()=>{if(~getJ().search(/function\((evt)\){\S*\1\.preventDefault\(\)\S*console\.log/)){document.querySelector('#view-after .button-open').addEventListener('click',()=>{Academy.vars.hE=true});return true;}}},{message:"Нажмите на кнопку <code class='keytext'>«Показать контакты»</code>",check:(o)=>o&&o.hE}],blocked:"4",editorOff:"4"},
'lesson1193':{theory:`<div><h1>Передайте функцию, пожалуйста</h1><p>Теперь переход по ссылке не происходит, и мы можем заменить вывод в консоль на добавление класса <code>modal--show</code> элементу из переменной <code>popup</code>.</p><p>Мы уже разобрались с синтаксисом событий и объектом <code>event</code>, но не обсудили ещё кое-что. Возможно, запись добавления обработчика показалась вам необычной.</p><pre><code>button.addEventListener('click', <mark>function () {\n    // Инструкции\n}</mark>);\n</code></pre><p>Мы передаём одну функцию в качестве параметра в другую функцию — в <code>addEventListener</code>. Такая запись может удивить, но это обычная практика — в JavaScript так делать можно. Тем более вы уже передавали функции в другие функции раньше!</p><pre><code>var getString = function () {\n    return 'Привет из функции!';\n}\n\nconsole.log(getString);    // Выведет код функции\nconsole.log(getString<mark>()</mark>); // Выведет 'Привет из функции!'\n</code></pre><p>Мы передали функцию и вызов функции в <code>console.log</code>. А ведь <code>console.log()</code> — тоже функция!</p><p>В случае с обработчиком мы делаем то же самое, только не записываем функцию в переменную.</p><pre><code>console.log(function () {\n    return 'Привет из функции!';\n});\n// Выведет код функции\n\nconsole.log(function () {\n    return 'Привет из функции!';\n}<mark>()</mark>);\n// Выведет 'Привет из функции!'\n</code></pre><p>У такой функции нет своего имени, она не записана в переменную. Мы создаём её там же, где передаём в другую функцию. Такие функции, которые создаются в момент передачи и не имеют названия, называются <i>анонимными функциями</i>.</p><p>Обратите внимание на самую важную часть — мы <b>передаём функцию</b> в обработчики, а <b>не вызываем</b> её. Если мы вызовем обработчик, код из него сразу выполнится, и в нужный момент наши инструкции не сработают. Код выполнится только один раз в момент вызова и больше не будет повторяться. Это распространённая ошибка, но так делать неправильно.</p><pre><code>// Так добавлять обработчик неправильно\n\nbutton.addEventListener('click', function () {\n    console.log('Клик по кнопке');\n}<mark>()</mark>);\n// Сообщение 'Клик по кнопке' сразу же выведется в консоль\n</code></pre><p>Вообще JavaScript выполняет программу последовательно, команду за командой. Но к событиям это не относится. Дело в том, что события не происходят последовательно, синхронно. Мы настраиваем обработчик, но инструкции выполняются не сразу, а только тогда, когда произойдёт событие. Это может произойти и через 5 минут после открытия сайта, и через 10, а может пользователь вообще не кликнет по ссылке или кнопке. Тогда событие не случится. События <b>асинхронны</b>, то есть происходят не по расписанию в какое-то конкретное время, друг за другом, а тогда, когда понадобится. В этом главная сила событий.</p><p>Допишем наш код, чтобы попап появлялся на странице после клика по кнопке <code>«Показать контакты»</code>.</p></div>`,html:tb1,css:tc1,hidden:th1,js:`var popup = document.querySelector('.modal');\nvar openPopupButton = document.querySelector('.button-open');\n\nopenPopupButton.addEventListener('click', function (evt) {\n    evt.preventDefault();\n    console.log('Клик по кнопке');\n});\n`,tasks:[{message:`В функции-обработчике удалите вывод в консоль и вместо него добавьте <code class='keyvalue'>popup</code> класс <code class='keyclass'>modal--show</code> с помощью <code>classList.add()</code>`,check:()=>~getJ().search(/function\(evt\)\{evt\.preventDefault\(\)\S*(?!console\.log)\S*popup\.classList\.add\(('|"|`)modal--show\1\)/)},{message:"Кликните по кнопке <code class='keytext'>«Показать контакты»</code> и убедитесь, что окно действительно появляется на странице.",check:(o)=>o&&o.popup&&o.popup.classList&&o.popup.classList.contains('modal--show')}],blocked:"4",editorOff:"4"},
'lesson1194':{theory:`<div><h1>Прячем всплывающее окно</h1><p>Мы добавили обработчик и теперь попап открывается, если нажать на кнопку <code>«Показать контакты»</code>. Сделаем так, чтобы попап закрывался по клику на крестик (кнопка с классом <code>button-close</code>).</p><p>Для этого сделаем уже знакомые нам действия: найдём кнопку, запишем в переменную, добавим ей обработчик клика. По клику будем удалять класс <code>modal--show</code> у попапа, чтобы он закрылся.</p><p>Как добавлять классы элементам мы знаем, а как их удалять?</p><p>Нужно использовать уже знакомый объект <code>classList</code>. Если для добавления класса мы используем метод <code>add()</code>, то для удаления надо обратиться к методу <code>remove()</code>, передав строку с классом, который нужно удалить. Выглядит это так:</p><pre><code>var popup = document.querySelector('.popup');\n// Перед названием селектора ставим точку\n\n<mark>popup.classList.remove('popup--open');</mark>\n// Перед названием класса точка не ставится\n</code></pre><p>Результат в разметке такой же, как при удалении класса вручную.</p><pre><code><i>&lt;!-- Исходное состояние разметки --&gt;</i>\n&lt;section class="popup popup--open"&gt;\n  …\n&lt;/section&gt;\n\n<i>&lt;!-- Состояние после вызова classList.remove --&gt;</i>\n&lt;section class="popup"&gt;\n  …\n&lt;/section&gt;\n</code></pre><p>Найдём кнопку с помощью <code>querySelector</code>. Только искать будем не по всему документу, а внутри элемента <code>popup</code>. Мы точно знаем, что кнопка находится там, поэтому избыточно запускать поиск по всему документу. Это ресурсоёмкая операция, потому что документ может быть очень большим.</p><p>Добавим обработчик клика по кнопке с классом <code>button-close</code>, проверим, что всё настроено правильно и попап действительно закрывается. В этом обработчике мы не будем указывать параметр <code>evt</code>, так как мы не собираемся использовать объект события внутри функции-обработчика. Элемент <code>button-close</code> — кнопка. У неё нет действий по умолчанию, которые надо отменять.</p><p>Кстати, обратите внимание, мы ставим точку, когда ищем элемент по селектору, но не ставим её при удалении или добавлении класса. Это правило важно запомнить. Чтобы было легче, можно помнить о том, что названия <code>classList.remove</code> и <code>classList.add</code> говорят сами за себя. Мы что-то делаем с классом элемента, поэтому нам надо передать только строку с названием класса. А искать элемент через <code>querySelector</code> можно разными способами. Мы говорили об этом раньше. Поэтому мы ставим точку перед названием класса, чтобы явно указать, что мы ищем именно по классу, а не тегу или как-то иначе.</p></div>`,html:tb1,css:tc1,hidden:th1,js:`var popup = document.querySelector('.modal');\nvar openPopupButton = document.querySelector('.button-open');\n\nopenPopupButton.addEventListener('click', function (evt) {\n    evt.preventDefault();\n    popup.classList.add('modal--show');\n});\n`,tasks:[{message:`После переменной <code class='keyvalue'>openPopupButton</code> создайте переменную <code>closePopupButton</code>, которая будет содержать элемент с классом <code class='keyclass'>button-close</code>. Ищите элемент внутри <code class='keyvalue'>popup</code>`,check:(o)=>{if(!o.hV){document.querySelector('#view-before section.modal').classList.add('modal--show');document.querySelector('#view-after section.modal').classList.add('modal--show')};return o&&o.closePopupButton&&o.closePopupButton===document.querySelector('#view-after .modal .button-close')}},{message:"Ниже, после обработчика <code class='keyvalue'>openPopupButton</code>, добавьте обработчик клика на <code class='keyvalue'>closePopupButton</code>",check:()=>~getJ().search(/(closePopupButton)=\S*\1\.addEventListener\(('|"|`)click\2,function\(\w*\)\{\S*\}\S*\)/)},{message:"Внутри обработчика удаляйте класс <code class='keyclass'>modal--show</code> у попапа с помощью <code>classList.remove()</code>",check:()=>{if(~getJ().search(/closePopupButton.addEventListener\(('|"|`)click\1,function\(\w*\)\{\S*popup.classList.remove\(('|"|`)modal--show\2\)\S*\}\)/)){document.querySelector('#view-after .modal .button-close').addEventListener('click',()=>{Academy.vars.hV=true});return true}}},{message:"Закройте попап кликом по кнопке <code class='keytext'>closePopupButton</code>",check:(o)=>{if(o&&o.popup&&o.popup.classList&&!o.popup.classList.contains('modal--show')&&o.hV){if(!Academy.vars.hA){Academy.viewScale="2";Academy.changeViewScale();Academy.vars.hA=true};return true}}}],blocked:"4",editorOff:"4"},
'lesson1195':{theory:`<div><h1>Жми на клавишу</h1><p>Попап уже открывается и закрывается по кликам, осталось дописать код так, чтобы попап закрывался по нажатию на клавишу <code>ESC</code>.</p><p>С кликом по кнопке мы вроде разобрались, а как повесить обработчик на нажатие клавиши?</p><p>У события «нажатие на клавишу» есть специальное название — <code>keydown</code>. Такое событие срабатывает при нажатии на любую клавишу. Обратите внимание, слушать это событие можно только на элементах, которые имеют состояние фокуса: поля ввода, кнопки, элементы с атрибутом <code>tabindex</code>, <b>документ</b>. При нажатии фокус должен находиться на соответствующем элементе.</p><pre><code>document.addEventListener(<mark>'keydown'</mark>, function() {\n    // Код отсюда выполнится при каждом нажатии любой клавиши\n});\n</code></pre><p>Добавим обработчик нажатия клавиши на документ и проверим, как он работает.</p><p style="padding: 10px 15px; border: 1px solid #e84e1b;"><strong>Важно!</strong> Чтобы обработчик среагировал на нажатия клавиш, нужно поставить фокус в наш мини-браузер. Кликните внутри мини-браузера, чтобы активировать окно. В обычной жизни так делать не надо, но в нашем интерфейсе мини-браузер встроен в обычный браузер, поэтому надо дать понять JavaScript, где вы сейчас находитесь.</p></div>`,html:tb1,css:tc1,hidden:th1,js:`var popup = document.querySelector('.modal');\nvar openPopupButton = document.querySelector('.button-open');\nvar closePopupButton = popup.querySelector('.button-close');\n\nopenPopupButton.addEventListener('click', function (evt) {\n    evt.preventDefault();\n    popup.classList.add('modal--show');\n});\n\nclosePopupButton.addEventListener('click', function () {\n    popup.classList.remove('modal--show');\n});\n`,tasks:[{message:"После всех обработчиков, добавьте обработчик нажатия клавиши <code class='keytext'>'keydown'</code> на <code class='keyvalue'>документ</code>.",check:()=>~getJ().search(/closePopupButton\.addEventListener\S*document\.addEventListener\(('|"|`)keydown\1,function\(\w*\)\{\S*\}\S*\)/)},{message:"Внутри обработчика добавьте вывод в консоль строки <code class='keytext'>'Я нажал какую-то клавишу'</code>",check:()=>~getJ().search(/document\.addEventListener\(('|"|`)keydown\1,function\(\w*\)\{\S*console\.log\(('|"|`)Янажалкакую-токлавишу\2\)\S*\}\S*\)/)},{message:"Кликните мышкой в мини-браузере для фокуса на нём, <code class='keytext'>три</code> раза нажмите <code class='keytext'>любую клавишу</code>, откройте <code class='keyword'>консоль</code>.",check:(o)=>{if(o&&o.log){var i=o.log.indexOf('Я нажал какую-то клавишу');if(~i){i=o.log.indexOf('Я нажал какую-то клавишу',i+1);return ~i&&~o.log.indexOf('Я нажал какую-то клавишу',i+1)&&!document.getElementById('lesson-console').classList.contains('off')}}}}],blocked:"4",editorOff:"4"},
'lesson1196':{theory:`<div><h1>Выбор клавиши</h1><p>Событие мы назвали, оно срабатывает при нажатии на любую клавишу. Но нам любая не подходит, нам нужен <code>ESC</code>. Как выполнять код по нажатию только на одну конкретную клавишу? Обратимся к уже знакомому объекту <code>event</code>.</p><p>Мы говорили раньше, что у объекта события есть много полезных свойств. Например, тип события, введённый символ, координаты курсора в момент наступления события и многое другое. В том числе и код клавиши, которую нажал пользователь. Это свойство называется <code>keyCode</code>.</p><p>С помощью этого свойства каждую клавишу можно определить по коду. Например, у <code>Enter</code> код <code>13</code>, а у <code>ESC</code> — код <code>27</code>. Эти номера универсальны и одинаковы в любой раскладке. Найти код любой клавиши можно <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode" target="_blank" rel="noopener">здесь</a>.</p><p>Теперь мы знаем, что есть объект <code>event</code>, который содержит номер нажатой клавиши в свойстве <code>keyCode</code>, и знаем код необходимой клавиши. Осталось всё это собрать в одном обработчике.</p><pre><code>document.addEventListener('keydown', function(<mark>evt</mark>) {\n// Проверяем, что код клавиши равен 27\nif (<mark>evt.keyCode === 27</mark>) {\n    // Код отсюда выполнится только при нажатии ESC\n}\n});\n</code></pre><p>Настроим наш обработчик, чтобы инструкции выполнялись только при нажатии <code>ESC</code>.</p><p>Кстати, кроме <code>keyCode</code> есть и другие свойства для определения нажатой клавиши. Например, <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key" target="_blank" rel="noopener">key</a>. Его отличие в том, что он возвращает не код клавиши, а её название в виде строки: «Enter», «Alt», «Escape». Ещё есть свойство <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code" target="_blank" rel="noopener">code</a>. Оно тоже возвращает название клавиши, при этом на значение не влияет выбранный язык клавиатуры. Эти свойства пока поддерживаются не во всех браузерах, но когда поддержка станет лучше, стоит начать использовать их вместо <code>keyCode</code> в соответствии с современным стандартом JavaScript.</p></div>`,html:tb1,css:tc1,hidden:th1,js:`var popup = document.querySelector('.modal');\nvar openPopupButton = document.querySelector('.button-open');\nvar closePopupButton = popup.querySelector('.button-close');\n\nopenPopupButton.addEventListener('click', function (evt) {\n    evt.preventDefault();\n    popup.classList.add('modal--show');\n});\n\nclosePopupButton.addEventListener('click', function () {\n    popup.classList.remove('modal--show');\n});\n\ndocument.addEventListener('keydown', function () {\n    console.log('Я нажал какую-то клавишу');\n});\n`,tasks:[{message:"В функцию-обработчик клавиатурного события добавьте параметр <code class='keyvalue'>evt</code>",check:()=>~getJ().search(/document\.addEventListener\S*function\(evt\)\{\S*\}\)/)},{message:"Внутри обработчика проверяйте, что код нажатой клавиши <code class='keyvalue'>evt.keyCode</code> равен <code class='keytext'>27</code>",check:()=>~getJ().search(/document\.addEventListener\S*function\((\w+)\)\{\S*if\(\1\.keyCode={2,3}27\)\S*\}\S*\)/)},{message:"Удалите вывод в <code class='keyword'>консоль</code> из обработчика и добавьте в тело условия вывод в <code class='keyword'>консоль</code> строки <code class='keytext'>'Я нажал ESC'</code>",check:()=>~getJ().search(/document\.addEventListener\(\S*\((\w+)\)\{\S*(?!console\.log)if\(\1\.keyCode={2,3}27\)(\{console\.log\(('|"|`)ЯнажалESC\3\)\S*\}|console\.log\(('|"|`)ЯнажалESC\4\);)\S*\}\S*\)/)},{message:"Кликните мышкой в мини-браузере для фокуса на нём, нажмите <code class='keyvalue'>ESC</code>, откройте <code class='keyword'>консоль</code>.",check:(o)=>o&&o.log&&~o.log.indexOf('Я нажал ESC')&&!document.getElementById('lesson-console').classList.contains('off')}],blocked:"4",editorOff:"4"},
'lesson1197':{theory:`<div><h1>Одним нажатием</h1><p>Мы настроили обработчик, теперь инструкции выполняются только при нажатии клавиши <code>ESC</code>.</p><p>Нам осталось удалить класс <code>modal--show</code> у попапа, чтобы он действительно закрывался каждый раз при нажатии <code>ESC</code>.</p><p>Для этого будем использовать уже знакомый нам метод <code>remove</code> объекта <code>classList</code>.</p></div>`,html:tb1,css:tc1,hidden:th1,js:`var popup = document.querySelector('.modal');\nvar openPopupButton = document.querySelector('.button-open');\nvar closePopupButton = popup.querySelector('.button-close');\n\nopenPopupButton.addEventListener('click', function (evt) {\n    evt.preventDefault();\n    popup.classList.add('modal--show');\n});\n\nclosePopupButton.addEventListener('click', function () {\n    popup.classList.remove('modal--show');\n});\n\ndocument.addEventListener('keydown', function (evt) {\n    if (evt.keyCode === 27) {\n        console.log('Я нажал ESC');\n    }\n});\n`,tasks:[{message:"В обработчике клавиатурного события, внутри условия, удалите вывод в <code class='keyword'>консоль</code> и добавьте удаление класса <code class='keyclass'>modal--show</code> у <code class='keytext'>попапа</code>.",check:(o)=>{if(!o.hE){document.querySelector('#view-before section.modal').classList.add('modal--show');document.querySelector('#view-after section.modal').classList.add('modal--show');Academy.viewScale="2";Academy.changeViewScale();}if(~getJ().search(/document\.addEventListener\S*function\((\w+)\)\S*if\(\1\.keyCode={2,3}27\)\{\S*(?!console.log)popup\.classList\.remove\(('|"|`)modal--show\2\)\S*(?!console.log)\S*\}\S*\}\)/)){document.getElementById('view-after').addEventListener('keydown',function(e){if(e.keyCode===27){Academy.vars.hE=true;Academy.vars.hA=true;}});return true;}}},{message:"Закройте попап, нажав клавишу <code class='keyword'>ESC</code>. Не забудьте поставить фокус в мини-браузер.",check:(o)=>o.hA}],blocked:"4",editorOff:"4"},
'lesson1198':{theory:`<section><h1>Конспект «События в JavaScript». 1 часть</h1><p><b>События</b> — действия пользователя на странице (клик по кнопке, нажатие клавиши).</p><h3>Добавление обработчиков событий</h3><pre><code>button.<mark>addEventListener('click', function () {\n    // Инструкции\n})</mark>;\n</code></pre><p>В примере:</p><ul><li><code>button</code> — элемент, на котором мы хотим «слушать» событие.</li><li><code>addEventListener()</code> — функция добавления обработчика события на элемент.</li><li><code>'click'</code> — общепринятое название события, первый параметр функции <code>addEventListener</code>. Названия всех событий можно посмотреть <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener">здесь</a>.</li><li>Второй параметр <code>addEventListener</code> — функция-обработчик, в ней записаны инструкции, которые выполнятся, только <b>когда произойдёт событие</b>.</li></ul><p>Обратите внимание, мы <b>передаём функцию, а не её вызов</b>. Если мы вызовем функцию, код из этой функции выполнится сразу и больше не сработает. А нам нужно, чтобы код выполнился <b>асинхронно</b> — в момент, когда произойдёт событие.</p><pre><code>// Так добавлять обработчик неправильно\n\nbutton.addEventListener('click', function () {\n    console.log('Клик по кнопке');\n}<mark>()</mark>);\n// Сообщение 'Клик по кнопке' сразу же выведется в консоль\n\n\n// А такой код верный\n\nbutton.addEventListener('click', function () {\n    console.log('Клик по кнопке');\n});\n// Сообщение выведется, когда произойдёт событие клика\n</code></pre><p>В примере выше мы передаём в обработчик функцию, у которой нет своего имени, она не записана в переменную. Мы создали её там же, где передаём. Такие функции, которые создаются в момент передачи и не имеют имени, называются <i>анонимными функциями</i>.</p><h3>Объект event</h3><p>Объект <code>event</code> — параметр функции-обработчика. Он всегда передаётся браузером в эту функцию в момент наступления события. Этот объект содержит много полезных свойств и методов.</p><p>Чтобы использовать <code>event</code>, достаточно указать этот объект параметром функции-обработчика и написать инструкции. Остальное сделает JavaScript. Среди некоторых разработчиков принято называть параметр сокращённо — <code>evt</code>, во избежание ошибок.</p><h3>Действия по умолчанию</h3><p>Некоторые элементы страницы имеют действия по умолчанию или дефолтные действия. Например, клик по кнопке отправления формы вызывает отправку данных этой формы на сервер, а при клике по ссылке браузер переходит по этой ссылке.</p><p>Объект <code>event</code> содержит метод, который отменяет действие элемента по умолчанию: <code>preventDefault()</code>.</p><pre><code>link.addEventListener('click', function(<mark>evt</mark>) {\n    // Отменяем действие по умолчанию\n    <mark>evt.preventDefault();</mark>\n\n    // Добавляем инструкции для события клика\n    console.log('Произошёл клик');\n});\n</code></pre><h3>Клавиатурные события</h3><p>У события «нажатие на клавишу» есть специальное название — <code>'keydown'</code>. Такое событие срабатывает при нажатии на <b>любую клавишу</b>. Обратите внимание, слушать это событие можно только на элементах, которые имеют состояние фокуса: поля ввода, кнопки, элементы с атрибутом <code>tabindex</code>, <b>документ</b>. При нажатии фокус должен находиться на соответствующем элементе.</p><p>Если мы хотим поймать нажатие какой-то конкретной клавиши, можно обратиться к свойству <code>keyCode</code> объекта <code>event</code>. Это свойство содержит код нажатой клавиши. Например, у <code>Enter</code> код <code>13</code>, а у <code>ESC</code> — <code>27</code>. Эти номера универсальны и одинаковы в любой раскладке. Найти код любой клавиши можно <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode" target="_blank" rel="noopener">здесь</a>.</p><pre><code>document.addEventListener('keydown', function(<mark>evt</mark>) {\n// Проверяем, что код клавиши равен 27\nif (<mark>evt.keyCode === 27</mark>) {\n    // Код отсюда выполнится только при нажатии ESC\n}\n});\n</code></pre><p>Кроме <code>keyCode</code> есть и другие свойства для определения нажатой клавиши. Например, <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key" target="_blank" rel="noopener">key</a> и <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code" target="_blank" rel="noopener">code</a>. Они возвращают названия клавиш, а не их номера. Эти свойства пока поддерживаются не во всех браузерах, но когда поддержка станет лучше, стоит начать использовать их вместо <code>keyCode</code> в соответствии с современным стандартом JavaScript.</p></section>`,html:`<!DOCTYPE html>\n<html>\n<head>\n  <title>CooCoo</title>\n</head>\n<body>\n  <img class="blur coocoo" src="images/courses/58/coo.jpg">\n</body>\n</html>`,css:`img {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 47vw;\n}\n\n.blur {\n  -webkit-filter: blur(5px);\n     -moz-filter: blur(5px);\n       -o-filter: blur(5px);\n      -ms-filter: blur(5px);\n          filter: blur(5px);\n}`,hidden:``,js:``,tasks:[{message:`Запишите картинку с классом <code class='keyclass'>coocoo</code> в переменную <code class='keyvalue'>image</code>, добавьте для <code>document</code> обработчик нажатия клавиш, который при нажатии клавиши <code class="keyword">Enter</code> (<code class='keyvalue'>keyCode</code> этой клавиши - <code class='keytext'>13</code>) уберёт у картинки класс <code class='keyclass'>blur</code>. Не забудьте перед нажатием клавиши <code class='keytext'>кликнуть</code> по мини-браузеру, чтобы он получил фокус!`,check:(o)=>{if(~getJ().search(/document\.addEventListener\(('|"|`)keydown\1,function\((\w+)\)\{\S*if\(\2\.keyCode={2,3}13\)\{{0,1}image\.classList\.remove\(('|"|`)blur\3\);{0,1}\}{0,1}\S*\}\S*\)/))document.querySelector('#view-after .view-body').addEventListener("keydown",function(e){if(e.keyCode===13&&!document.querySelector('#view-after .coocoo').classList.contains('blur'))Academy.vars.hA=true});return o.image===document.querySelector('#view-after .coocoo')&&o.hA}}],blocked:"4",editorOff:"4"},
'lesson1199':{theory:`<div><h1>Четырнадцатая программа: «Не надо стесняться»</h1><p>Кексу понравилось, как вы справились с магазином сладостей. Он спешит дать вам новое задание. В этот раз надо написать код для магазина игрушек ручной работы. Вот точное ТЗ от Босса.</p><blockquote><p>Мяу! Нужно запрограммировать взаимодействие с пользователем.</p><p>В разметке есть попап (класс <code>popup</code>).</p><p>Клик по кнопке «Показать подробности» (класс <code>button-show</code>) должен вызвать показ окна на странице. У попапа должен появиться класс <code>popup--open</code>.</p><p>Клик по крестику в теле попапа (класс <code>button-hide</code>) должен спрятать окно со страницы. Для этого нужно удалить класс <code>popup--open</code> у попапа.</p><p>Кроме этого, если окно на странице, а пользователь нажал клавишу ESC, попап тоже должен исчезнуть. Закрытие должно срабатывать <b>только</b> по этой клавише, нажатие на другие клавиши не должны влиять на положение всплывающего окна.</p><p>И не забывай, что кнопка «Показать подробности» свёрстана ссылкой. Не забудь отменить переход по этой ссылке.</p><p>Жду результата!</p></blockquote><p>Если вы перейдёте по ссылке внутри мини-браузера и захотите вернуться на первую страницу, кликните на кнопку <сode>Назад</code>.</p></div>`,html:`<!DOCTYPE html>\n<html>\n<head lang="ru">\n  <meta charset="utf-8">\n  <title>Магазин «Мишка»</title>\n  <link href="style.css" rel="stylesheet">\n</head>\n<body>\n  <h1 class="visually-hidden">Каталог товаров</h1>\n\n  <section class="card">\n    <h2 class="card__title">Зайчик-попрыгайчик</h2>\n    <img class="card__img" src="images/courses/58/rabbit.jpg" width="" height="" alt="Зайчик-попрыгайчик">\n    <p class="card__text">Рост 30 см, вес 200 г</p>\n    <p><a class="card__button button-show" onclick="fH1()">Показать подробности</a></p>\n  </section>\n\n  <section class="popup">\n    <div class="popup__content">\n      <h2 class="visually-hidden">Подробности о товаре</h2>\n      <ul class="features">\n        <li class="feature feature--eco">\n          <p>Экологически чистые материалы</p>\n        </li>\n        <li class="feature feature--handmade">\n          <p>Связано вручную с любовью и умилением</p>\n        </li>\n        <li class="feature feature--gift">\n          <p>Поставляется в подарочной упаковке</p>\n        </li>\n        <li class="feature feature--like">\n          <p>Увеличивает лайки на фотографиях</p>\n        </li>\n      </ul>\n      <button class="popup__button button-hide" type="button">Закрыть</button>\n    </div>\n  </section>\n  <div class="contacts-html off">\n    <h1>Подробности о товаре</h1>\n    <ul class="features">\n      <li class="feature feature--eco">\n        <p>Экологически чистые материалы</p>\n      </li>\n      <li class="feature feature--handmade">\n        <p>Связано вручную с любовью и умилением</p>\n      </li>\n      <li class="feature feature--gift">\n        <p>Поставляется в подарочной упаковке</p>\n      </li>\n      <li class="feature feature--like">\n        <p>Увеличивает лайки на фотографиях</p>\n      </li>\n    </ul>\n    <a class="card__button button-show" onclick="fH1()">Назад</a>\n  </div>\n  <script src="script.js"></script>\n</body>\n</html>`,css:`h3 {\n  margin: 0.5em 0;\n}\n\np {\n  margin: 0.5em 0 2em;\n}\n\n.card {\n  display: flex;\n  flex-direction: column;\n  margin: 50px auto 0;\n  position: relative;\n  width: 316px;\n  border: 1px solid #ededed;\n}\n\n.card.off {\n  display: none;\n}\n\n.card__img {\n  order: -1;\n}\n\n.card__text {\n  position: relative;\n  margin-top: 0;\n  margin-left: 28px;\n  margin-bottom: 40px;\n  color: #444444;\n}\n\n.card__text::after {\n  position: absolute;\n  content: "";\n  height: 1px;\n  width: 260px;\n  left: 0;\n  bottom: -20px;\n  background-color: #ececec;\n}\n\n.card__title {\n  margin-top: 18px;\n  margin-left: 28px;\n  margin-bottom: 5px;\n  font-family: "Verdana", "Helvetica Neue", "Helvetica", "Arial", sans-serif;\n  font-size: 16px;\n  font-weight: 700;\n  line-height: 24px;\n}\n\n.card__controls {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  padding-top: 20px;\n  padding-bottom: 20px;\n}\n\n.card__button {\n  margin: 0 auto;\n  text-decoration: none;\n  display: block;\n  width: 260px;\n  padding: 0 10px;\n  padding-top: 16px;\n  padding-bottom: 19px;\n  border: 2px solid #444444;\n  color: #444444;\n  font-size: 16px;\n  font-family: inherit;\n  line-height: 16px;\n  font-weight: 700;\n  text-align: center;\n  text-transform: uppercase;\n  background-color: #ffffff;\n  cursor: pointer;\n}\n\n.card__button:hover,\n.card__button:focus {\n  background-color: #444444;\n  color: #ffffff;\n}\n\n.card__button:active {\n  background-color: #444444;\n  color: #797979;\n}\n\n.features {\n  list-style: none;\n  margin: 0;\n  margin-left: 50px;\n  padding: 0;\n}\n\n.feature {\n  position: relative;\n}\n\n.feature::before {\n  content: "";\n  position: absolute;\n  left: -50px;\n  top: -5px;\n  background-repeat: no-repeat;\n}\n\n.feature--eco::before {\n  width: 32px;\n  height: 37px;\n  background-image: url("images/courses/58/icon-feature-flower.svg");\n}\n\n.feature--handmade::before {\n  width: 34px;\n  height: 34px;\n  background-image: url("images/courses/58/icon-feature-ball.svg");\n}\n\n.feature--gift::before {\n  width: 33px;\n  height: 33px;\n  background-image: url("images/courses/58/icon-feature-gift.svg");\n}\n\n.feature--like::before {\n  width: 33px;\n  height: 28px;\n  background-image: url("images/courses/58/icon-feature-heart.svg");\n}\n\n.popup {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.popup--open {\n  display: block;\n}\n\n.popup::after {\n  content: "";\n  position: fixed;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  background-color: rgba(0, 0, 0, 0.3);\n  z-index: 1;\n}\n\n.popup__content {\n  position: relative;\n  width: 300px;\n  margin-top: 100px;\n  margin-left: auto;\n  margin-right: auto;\n  padding: 30px 70px 15px;\n  background-color: #ffffff;\n  box-shadow: -1px 5px 12px 0 rgba(89, 90, 90, 0.3);\n  z-index: 2;\n}\n\n.popup__button {\n  position: absolute;\n  top: 20px;\n  right: 20px;\n  width: 20px;\n  height: 20px;\n  font-size: 0;\n  background: none;\n  border: 0;\n}\n\n.popup__button::after,\n.popup__button::before {\n  content: "";\n  position: absolute;\n  right: 0;\n  top: 20px;\n  width: 26px;\n  height: 6px;\n  margin: -13px -3px;\n  color: #bfbfbf;\n  background-color: currentColor;\n}\n\n.popup__button::before {\n  transform: rotate(45deg);\n}\n\n.popup__button::after {\n  transform: rotate(-45deg);\n}\n\n.popup__button:hover,\n.popup__button:focus {\n  color: #9e9e9e;\n}\n\n.popup__button:active {\n  color: #4a4a4a;\n}\n\n.visually-hidden {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  border: 0;\n  padding: 0;\n\n  white-space: nowrap;\n\n  clip-path: inset(100%);\n  clip: rect(0 0 0 0);\n  overflow: hidden;\n}`,hidden:`body {margin:0;padding:10px;font-family:"Open Sans","Helvetica Neue","Helvetica","Arial",sans-serif;font-size:14px;line-height:24px;color:black;background-color:white;font-style:normal;}.no-interactions .card__button:hover,.no-interactions .card__button:focus,.no-interactions .card__button:active{color:#444444;background-color:#ffffff;outline:none;}.no-interactions .popup__button:hover,.no-interactions .popup__button:focus,.no-interactions .popup__button:active{color:#bfbfbf;outline:none;}`,js:``,tasks:[{message:`<button onclick="fH2()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p>Нужно запрограммировать взаимодействие с пользователем.</p><p>В разметке есть попап (класс <code class='keyclass'>popup</code>).</p><p>Клик по кнопке <code class='keytext'>«Показать подробности»</code> (класс <code class='keyclass'>button-show</code>) должен вызвать показ окна на странице. У попапа должен появиться класс <code class='keyclass'>popup--open</code>.</p><p>Клик крестику в теле попапа (класс <code class='keyclass'>button-hide</code>) должен спрятать окно со страницы. Для этого нужно удалить класс <code class='keyclass'>popup--open</code> у окна.</p><p>Кроме этого, если окно на странице, а пользователь нажал клавишу <code class="keyword">ESC</code>, попап тоже должен исчезнуть. Закрытие попапа должно срабатывать только по этой клавише, нажатие на другие клавиши не должны влиять на положение всплывающего окна.</p><p>И не забывай, что кнопка <code class='keytext'>«Показать подробности»</code> свёрстана ссылкой. Не забудь <code class='keytext'>отменить переход</code> по этой ссылке.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:()=>{if(!Academy.vars.hE){Academy.vars.hE=true;var p=document.querySelector('#view-before .popup');document.querySelector('#view-before .button-show').onclick="";document.querySelector('#view-before .button-show').addEventListener('click',function(evt){evt.preventDefault();p.classList.add('popup--open')});document.querySelector('#view-before .button-hide').onclick="";document.querySelector('#view-before .button-hide').addEventListener('click',function(evt){p.classList.remove('popup--open')});document.querySelector('#view-before .view-body').addEventListener('keydown',function(e){if(e.keyCode===27)p.classList.remove('popup--open');});setT()}return Academy.vars.hA;}}],blocked:"4",editorOff:"",},
'lesson1200':{theory:`<div><h1>Добро пожаловать в нашу галерею</h1><blockquote><p>Мяу! Ты хорошо справился с задачей, но нет времени на отдых!</p><p>Нужно запрограммировать галерею с моими фотографиями для сайта нашей веб-студии. Заказчики должны знать героя веб-разработки в лицо!</p><p>Галерея состоит из нескольких миниатюр (элементы с классом <code>gallery__photo-preview</code>) и большой фотографии (класс <code>full-photo</code>). По клику на миниатюру должно меняться большое изображение. Большая картинка должна соответствовать превью, по которой кликнул пользователь.</p><p>Данные для изображений собраны в массив <code>photos</code>. Каждый элемент массива — путь до полноразмерной фотографии. Порядок элементов в этом массиве такой же, как и порядок миниатюр в разметке.</p></blockquote><p>Верстальщик уже всё подготовил: изображения превью лежат внутри кнопок с классом <code>gallery__photo-preview</code>, клики именно по этим кнопкам будут менять содержимое большого изображения (класс <code>full-photo</code>). От нас, как обычно, требуется запрограммировать взаимодействие интерфейса с пользователем.</p><p>Сначала мы найдём все миниатюры с помощью <code>querySelectorAll</code> и большое изображение через <code>querySelector</code>, запишем найденные элементы в переменные.</p><p>Мы знакомились с <code>querySelectorAll</code> в заданиях главы «Знакомство с JavaScript в браузере». Загляните туда, если вы забыли, как работает этот метод.</p></div>`,html:tb2,css:tc2,hidden:th2,js:tj1,tasks:[{message:`После массива данных создайте переменную <code class='keyvalue'>thumbnails</code>, запишите в неё все элементы с классом <code class='keyclass'>gallery__photo-preview</code>, найденные с помощью <code>querySelectorAll</code>`,check:(o)=>{if(o&&o.thumbnails&&o.thumbnails.length){var c=document.querySelectorAll('#view-after .gallery__photo-preview');var t=Array.prototype.slice.call(o.thumbnails);for(var i=0;i<c.length;i++)if(!~t.indexOf(c[i]))return false;return true;}}},{message:`Ниже создайте переменную <code class='keyvalue'>fullPhoto</code> и запишите в неё изображение с классом <code class='keyclass'>full-photo</code>, найденное с помощью <code>querySelector</code>`,check:(o)=>o&&o.fullPhoto===document.querySelector('#view-after .full-photo')}],blocked:"4",editorOff:""},
'lesson1201':{theory:`<div><h1>Click ’Em All!</h1><p>Мы нашли все изображения на странице, теперь можно программировать логику. Взаимодействие должно быть таким: пользователь кликает по превью → меняется большая картинка.</p><p>Первым делом нужно добавить обработчики клика на каждую миниатюру. Все миниатюры хранятся в коллекции <code>thumbnails</code>. Мы можем перебрать эту коллекцию в цикле, добавляя обработчик клика на текущий элемент коллекции. Так мы добавим обработчик на каждую миниатюру.</p><p>Внутри обработчика выведем строку в консоль, а затем попробуем кликнуть по миниатюрам. Так мы убедимся, что обработчики срабатывают.</p></div>`,html:tb2,css:tc2,hidden:th2,js:tj1+`\nvar thumbnails = document.querySelectorAll('.gallery__photo-preview');\nvar fullPhoto = document.querySelector('.full-photo');\n`,tasks:[{message:`После переменных напишите цикл <code class="keyword">for</code>, который увеличивает счётчик <code class='keyvalue'>i</code> на единицу от <code class='keytext'>0</code> до <code class='keytext'>длины</code> коллекции <code class='keyvalue'>thumbnails</code> (не включая последнее значение).`,check:(o)=>o&&o.thumbnails&&~getJ().search(/thumbnails=\S*for\(\w{0,3}i=0;i<thumbnails.length;(i\+\+|i=i\+1|i\+=1)\)\{\S*\}/)},{message:"Внутри цикла добавьте обработчик клика на текущий элемент массива <code class='keyvalue'>thumbnails[<code class='keytext'>i</code>]</code>",check:(o)=>o&&o.thumbnails&&~getJ().search(/thumbnails=\S*for\(\w{0,3}i=0;i<thumbnails.length;(i\+\+|i=i\+1|i\+=1)\)\{\S*thumbnails\[i\]\.addEventListener\(('|"|`)click\2,function\(\w*\)\{\S*\}\S*\)\S*\}/)},{message:"Внутри обработчика добавьте <code class='keytext'>вывод в консоль</code> строки <code class='keytext'>'Клик по картинке'</code>",check:(o)=>o&&o.thumbnails&&~getJ().search(/thumbnails=\S*for\(\w{0,3}i=0;i<thumbnails.length;(i\+\+|i=i\+1|i\+=1)\)\{\S*thumbnails\[i\]\.addEventListener\(('|"|`)click\2,function\(\w*\)\{\S*console\.log\(('|"|`)Кликпокартинке\3\)\S*\}\S*\)\S*\}/)},{message:"<code class='keytext'>Кликните</code> по одной из миниатюр и загляните в <code class='keyword'>консоль</code>.",check:(o)=>o&&o.log&&~o.log.indexOf("Клик по картинке")}],blocked:"4",editorOff:"4"},
'lesson1202':{theory:`<div><h1>Добавим картинку</h1><p>Обработчики клика добавили, убедились, что всё работает. Как заставить большую картинку меняться по кликам пользователя?</p><p>У изображений есть атрибут <code>src</code>, которым можно управлять из JavaScript. Мы уже говорили об этом раньше.</p><p>Чтобы изображение элемента с классом <code>full-photo</code> (переменная <code>fullPhoto</code>) менялось, должно измениться значение <code>src</code> этого элемента.</p><p>У нас есть массив с данными <code>photos</code>. Когда Кекс давал нам задание, он отметил, что «порядок элементов в этом массиве такой же, как и порядок миниатюр в разметке». Все превью находятся в коллекции <code>thumbnails</code>. Получается, элементы массива <code>photos</code> подходят элементам из коллекции <code>thumbnails</code> с тем же индексом.</p><p>Например, пользователь кликнул по самой первой миниатюре в разметке. Она же <code>thumbnails[0]</code> в коллекции. Тогда в большой картинке должно появиться изображение с адресом <code>photos[0]</code>. Получается такой код:</p><pre><code>thumbnails<mark>[0]</mark>.addEventListener('click', function () {\n    fullPhoto.src = photos<mark>[0]</mark>;\n});\n</code></pre><p>Добавим код внутрь обработчика. Будем подставлять в атрибут <code>src</code> значение элемента из массива <code>photos</code>. Индексы миниатюры и элемента с адресом картинки будут совпадать.</p></div>`,html:tb2,css:tc2,hidden:th2,js:tj1+`\nvar thumbnails = document.querySelectorAll('.gallery__photo-preview');\nvar fullPhoto = document.querySelector('.full-photo');\n\nfor (var i = 0; i < thumbnails.length; i++) {\n    thumbnails[i].addEventListener('click', function () {\n        console.log('Клик по картинке');\n    });\n}\n`,tasks:[{message:`В обработчике замените вывод строки в консоль на запись пути картинки в атрибут <code class="keyword">src</code>: <code>fullPhoto.src</code> <code class='keyvalue'>=</code> <code class='keyvalue'>photos[<code class='keytext'>i</code>]</code>`,check:(o)=>{if(o&&o.thumbnails&&~getJ().search(/thumbnails=\S*for\(\w{0,3}i=0;i<thumbnails.length;(i\+\+|i=i\+1|i\+=1)\)\{\S*thumbnails\[i\]\.addEventListener\(('|"|`)click\2,function\(\w*\)\{\S*(?!console\.log)\S*fullPhoto\.src=photos\[i\]\S*(?!console\.log)\S*\}\S*\)\S*\}/)){var t=document.querySelectorAll('#view-after .gallery__photo-preview');for(var i=0;i<t.length;i++)t[i].addEventListener('click',function(){Academy.vars.hA=true});return true;}}},{message:`<code class='keytext'>Кликните</code> на любую миниатюру в галерее. Обратите внимание, что программа работает с ошибкой. Дальше мы разберёмся, почему так произошло.`,check:(o)=>o&&o.hA}],blocked:"4",editorOff:"4"},
'lesson1203':{theory:`<div><h1>В систему закралась ошибка</h1><p>Кажется, в нашей программе что-то пошло не так. Кликаем по превью, а большая картинка не появляется. Мы проверили работу программы в предыдущем задании — сообщения в консоль выводились.</p><p>Что делают разработчики в такой ситуации? Отлаживают код.</p><p>Программа перестала работать, когда мы добавили эту запись:</p><pre><code>fullPhoto.src = photos[i];\n</code></pre><p>Что с ней может быть не так? Часть <code>fullPhoto.src</code> не вызывает подозрений — мы нашли изображение по классу, сохранили в переменную, а теперь хотим что-то записать в атрибут <code>src</code>. А вот <code>photos[i]</code> может быть причиной сбоя.</p><p>Дело не в названии массива <code>photos</code>, его мы написали правильно. Остаётся индекс и текущий элемент массива. Возможно, с ними что-то не то.</p><p>Мы выведем их в консоль и проверим. Кажется, проблема именно там.</p></div>`,html:tb2,css:tc2,hidden:th2,js:tj1+`\nvar thumbnails = document.querySelectorAll('.gallery__photo-preview');\nvar fullPhoto = document.querySelector('.full-photo');\n\nfor (var i = 0; i < thumbnails.length; i++) {\n    thumbnails[i].addEventListener('click', function () {\n        fullPhoto.src = photos[i];\n    });\n}\n`,tasks:[{message:"Внутри обработчика, в самом начале, выведите в консоль счётчик <code class=keyvalue>i</code>",check:(o)=>o&&o.thumbnails&&~getJ().search(/function\(\)\{\S*console\.log\(i\)\S*fullPhoto\.src=photos\[i\]\S*\}/)},{message:"На следующей строке выведите в консоль <code class=keyvalue>photos[<code class=keytext>i</code>]</code>",check:(o)=>{if(o&&o.thumbnails&&~getJ().search(/function\(\)\{\S*console\.log\(i\)\S*console\.log\(photos\[i\]\)\S*\}/)){if(!o.hA){Academy.vars.hL=()=>{Academy.vars.hA++};Academy.vars.hA=1};var t=document.querySelectorAll('#view-after .gallery__photo-preview');for(var i=0;i<t.length;i++){t[i].removeEventListener('click',Academy.vars.hL);t[i].addEventListener('click',Academy.vars.hL)};return true}}},{message:"<code class='keytext'>Кликните</code> по двум любым миниатюрам и загляните в консоль",check:(o)=>o&&o.hA>2}],blocked:"4",editorOff:"4"},
'lesson1204':{theory:`<div><h1>Область видимости</h1><p>Ошибка обнаружена! Индекс последнего элемента в массиве <code>photos</code> — <code>4</code>, а значение <code>i</code> в нашем коде <code>5</code>, по какой миниатюре мы бы ни кликнули. В массиве <code>photos</code> у нас нет элемента с таким индексом, поэтому мы и получаем <code>undefined</code> вместо адреса изображения и никакой картинки не появляется. Но почему такое вообще происходит?</p><p>Давайте немного отойдём в сторону от нашей задачи и разберёмся с одной важной концепцией JavaScript. Это поможет решить нашу проблему с галереей.</p><p>Напишем функцию <code>eatDinner</code>. Она выводит в консоль сообщения о нашем обеде. У неё есть параметр <code>drink</code> и переменная <code>food</code></p><pre><code>var eatDinner = function (drink) {\n    var food = 'макароны';\n    console.log('Поел ' + food);\n    console.log('Выпил ' + drink);\n};\n\neatDinner('компот');\n// Выведет 'Поел макароны'\n// Выведет 'Выпил компот'\n\nconsole.log('Поел ' + food);\n// Выведет ошибку\n\nconsole.log('Выпил ' + drink);\n// Выведет ошибку\n</code></pre><p>Если мы попробуем снаружи получить доступ к переменной <code>food</code> у нас ничего не получится — консоль выдаст ошибку. Потому что <b>переменные из тела функции доступны только внутри этой функции</b>. Снаружи их получить нельзя.</p><p>То же самое произойдёт, если мы захотим обратиться снаружи к параметру функции. Параметр хоть и задаётся снаружи, ведёт себя, как переменная внутри функции.</p><p>Почему так?</p><p>Потому что у каждой функции есть <b>область видимости</b> — все значения, доступные для этой функции. Область видимости ограничивается самой функцией. Так как переменная <code>food</code> объявлена внутри функции <code>eatDinner</code>, она доступна только внутри области видимости этой функции, как и параметр <code>drink</code>. Такие переменные называются <i>локальными переменными</i> функции. Их область видимости ограничена функцией, в которой они объявлены, и за её пределами эти переменные получить нельзя, поэтому такая область видимости тоже называется <i>локальной</i>.</p><p>Давайте в этом убедимся. Вызовем функцию, а затем снаружи попробуем получить доступ к параметру и переменной из тела функции <code>eatDinner</code>.</p></div>`,html:``,css:``,hidden:``,js:`var eatDinner = function (drink) {\n    var food = 'котлеты';\n    console.log('Поел ' + food);\n    console.log('Выпил ' + drink);\n};\n`,tasks:[{message:"Ниже, после объявления функции <code>eatDinner</code>, вызовите эту функцию с аргументом <code class='keytext'>'чай'</code>",check:()=>~getJ().search(/eatDinner=function\S*\{\S*\}\S*eatDinner\(('|"|`)чай\1\)/)},{message:"После вызова функции выведите в консоль строку <code class='keytext'>'Поел '<code> <code class='keyvalue'>+ food</code>",check:(o)=>o.hA||(~getJ().search(/eatDinner=function\S*\{\S*\}\S*eatDinner\(('|"|`)чай\1\)\S*console\.log\(('|"|`)Поел\2\+food\)/)&&(Academy.vars.hA=true))},{message: "В этом выводе в консоль замените строку на <code class='keytext'>'Выпил '<code> <code class='keyvalue'>+ drink</code>",check:(o)=>~getJ().search(/eatDinner=function\S*\{\S*\}\S*eatDinner\(('|"|`)чай\1\)\S*console\.log\(('|"|`)Выпил\2\+drink\)/)}],blocked:"4",editorOff:"8"},
'lesson1205':{theory:`<div><h1>Глобальная область видимости</h1><p>Локальная область видимости ограничена функцией, поэтому мы не можем получить переменные функции извне. Но внутри функций, а не снаружи, всё работает по-другому.</p><p>Если внутри функции есть обращение к какой-то <b>не</b> локальной переменной, JavaScript обратится на уровень выше, за пределы функции, чтобы найти необходимую переменную. Говорят, что <i>чтение переменных происходит изнутри области видимости наружу</i>.</p><pre><code>var food = 'салат';\n\nvar eatDinner = function () {\n    // Внутри функции не объявлены локальные переменные\n    console.log('Поел ' + food);\n};\n\neatDinner();\n// Функция обратится к переменной food,\n// которая объявлена снаружи eatDinner\n// Выведет 'Поел салат'\n</code></pre><p>В нашем примере переменная <code>food</code> объявлена <b>не</b> внутри какой-то функции. Она объявлена на уровне всей программы, поэтому её видно отовсюду, то есть можно использовать внутри любой функции. Такие переменные, которые объявляются на самом верхнем уровне, вне каких-то функций, называются <i>глобальными</i>. А область видимости, в которой они находятся, называется <i>глобальной областью видимости</i>. Из названия понятно, что переменные из этой области видимости видны по всему коду программы и доступны во всех блоках кода.</p><p>Если внутри функции будет обращение к переменной, которая не объявлена ни в одной области видимости, консоль выдаст ошибку.</p></div>`,html:``,css:``,hidden:``,js:`var food = 'борщ';\n\nvar eatDinner = function () {\n    console.log('Поел ' + food);\n};\n`,tasks:[{message:"После объявления функции <code>eatDinner</code>, вызовите эту <code class='keytext'>функцию</code>.",check:()=>~getJ().search(/eatDinner=function\S*\}\S*eatDinner\(\)/)},{message:"В <code class='keytext'>теле функции</code>, в выводе строки в <code class='keytext'>консоль</code>, замените переменную <code class='keyvalue'>food</code> на <code class='keyvalue'>soup</code>",check:(o)=>o&&o.eatDinner&&~getF(o.eatDinner).search(/console\.log\(('|"|`)Поел\1\+soup\)/)}],blocked:"4",editorOff:"8"},
'lesson1206':{theory:`<div><h1>Перемены снаружи — перемены внутри</h1><p>Из-за того, что переменные ищутся изнутри наружу, снаружи можно переопределять переменные, которые используются внутри функции.</p><p>Представьте, что вы школьник и, наконец-то, настало время обеда. Вы идёте в столовую. Сегодня на обед котлеты. И не с макарошками, а с пюрешкой! Вы обедаете и идёте учиться дальше. Много уроков, продлёнка, и вот уже время ужина. Вы снова идёте в столовую, а там закончились котлеты, поэтому на ужин сельдерей. И вы ужинаете сельдереем, деваться некуда. Воспроизведём этот пример в коде.</p><pre><code>var food = 'котлеты с пюрешкой';\n\nvar eatDinner = function () {\n    console.log('Поел ' + food);\n};\n\neatDinner();\n// Выведет 'Поел котлеты с пюрешкой'\n\n// Переопределяем переменную food\n<mark>food = 'сельдерей';</mark>\n\neatDinner();\n// Выведет 'Поел сельдерей'\n</code></pre><p>Сначала значение глобальной переменной <code>food</code> было <code>'котлеты с пюрешкой'</code>. Мы вызвали функцию и она использовала это значение, потому что оно было актуально на тот момент. Затем значение <code>food</code> изменилось на <code>'сельдерей'</code>. С этого места в коде и ниже, старого значения переменной больше нет. Поэтому, когда мы вызвали функцию <b>после</b> переопределения переменной, функция использовала новое значение.</p></div>`,html:``,css:``,hidden:``,js:`var food = 'пирожки';\n\nvar eatDinner = function () {\n    console.log('Поел ' + food);\n};\n`,tasks:[{message:"После определения функции <code>eatDinner</code>, вызовите эту функцию.",check:()=>~getJ().search(/eatDinner=function\S*\}\S*eatDinner\(\)/)},{message:"Ниже в коде, после вызова <code class='keytext'>функции</code>, переопределите значение переменной <code class='keyvalue'>food</code> на <code class='keytext'>'винегрет'</code>",check:()=>~getJ().search(/eatDinner=function\S*\}\S*eatDinner\(\)\S*food=('|"|`)винегрет\1/)},{message:"Ниже снова вызовите функцию <code>eatDinner</code>",check:()=>~getJ().search(/eatDinner=function\S*\}\S*eatDinner\(\)\S*food=('|"|`)винегрет\1\S*eatDinner\(\)/)}],blocked:"4",editorOff:"8"},
'lesson1207':{theory:`<div><h1>Стань независимым</h1><p>Мы выяснили, что переопределение глобальных переменных влияет на результат работы функции, которая эти переменные использует. Но, вообще-то, так делать не стоит — это не лучшая практика. Переопределение переменных, которые использует функция, может приводить к неожиданным последствиям и ошибкам в коде. Поэтому и существуют параметры, чтобы переиспользовать функции, явно передавая необходимые значения.</p><p>С параметрами всё легко и понятно, если мы хотим сразу вызвать функцию и получить результат её работы.</p><pre><code>var eatDinner = function (food) {\n    console.log('Поел ' + food);\n};\n\neatDinner('стейк');\n// Выведет 'Поел стейк'\n</code></pre><p>Что делать, если мы хотим зафиксировать в функции какое-то значение, а получить результат позже? Мы поступаем так с событиями: создаём функцию, используем внутри какие-то значения, но результат получаем не сразу, а когда совершится какое-то событие. Правда, не всегда всё идёт гладко, прям как у нас в галерее. Но мы на пути решения проблемы.</p><p>Вернёмся к примеру со школьником. Что, если школьник не хочет есть сельдерей? И вообще не хочет зависеть от еды, которая сейчас есть в столовой? Конечно, ему нужно взять еду с собой из дома! Тогда у него всегда будет в рюкзаке контейнер с едой. Он сможет в любой момент его достать и перекусить. Как реализовать это в коде?</p><pre><code>var collectContainer = function () {\n    var food = 'макароны';\n    var eatDinner = function () {\n        console.log('Поел ' + food);\n    }\n    <mark>return eatDinner</mark>;\n};\n\nvar schoolkid = collectContainer();\n// В переменной функция eatDinner,\n// которую вернула функция collectContainer\n\n// Вызываем функцию eatDinner из переменной schoolkid\nschoolkid();\n// Выведет 'Поел макароны'\n</code></pre><p>Не пугайтесь, в следующем задании мы подробно разберём, как эта запись работает и почему. А пока давайте убедимся, что это код действительно выполняется так, как показано в примере.</p></div>`,html:``,css:``,hidden:``,js:`var collectContainer = function () {\n    var food = 'макароны';\n    var eatDinner = function () {\n        console.log('Поел ' + food);\n    };\n    return eatDinner;\n};\n`,tasks:[{message:"После определения функции <code>collectContainer</code>, создайте переменную <code class='keyvalue'>schoolkid</code>",check:()=>~getJ().search(/(varschoolkid|letschoolkid)/)},{message:"Укажите, что переменная <code class='keyvalue'>schoolkid</code> равна вызову функции <code>collectContainer</code>",check:()=>~getJ().indexOf(`schoolkid=collectContainer()`)},{message:"Ниже выведите переменную <code class=keyvalue>schoolkid</code> в <code class='keytext'>консоль</code>.",check:()=>~getJ().search(/schoolkid=collectContainer\(\)\S*console\.log\(schoolkid\)/)},{message:"Ниже вызовите полученную функцию: <code>schoolkid()</code>",check:()=>~getJ().search(/schoolkid=collectContainer\(\)\S*console\.log\(schoolkid\)\S*schoolkid\(\)/)}],blocked:"4",editorOff:"8"},
'lesson1208':{theory:`<div><h1>Замыкания</h1><p>Код действительно работает. В чём секрет такой странной записи и что она вообще означает?</p><pre><code>var collectContainer = function () {\n    var food = 'макароны';\n    var eatDinner = function () {\n        console.log('Поел ' + food);\n    }\n    return eatDinner;\n};\n\nvar schoolkid = collectContainer();\nschoolkid();\n// Выведет 'Поел макароны'\n</code></pre><p>Мы хотим, чтобы функция получила фиксированное значение, которое бы не зависело от изменений в глобальной области видимости. При этом результат работы функции мы хотим получить не сразу. Как с событиями, когда мы создаём обработчик, но ждём выполнение события не сразу. В нашем примере мы собираем школьнику контейнер с едой, чтобы он мог перекусить любимыми макаронами независимо от того, что дают в столовой.</p><p>Код из примера работает так: мы вызываем <code>collectContainer</code> → функция <code>collectContainer</code> возвращает <code>eatDinner</code> → вызываем <code>eatDinner</code>.</p><p>Мы создаём функцию внутри функции. Таким образом мы создаём одну область видимости внутри другой области видимости. У <code>eatDinner</code> своя область видимости, в которой идёт обращение к переменной <code>food</code>. Эта переменная объявлена внутри <code>collectContainer</code>, у которой своя область видимости.</p><p>Функция <code>eatDinner</code> не находит внутри себя создание переменной <code>food</code>, смотрит в соседнюю область видимости (в область видимости <code>collectContainer</code>). Там она находит переменную <code>food</code>, узнаёт, что её значение равно строке <code>'макароны'</code>, и фиксирует это значение в памяти.</p><p>Постойте! Мы же выводили в консоль переменную <code>schoolkid</code> и там не было никаких макарон!</p><pre><code>var collectContainer = function () {\n    var food = 'макароны';\n    var eatDinner = function () {\n        console.log('Поел ' + food);\n    };\n    return eatDinner;\n};\n\nvar schoolkid = collectContainer();\n<mark>console.log(schoolkid)</mark>;\n// Выведет function () { console.log('Поел ' + <mark>food</mark>); }\n</code></pre><p>Всё верно. Код самой функции не меняется, просто в памяти вместе с функцией хранится то значение переменной, которое было при объявлении этой функции. Поэтому <code>eatDinner</code> «помнит» значение <code>food</code>. Это особенность функций, они помнят своё окружение в момент своего создания. В таком случае говорят о замыкании. <b>Замыкание</b> — функция, которая помнит о своём окружении. То есть это функция + все значения переменных <b>вне</b> локальной области видимости этой функции. Речь идёт только о переменных, которые функция использует в своём коде.</p><p>В нашем примере функция <code>eatDinner</code> вместе с переменной <code>food</code> являются замыканием.</p><p>Именно благодаря замыканиям код из примера выше работает. <code>eatDinner</code> помнит о значении <code>food</code> при своём создании, поэтому использует это значение в момент вызова. Как если бы мама сказала нам купить картошки, когда мы будем идти мимо магазина. Мы запомнили про картошку и пошли по своим делам. Когда мы увидели магазин, мы вспомнили, что именно картошка была нужна, мы её купили и пошли домой.</p><p>Убедимся, что замыкания позволяют школьнику есть макароны из контейнера независимо от еды в столовой.</p></div>`,html:``,css:``,hidden:``,js:`var food = 'салат';\n\nvar collectContainer = function () {\n    var food = 'макароны';\n    var eatDinner = function () {\n        console.log('Поел ' + food);\n    };\n    return eatDinner;\n};\n\nvar schoolkid = collectContainer();\n`,tasks:[{message:"Ниже, после создания переменной <code class='keyvalue'>schoolkid</code> вызовите <code class='keytext'>функцию из этой переменной</code>.",check:()=>~getJ().indexOf('schoolkid()')},{message:"Ниже переопределите значение глобальной переменной <code class='keyvalue'>food</code> на <code class='keytext'>'бульон'</code>",check:()=>~getJ().search(/schoolkid\(\)\S*food=('|"|`)бульон\1/)},{message:"Затем снова вызовите функцию <code>schoolkid</code>",check:()=>~getJ().search(/schoolkid\(\)\S*food=('|"|`)бульон\1\S*schoolkid\(\)/)}],blocked:"4",editorOff:"8"},
'lesson1209':{theory:`<div><h1>Собираемся в школу</h1><p>Всё работает. На функцию никак не влияют глобальные переменные.</p><p>Наш пример рабочий, но он жёстко привязан к значению внутри функции <code>collectContainer</code>. Может школьник не хочет есть каждый раз только макароны? Нужно дать ему возможность выбора. Да и чаще всего мы передаём какие-то значения в функцию, а не жёстко фиксируем их внутри локальной области видимости. Добавим функции <code>collectContainer</code> параметр.</p><pre><code>\nvar collectContainer = function (<mark>food</mark>) {\n    return function () {\n        console.log('Поел ' + <mark>food</mark>);\n    };\n};\n\nvar schoolkid = collectContainer(<mark>'макароны'</mark>);\nschoolkid();\n// Выведет 'Поел макароны'\n</code></pre><p>Теперь значение <code>food</code> будет использовано из параметра, а не из локальной переменной функции <code>collectContainer</code>. Работать всё будет точно так же. Функция, которую возвращает <code>collectContainer</code>, будет запоминать значение параметра и использовать его при своём вызове.</p><p>Внутреннюю функцию мы сделали анонимной, потому что имя <code>eatDinner</code> нигде не используется. Это никак не повлияет на работу функции.</p><p>Представим, что школьников теперь двое. Каждый из них возьмёт из дома контейнер с едой.</p><p>Убедимся, что переопределение глобальных переменных не повлияет на работу нашей функции <code>collectContainer</code>.</p><p>Обратите внимание, что каждый раз, когда мы будем вызывать функцию <code>collectContainer</code> и записывать результат в переменную, в памяти будет создаваться новое замыкание, которое будет помнить о значении параметра <code>food</code> в момент своего создания.</p></div>`,html:``,css:``,hidden:``,js:`var food = 'салат';\n\nvar collectContainer = function (food) {\n    return function () {\n        console.log('Поел ' + food);\n    };\n};\n\nvar schoolkidFirst = collectContainer('макароны');\n`,tasks:[{message:`После переменной <code class='keyvalue'>schoolkidFirst</code> по аналогии создайте переменную <code class='keyvalue'>schoolkidSecond</code>. В качестве аргумента передайте строку <code class='keytext'>'пельмешки'</code>`,check:()=>~getJ().search(/(var|let)schoolkidSecond\S*=collectContainer\(('|"|`)пельмешки\2\)/)},{message:"Ниже переопределите значение глобальной переменной <code class='keyvalue'>food</code> на <code class='keytext'>'сельдерей'</code>",check:()=>~getJ().search(/(var|let)schoolkidSecond\S*=collectContainer\(('|"|`)пельмешки\2\)\S*food=('|"|`)сельдерей\3/)},{message:"Затем вызовите функцию из переменной <code class='keyvalue'>schoolkidFirst</code>",check:()=>~getJ().search(/(var|let)schoolkidSecond\S*=collectContainer\(('|"|`)пельмешки\2\)\S*food=('|"|`)сельдерей\3\S*schoolkidFirst\(\)/)},{message:"Ниже вызовите функцию из переменной <code class='keyvalue'>schoolkidSecond</code>",check:()=>~getJ().search(/(var|let)schoolkidSecond\S*=collectContainer\(('|"|`)пельмешки\2\)\S*food=('|"|`)сельдерей\3\S*schoolkidFirst\(\)\S*schoolkidSecond\(\)/)},{message:`А теперь сломайте наше замыкание, удалив параметр <code class='keytext'>food</code> у функции <code>collectContainer</code>. Накормите школьников сельдереем! Му-ха-ха!`,check:(o)=>o&&o.collectContainer&&!~getF(o.collectContainer).search(/function\(\w+\)/)}],blocked:"4",editorOff:"8"},
'lesson1210':{theory:`<div><h1>Чиним галерею</h1><p>После знакомства с областями видимости и замыканиями, вернёмся к нашей задаче. Что же случилось у нас в коде? Почему программа не работает как надо?</p><pre><code>for (var i = 0; i &lt; thumbnails.length; i++) {\n    thumbnails[i].addEventListener('click', function () {\n        fullPhoto.src = photos[i];\n    });\n}</code></pre><p>Обработчики, которые мы создали, используют значение счётчика <code>i</code>. Сложность в том, что обработчики срабатывают не сразу, а в момент наступления события. К тому моменту, когда первое событие клика выполняется, цикл полностью отработал, значение счётчика стало максимальным — <code>5</code>, и функция-обработчик берёт именно это значение. Цикл не создаёт отдельную область видимости, это ведь не функция. Поэтому значение <code>i</code> находится в глобальной области и каждый обработчик обращается к этому значению <code>5</code>. А у нас нет миниатюры с таким индексом и элемента в массиве <code>photos</code>, поэтому никакая картинка и не подставляется.</p><p>Как нам это исправить? Нам помогут замыкания!</p><p>Мы создадим функцию, которая будет принимать в качестве параметров миниатюру и подходящий элемент из массива <code>photos</code>. А уже внутри этой функции будем добавлять обработчики. Тогда каждый обработчик будет брать значения из своего замыкания — из параметров функции, в которой находится обработчик.</p><p>У каждого обработчика будет собственное замыкание, поэтому значения в обработчиках не будут повторяться, как это было раньше.</p><p>Давайте постепенно улучшим нашу программу так, чтобы она работала корректно.</p></div>`,html:tb2,css:tc2,hidden:th2,js:tj1+`\nvar thumbnails = document.querySelectorAll('.gallery__photo-preview');\nvar fullPhoto = document.querySelector('.full-photo');\n\nfor (var i = 0; i < thumbnails.length; i++) {\n    thumbnails[i].addEventListener('click', function () {\n        fullPhoto.src = photos[i];\n    });\n}\n`,tasks:[{message:`Перед <code class='keytext'>циклом</code> объявите функцию <code>addThumbnailClickHandler</code> с двумя параметрами: <code class='keytext'>thumbnail</code> и <code class='keytext'>photo</code>`,check:(o)=>o&&((o.addThumbnailClickHandler&&~getF(o.addThumbnailClickHandler).indexOf('function(thumbnail,photo)'))||~getJ().search(/functionaddThumbnailClickHandler\(thumbnail,photo\)\{\S*\}/))},{message:"В теле <code class='keytext'>функции</code> добавьте <code class='keyvalue'>thumbnail</code> <code class='keytext'>обработчик клика</code>.",check:(o)=>o&&((o.addThumbnailClickHandler&&~getF(o.addThumbnailClickHandler).search(/function\(thumbnail,photo\)\{\S*thumbnail\.addEventListener\(('|"|`)click\1,function\(\w*\)\{\S*\}\S*\)\S*\}/))||~getJ().search(/functionaddThumbnailClickHandler\(thumbnail,photo\)\{\S*thumbnail\.addEventListener\(('|"|`)click\1,function\(\w*\)\{\S*\}\S*\)\S*\}/))},{message:`Внутри этого обработчика <code class='keytext'>выведите в консоль</code> <code class='keyvalue'>thumbnail</code>, а на следующей строке <code class='keytext'>выведите в консоль</code> <code class='keyvalue'>photo</code>`,check:(o)=>o&&((o.addThumbnailClickHandler&&~getF(o.addThumbnailClickHandler).search(/function\(thumbnail,photo\)\{\S*thumbnail\.addEventListener\(('|"|`)click\1,function\(\w*\)\{\S*console\.log\(thumbnail\)\S*console\.log\(photo\)\S*\}\S*\)\S*\}/))||~getJ().search(/functionaddThumbnailClickHandler\(thumbnail,photo\)\{\S*thumbnail\.addEventListener\(('|"|`)click\1,function\(\w*\)\{\S*console\.log\(thumbnail\)\S*console\.log\(photo\)\S*\}\S*\)\S*\}/))},{message:`Замените весь код в теле цикла на вызов функции <code>addThumbnailClickHandler</code> с аргументами <code class='keyvalue'>thumbnails[<code class='keytext'>i</code>]</code>, <code class='keyvalue'>photos[<code class='keytext'>i</code>]</code>`,check:(o)=>{if(~getJ().search(/for\(vari=0;i<thumbnails\.length;i\+\+\)\{addThumbnailClickHandler\(thumbnails\[i\],photos\[i\]\);{0,1}\}/)){if(!o.hA){Academy.vars.hA=1;Academy.vars.hL=()=>{Academy.vars.hA++}};var t=document.querySelectorAll('#view-after .gallery__photo-preview');for(var i=0;i<t.length;i++){t[i].removeEventListener('click',Academy.vars.hL);t[i].addEventListener('click',Academy.vars.hL)};return true}}},{message:"<code class='keytext'>Кликните</code> по <code class='keytext'>двум</code> любым миниатюрам.",check:(o)=>o.hA>2}],blocked:"4",editorOff:"4"},
'lesson1211':{theory:`<div><h1>Дело раскрыто</h1><p>Замыкания нам помогли, галерея почти работает!</p><p>На каждой итерации мы передаём разные значения в <code>addThumbnailClickHandler</code>. Каждый обработчик получает своё замыкание, в котором находятся какие-то конкретные значения параметров <code>thumbnail</code>, <code>photo</code>. Именно эти значения использует каждый обработчик при происхождении события. И теперь значение индекса в уже отработавшем цикле никак не влияет на нашу программу.</p><p>Осталось заменить выводы в консоль на замену <code>src</code> у большого изображения, и убедиться, что код работает правильно.</p></div>`,html:tb2,css:tc2,hidden:th2,js:tj1+`\nvar thumbnails = document.querySelectorAll('.gallery__photo-preview');\nvar fullPhoto = document.querySelector('.full-photo');\n\nvar addThumbnailClickHandler = function (thumbnail, photo) {\n    thumbnail.addEventListener('click', function () {\n        console.log(thumbnail);\n        console.log(photo);\n    });\n};\n\nfor (var i = 0; i < thumbnails.length; i++) {\n    addThumbnailClickHandler(thumbnails[i], photos[i]);\n}`,tasks:[{message:"Замените код внутри обработчика на <code class='keyvalue'>fullPhoto.src = photo;</code>",check:(o)=>{if(o&&~getF(o.addThumbnailClickHandler).search(/thumbnail\.addEventListener\(\S*function\(\w*\)\{\S*fullPhoto.src=photo\S*\}\S*\)\S*\}/)){if(!o.hA){Academy.vars.hA=1;Academy.vars.hL=()=>{Academy.vars.hA++}};var t=document.querySelectorAll('#view-after .gallery__photo-preview');for(var i=0;i<t.length;i++){t[i].removeEventListener('click',Academy.vars.hL);t[i].addEventListener('click',Academy.vars.hL)};return true}}},{message:"<code class='keytext'>Кликните</code> по одной из миниатюр.",check:(o)=>o.hA>1}],blocked:"4",editorOff:"4"},
'lesson1212':{theory:`<section><h1>Конспект «События в JavaScript». 2 часть</h1><h3>Области видимости</h3><p>У каждой функции есть область видимости — все значения, доступные для этой функции.</p><p>Область видимости ограничена функцией, поэтому снаружи нельзя получить локальные переменные и параметры функции.</p><p><b>Локальные переменные</b> — переменные, у которых область видимости ограничена функцией, где они объявлены. Такая область видимости называется локальной.</p><p><b>Глобальные переменные</b> — переменные, которые объявлены на уровне всей программы, их видно из любого блока кода. Область видимости, в которой они объявлены, называется глобальной.</p><p>Если внутри функции обратиться не к локальной переменной, JavaScript будет искать переменную снаружи, переходя наверх от уровня к уровню, пока не найдёт переменную. Если переменной не будет ни внутри функции ни снаружи, будет ошибка.</p><p>Так как функция может использовать переменные, объявленные снаружи, их можно переопределять.</p><pre><code>var food = 'макароны';\n\nvar eatDinner = function () {\n    console.log('Поел ' + food);\n};\n\neatDinner();\n// Выведет 'Поел макароны'\n\n// Переопределяем переменную food\n<mark>food = 'сельдерей';</mark>\n\neatDinner();\n// Выведет 'Поел сельдерей'\n</code></pre><p>Переопределять снаружи переменные, которые использует функция — не лучшая практика. Это может приводить к неожиданным последствиям и ошибкам в коде. Использовать это нужно осторожно.</p><p>Области видимости создаются только функциями. Поэтому, если переменная была создана в другой конструкции, например, в цикле, она будет доступна для чтения из функции.</p><h3>Замыкания</h3><p><b>Замыкание</b> — функция, которая помнит о своём окружении. Это функция + все значения вне локальной области видимости, которые она использует.</p><p>Благодаря замыканиям мы можем зафиксировать какое-то значение в функции, а использовать саму функцию позже.</p><pre><code>var collectContainer = function (<mark>food</mark>) {\n    return function () {\n        console.log('Поел ' + <mark>food</mark>);\n    };\n};\n\nvar schoolkid = collectContainer(<mark>'макароны'</mark>);\nschoolkid();\n// Выведет 'Поел макароны'\n</code></pre><h3>Замыкания и асинхронность</h3><p>Некоторые функции выполняются асинхронно, поэтому в момент выполнения кода значение переменной может уже измениться. Чтобы избавиться от этой проблемы, нужно создать отдельную область видимости. Так все переменные будут под контролем и замыкания не позволят потерять необходимые значения.</p><pre><code>var thumbnails = document.querySelectorAll('.gallery__photo-preview');\nvar fullPhoto = document.querySelector('.full-photo');\n\nvar addThumbnailClickHandler = function (thumbnail, photo) {\n    thumbnail.addEventListener('click', function () {\n        fullPhoto.src = photo;\n    });\n};\n\nfor (var i = 0; i &lt; thumbnails.length; i++) {\n    addThumbnailClickHandler(thumbnails[i], photos[i]);\n}\n</code></pre><br></section>`,html:``,css:``,hidden:``,js:`var selection = "То, что нам нужно!";\n\nvar helper = function(selection) {\n    selection = "Совсем не то, что нам нужно...";\n    console.log(selection);}\n\nhelper("Странная вещь");`,tasks:[{message:"Сделайте так, чтобы вызов функции <code>helper</code> вывел в консоль именно глобальный <code class='keyvalue'>selection</code> (тот, у которого текст <code class='keytext'>То, что нам нужно!</code>) :)",check:(o)=>o&&~getF(o.helper).indexOf('console.log(selection)')&&~o.log.indexOf('То, что нам нужно!')}],blocked:"4",editorOff:"9"},
'lesson1213':{theory:`<div><h1>Пятнадцатая программа: «Сеньор Помидор»</h1><p>Мы разобрались с галереей Кекса, пришло время новой задачи. В этот раз нужно запрограммировать галерею для интернет-магазина овощей.</p><p>Кекс не любит овощи, особенно помидоры. Он предпочитает молочное и мясное меню. Но работа есть работа.</p><blockquote><p>Мяу! Нужно оживить галерею с фотографиями товаров.</p><p>В галерее есть миниатюры (элементы с классом <code>gallery__picture-preview</code>) и большое изображение (класс <code>full-picture</code>).</p><p>После клика по превью большая фотография должна поменяться. Большое изображение должно быть таким же, как и в миниатюре, только большего размера.</p><p>Пути к полноразмерным фотографиям находятся в массиве <code>pictures</code>. Порядок элементов в массиве такой же, как и порядок миниатюр в разметке.</p></blockquote></div>`,html:`<!DOCTYPE html>\n<html lang="ru">\n<head>\n  <meta charset="utf-8">\n  <title>Помидоркогалерея</title>\n  <link href="style.css" rel="stylesheet">\n</head>\n<body>\n  <section class="gallery">\n    <h1>Помидоркогалерея</h1>\n    <div class="gallery__pictures">\n      <p class="gallery__picture-full">\n        <img class="full-picture" src="images/courses/58/tomato-red-large.jpg" width="450" height="300" alt="Фото большое">\n      </p>\n      <p class="gallery__picture-previews">\n        <button class="gallery__picture-preview" type="button">\n          <img src="images/courses/58/tomato-red.jpg" alt="Помидорка красная">\n        </button>\n        <button class="gallery__picture-preview" type="button">\n          <img src="images/courses/58/tomato-yellow.jpg" alt="Помидорка жёлтая">\n        </button>\n        <button class="gallery__picture-preview" type="button">\n          <img src="images/courses/58/tomato-strange.jpg" alt="Помидорка серобурая">\n        </button>\n      </p>\n    </div>\n  </section>\n\n  <script src="script.js"></script>\n</body>\n</html>`,css:`.gallery {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  min-width: 555px;\n}\n\n.gallery__pictures {\n  display: flex;\n}\n\n.gallery__picture-full {\n  margin-bottom: 0;\n}\n\n.gallery__picture-full img {\n  display: block;\n  box-shadow: 0 0 5px rgba(0, 1, 1, 0.2);\n}\n\n.gallery__picture-previews {\n  display: flex;\n  width: 90px;\n  margin: 0;\n  margin-right: 15px;\n  flex-direction: column;\n  list-style-type: none;\n  padding: 0;\n  justify-content: space-between;\n  order: -1;\n}\n\n.gallery__picture-preview {\n  position: relative;\n  padding: 0;\n  border: 0;\n  border-radius: 0;\n  background: none;\n  outline: none;\n  top: 0;\n  filter: grayscale(1);\n  opacity: 0.7;\n  transition: top 0.2s, box-shadow 0.2s, filter 0.2s, opacity 0.2s;\n  box-shadow: 0 0 5px rgba(0, 1, 1, 0.2);\n}\n\n.gallery__picture-preview:hover {\n  outline: 3px solid #cccccc;\n  outline-offset: -3px;\n}\n\n.gallery__picture-preview:focus {\n  top: -5px;\n  box-shadow: 0 3px 10px 2px rgba(0, 1, 1, 0.2);\n  filter: none;\n  opacity: 1;\n}\n\n.gallery__picture-preview img {\n  display: block;\n  object-fit: cover;\n  width: 90px;\n  height: 90px;\n}`,hidden:`body{font-weight:400;font-size:16px;font-family:"Open Sans","Arial",sans-serif;color:#3a3a3a;background:rgba(0, 0, 0, 0) url("images/courses/58/leaves.png") repeat 0 0;}p{margin:0;}.no-interactions .gallery__picture-preview:hover,.no-interactions .gallery__picture-preview:focus{outline:none;}.no-interactions .gallery__picture-preview:focus{top:0;box-shadow:0 0 5px rgba(0, 1, 1, 0.2);filter:grayscale(1);opacity:0.7;outline:none;}`,js:`var pictures = [\n    'images/courses/58/tomato-red-large.jpg',\n    'images/courses/58/tomato-yellow-large.jpg',\n    'images/courses/58/tomato-strange-large.jpg',\n];\n`,tasks:[{message:`<button onclick="fH3()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class="test-container"><p><code class='keyword'>Мяу!</code> Нужно оживить галерею с фотографиями товаров.</p><p>В галерее есть миниатюры (элементы с классом <code class='keyclass'>gallery__picture-preview</code>) и большое изображение (класс <code class='keyclass'>full-picture</code>).</p><p>После клика по превью большая фотография должна поменяться. Большое изображение должно быть таким же, как и в миниатюре, только большего размера.</p><p>Пути к полноразмерным фотографиям находятся в массиве <code class='keyvalue'>pictures</code>. Порядок элементов в массиве такой же, как и порядок миниатюр в <code class='keytext'>разметке</code>.</p></div><p class="task-press-button">Нажмите кнопку <code class="keyword">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{if(!o.hE){Academy.vars.hE=true;setT();var p=['images/courses/58/tomato-red-large.jpg','images/courses/58/tomato-yellow-large.jpg','images/courses/58/tomato-strange-large.jpg'];var c=document.querySelector('#view-before .full-picture');var t=document.querySelectorAll('#view-before .gallery__picture-preview');var e=function(r,s){r.addEventListener('click',function(){c.src=s;})};for(var i=0;i<t.length;i++)e(t[i],p[i]);};return o.hA}}],blocked:"4",editorOff:"4"}
};
hL();