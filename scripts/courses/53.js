keks={
print:(p)=>{Academy.vars.log.push("Печать страницы №"+p);setTimeout(()=>printLog("Работа принтера."),4)},
getScore:()=>{var n=Math.random();return n>=.9?-1:~~(n*100/9+1)}
};
fH1={
a:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.search(/(var|let) total/);if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[[9,100,200],[5,100,200],[10,100,80],[10,175,150],[15,170,100],[0,100,125]];var r=[1300,700,900,1625,2060,0];for(var i=0;i<d.length;i++){var f="function z(){"+a+";days="+d[i][0]+";evenDayAmount="+d[i][2]+";oddDayAmount="+d[i][1]+";"+b+";return total};z();";var t;l.push("Тест "+(i+1)+". Количество дней — "+d[i][0]+". Протеин в чётные дни — "+d[i][2]+". Протеин в нечётные дни — "+d[i][1]+".");l.push("Ожидаю количество грамм протеина: "+r[i]);try{t=eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};l.push("Полученный результат: "+t);if(t===r[i])continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}};l.push("Все тесты пройдены!");p("Тест задания");g(true)},
b:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.indexOf(';');x=j.indexOf(';',x+1);if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[[6000,5000],[5000,5000],[7000,5000],[9000,5500],[10000,5700]];var r=[4,0,7,10,11];for(var i=0;i<d.length;i++){var f="function z(){"+a+";initialWeight="+d[i][0]+";targetWeight="+d[i][1]+";"+b+";return days};z();";var t;l.push("Тест "+(i+1)+". Начальный вес — "+d[i][0]+" гр., хотим похудеть до — "+d[i][1]+" гр.");l.push("Ожидаю ответ: "+r[i]+(i===0?' дня.':' дней.'));try{t=eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};l.push("Полученный результат, дней: "+t);if(t===r[i])continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}};l.push("Все тесты пройдены!");p("Тест задания");g(true)},
c:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.indexOf('var quantity');x=j.indexOf(';',x);if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[[1,4,7],[3,3,6],[5,2,7],[2,7,5]];var r=[[1,4,16,64,256,1024,4096],[3,9,27,81,243,729],[5,10,20,40,80,160,320],[2,14,98,686,4802]];for(var i=0;i<d.length;i++){var f="function z(){"+a+";startNumber="+d[i][0]+";multiplier="+d[i][1]+";quantity="+d[i][2]+";"+b+"};z();";l.push("Тест "+(i+1)+". Стартовое значение — "+d[i][0]+", множитель — "+d[i][1]+", количество — "+d[i][2]+".");l.push("Ожидаю вывод в консоль: "+r[i].map((i)=>' '+i)+'.');try{eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};for(var k=0;k<r[i].length;k++){if(~l.indexOf(r[i][k]))continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}}};l.push("Все тесты пройдены!");p("Тест задания");g(true)},
d:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.search(/(var|let) sum/);if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[10,15,25,46];var r=[55,120,325,1081];for(var i=0;i<d.length;i++){var f="function z(){"+a+";lastNumber="+d[i]+";"+b+";return sum};z();";var t;l.push("Тест "+(i+1)+". Сумма чисел от 1 до  "+d[i]+".");l.push("Ожидаю результат: "+r[i]);try{t=eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};l.push("Полученный результат: "+t);if(t===r[i])continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}};l.push("Все тесты пройдены!");p("Тест задания");g(true)},
e:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.search(/(var|let) multiplicationResult/);if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[5,12,8,10];var r=[8,46080,384,3840];for(var i=0;i<d.length;i++){var f="function z(){"+a+";lastNumber="+d[i]+";"+b+";return multiplicationResult};z();";var t;l.push("Тест "+(i+1)+". Последовательность чисел от 1 до  "+d[i]+".");l.push("Ожидаю результат: "+r[i]);try{t=eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};l.push("Полученный результат: "+t);if(t===r[i])continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}};l.push("Все тесты пройдены!");p("Тест задания");g(true)},
f:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.indexOf(';');if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[15,114,122,110,135];var r=[[3,5],[2,3,6,19,38,57],[2,61],[2,5,10,11,22,55],[3,5,9,15,27,45]];Academy.vars.rcl=console.log;for(var i=0;i<d.length;i++){var f="function z(){"+a+";number="+d[i]+";"+b+";};z();";l.push("Тест "+(i+1)+". Стартовое значение — "+d[i]+".");var m=[];console.log=((arguments)=>{Academy.vars.rcl(arguments);m.push(arguments)}).bind(this);l.push("Ожидаю вывод в консоль делителей: "+r[i].map((i)=>' '+i));try{eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};if(m.length!==r[i].length){l.push("error: количество выводов в консоль не совпадает!");p("Тест задания");g(false);return};for(var k=0;k<r[i].length;k++){if(~m.indexOf(r[i][k]))continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}}};l.push("Все тесты пройдены!");p("Тест задания");g(true);console.log=Academy.vars.rcl;},
g:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.search(/(var|let) quantity/);if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[123,15200,5678,17];var r=[3,5,4,2];for(var i=0;i<d.length;i++){var f="function z(){"+a+";number="+d[i]+";"+b+";return quantity};z();";var t;l.push("Тест "+(i+1)+". Число — "+d[i]+".");l.push("Ожидаю количество цифр: "+r[i]);try{t=eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};l.push("Полученный результат: "+t);if(t===r[i])continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}};l.push("Все тесты пройдены!");p("Тест задания");g(true)},
h:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.search(/(var|let) total/);if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[9,5,10,15,25,0];var r=[500,200,500,900,1400,0];for(var i=0;i<d.length;i++){var f="function z(){"+a+";days="+d[i]+";"+b+";return total};z();";var t;l.push("Тест "+(i+1)+". Количество дней — "+d[i]+".");l.push("Ожидаю количество грамм протеина: "+r[i]);try{t=eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};l.push("Полученный результат: "+t);if(t===r[i])continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}};l.push("Все тесты пройдены!");p("Тест задания");g(true)},
i:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.search(/;/);if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[[3,5,15,6,2,1],[7,12,57,23,0,2],[57,16,-2,4,8,15],[34,115,22,34,12,1,34]];var r=[[1,2,3,5,6,15],[0,2,7,12,23,57],[-2,4,8,15,16,57],[1,12,22,34,34,34,115]];for(var i=0;i<d.length;i++){var f="function z(){"+a+";numbers=["+d[i]+"];"+b+";return numbers};z();";var t;l.push("Тест "+(i+1)+".  Стартовый массив — ["+d[i]+"].");l.push("Ожидаю отсортированный массив: ["+r[i]+"]");try{t=eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};if(!Array.isArray(t)){l.push("Полученный результат: "+t);l.push("error: полученный результат не массив!");p("Тест задания");g(false);return};l.push("Полученный результат: ["+t+"]");if(t.length!==r[i].length){;l.push("error: длины массивов не совпадают!");p("Тест задания");g(false);return};for(var k=0;k<r[i].length;k++){if(t[k]===r[i][k])continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}}};l.push("Все тесты пройдены!");p("Тест задания");g(true)},
j:()=>{var p=printLog;var g=getR;var l=Academy.vars.log;var j=Academy.JS.getValue();var x=j.search(/(var|let) ylop/);if(!~x){l.push("error: не найдены необходимые переменные");p("Тест задания");g(false);return};var a=j.slice(0,x);var b=j.slice(x);var d=[1221,7997,5005,1591];var r=[true,true,true,false];for(var i=0;i<d.length;i++){var f="function z(){"+a+";poly="+d[i]+";"+b+";return isPalindrome};z();";var t;l.push("Тест "+(i+1)+". Число — "+d[i]+".");l.push("Ожидаю результат, число палиндром: "+r[i]);try{t=eval(f);}catch(e){l.push(e);p("Тест задания");g(false);return};l.push("Полученный результат: "+t);if(t===r[i])continue;else{l.push("error: результаты не совпадают!");p("Тест задания");g(false);return}};l.push("Все тесты пройдены!");p("Тест задания");g(true)},
};
LessonsData={
"lesson1033":{theory:`<div><h1>Новый проект: разработка драйвера</h1><p>Вы доказали, что можете создавать программы со сложной логикой. И Кекс поручает вам большой и серьёзный проект: разработку драйверов для нового принтера марки Кексрокс<sup>®</sup>. Драйвер — это специальная программа, которая позволяет компьютеру управлять техникой (мышкой, клавиатурой, принтерами, сканерами, мониторами и другими устройствами).</p><p>Новый принтер достаточно простой, он должен уметь печатать все страницы в прямом и обратном порядке, печатать чётные и нечётные страницы и делать копии одной страницы. И ваша программа-драйвер должна это обеспечить.</p><p>Правда, тестовый образец принтера нам ещё не прислали (разработка идёт долго, ведь инженеры Кекса спят по 20 часов в сутки). Поэтому логику работы драйверов будем отрабатывать с помощью специальной команды <code>keks.print</code>, которая принимает на вход номер страницы. Вот пример:</p><pre>// Выведет в консоль строку «Печать страницы №1»\nkeks.print(1);\n</pre><p>Сейчас эта команда просто выводит текст в консоль. Но как только пришлют тестовый образец, её легко перенастроить на работу с принтером.</p><p>Начнём с простой задачи: нужно заставить принтер печатать заданную страницу несколько раз.</p></div>`,html:``,css:``,hidden:``,js:`var page = 7;\n\nkeks.print(page);\n`,tasks:[{message:`Драйвер печатает одну страницу <code class='keytext'>№7</code>. Сделайте так, чтобы он печатал её <code class='keytext'>три</code> раза. Скопируйте строчку с командой <code>keks.print(<code class='keytext'>page</code>)</code> в конец программы.`,check:()=>~getJ().search(/keks\.print\(page\)\S*keks\.print\(page\)/)},{message:`И ещё раз.`,check:()=>~getJ().search(/keks\.print\(page\)\S*keks\.print\(page\)\S*keks\.print\(page\)/)},{message:`Замените значение переменной <code class='keyvalue'>page</code> на <code class='keytext'>9</code>`,check:(o)=>o.page===9||~getJ().search(/page=9\D+/)}],blocked:"4",editorOff:"8"},
"lesson1034":{theory:`<div><h1>Управляем количеством копий</h1><p>Драйвер умеет делать три копии заданной страницы. Теперь нужно научить его делать разное количество копий в зависимости от ситуации. Вы знаете условия, поэтому могли бы написать программу как-то так:</p><pre>// Переменная хранит нужное количество копий\nvar count = 3;\n\nif (count === 2) {\n  keks.print(page);\n  keks.print(page);\n}\n\nif (count === 3) {\n  keks.print(page);\n  keks.print(page);\n  keks.print(page);\n}\n</pre><p>Вообще, подход рабочий, но никто так не пишет. Представьте программу, которая умеет делать сто копий одной страницы.</p><p>Чтобы удобно выполнять такие повторяющиеся команды, в языках программирования существуют циклы. Например, цикл <code>for</code>:</p><pre>for (var i = 0; i &lt; count; i = i + 1) {\n  // повторяющиеся команды\n}\n</pre><p>Если мы записываем цикл <code>for</code> таким образом, действия внутри фигурных скобок выполнятся <code>count</code> раз. Внимательное рассмотрение содержимого <code>for</code> мы пока отложим до следующего задания, а пока посмотрим, как он работает.</p><p>Доработайте драйвер, чтобы можно было управлять количеством копий с помощью переменной <code>count</code>.</p><p><span>Кстати,</span> в курсе «Условия» мы рассматривали строгое (<code>===</code>) и нестрогое (<code>==</code>) равенства. Почему в примере выше используется именно строгое равенство?</p><p>Потому что такое сравнение помогает избежать ошибок. Например, вот такое сравнение пройдёт, если мы будем использовать нестрогое равно:</p><pre>if ('003' <b>==</b> 3) {\n  …\n}</pre><p>Та же самая проверка с использованием <code>===</code> не пройдёт, потому что строка '003' не то же самое, что число 3. В нашей программе количество копий записывается числом и во всех сравнениях мы ожидаем число. Поэтому используем строгое равенство, чтобы обезопасить себя от попадания в нашу программу неподходящих значений.</p><p>Использовать строгое равенство — хорошая практика. Используйте именно его во всех случаях, где это возможно.</p></div>`,html:``,css:``,hidden:``,js:`var page = 7;\nvar count = 3;\n\nkeks.print(page);\nkeks.print(page);\nkeks.print(page);\n`,tasks:[{message:`Замените дублирование команд на цикл <code class='keyword'>for</code>. Удалите команды <code>keks.print</code> и замените их на цикл: <code>for (var i = 0; i < count; i = i + 1) { }</code>`,check:()=>~getJ().search(/for\((var|let)i=0;i<count;i(\+\+|\+=1|=i\+1)\)\{\S*\}/)},{message:`Внутри цикла добавьте команду <code>keks.print(<code class='keytext'>page</code>)</code>`,check:()=>~getJ().search(/for\((var|let)i=0;i<count;i(\+\+|\+=1|=i\+1)\)\{\S*keks\.print\(page\)\S*\}/)},{message:`Измените значение переменной <code class='keyvalue'>count</code> на <code class='keytext'>5</code> и убедитесь, что количество напечатанных копий изменилось.`,check:(o)=>o.count===5||~getJ().search(/count=5\D\S*for\(/),}],blocked:"4",editorOff:"8"},
"lesson1035":{theory:`<div><h1>Разбираем цикл for</h1><p>Отлично! Первая часть драйвера реализована. Второй шаг: печать всех страниц документа.</p><p>В этой задаче тоже много повторяющихся действий, поэтому без циклов решить её не получится. Давайте разберём цикл <code>for</code> подробнее:</p><pre>for (var i = 0; i &lt; 5; i = i + 1) {\n  // повторяющиеся команды или «тело цикла»\n}\n</pre><p>Как работает цикл <code>for</code>? Он выполняет действия из тела цикла снова и снова, пока условие возвращает <code>true</code>. Что за условие и как грамотно писать циклы, мы сейчас разберёмся.</p><p>В круглых скобках записывается код управления циклом. Он состоит из трёх частей, разделённых <code>;</code>. Смысл каждой части такой:</p><ol><li><p>Первая часть — подготовительная. Команды отсюда запускаются <em>один раз</em> перед началом работы цикла. Обычно здесь задаётся исходное значение для переменной-счётчика. Можно сказать, что первая часть — стартовая настройка для цикла.</p><p>В примере ниже мы создали переменную-счётчик <code>i</code> и задали ей начальное значение <code>0</code>. Именно этому значению будет равна переменная, когда цикл начнёт свою работу.</p><p>Обратите внимание, что в цикле мы создаём переменную-счётчик с помощью <code>var</code>, как в случае с любой другой переменной. Традиционно такая переменная называется <code>i</code> (от слова index), но у неё может быть любое другое название. Например, если цикл считает дни, переменная-счётчик может называться <code>day</code>, а если страницы документа, то <code>page</code>.</p><pre>for (<b>var i = 0</b>; i &lt; 5; i = i + 1) { }</pre></li><li><p>Вторая часть — проверочная. Она содержит условие и запускается <em>перед</em> каждым новым витком цикла. Условие здесь работает по знакомому вам алгоритму. Если условие возвращает <code>true</code>, цикл делает ещё один виток, иначе цикл завершает свою работу.</p><p>В примере мы указали, что цикл должен работать пока переменная <code>i</code> будет меньше <code>5</code>.</p><pre>for (var i = 0; <b>i &lt; 5</b>; i = i + 1) { }</pre></li><li><p>Третья часть — дополняющая, хотя по-научному она называется «законом изменения». Код третьей части запускается <em>после</em> каждого витка цикла. То есть после того, как выполнится код из тела цикла. Обычно там изменяется переменная-счётчик.</p><p>В нашем случае мы указали, что после каждого витка цикла, переменная <code>i</code> должна увеличиваться на единицу.</p><pre>for (var i = 0; i &lt; 5; <b>i = i + 1</b>) { }</pre></li></ol><p>Мы разобрали, как устроен цикл <code>for</code> в теории. Теперь напишем программу для печати всех страниц. Количество страниц хранится в переменной <code>totalPages</code>.</p><p><span>Кстати,</span> создать счётчик в цикле можно и без <code>var</code>. Такая возможность существует для обратной совместимости и пришла к нам из старых версий языка. Там это работало, хотя такой код считался неграмотным. Но в новой версии JavaScript (ES6) такая запись работать не будет. В новой версии по умолчанию включен строгий режим, который запрещает создавать переменные без <code>var</code>, в том числе и счётчик цикла. Не забывайте про <code>var</code> и сразу пишите код грамотно.</p></div>`,html:``,css:``,hidden:``,js:`var totalPages = 7;\n`,tasks:[{message:`Выведем страницы документа в цикле. Под объявлением переменной добавьте в код пустой цикл <code>for (;;) { }</code>`,check:()=>~getJ().search(/for\(\S*;\S*;\S*\)\{\S*\}/)},{message:`В подготовительной части цикла создайте переменную-счётчик: <code>var page</code> <code class='keyword'>=</code> <code class'keytext>0</code>`,check:()=>~getJ().search(/for\((var|let)page=0;\S*;\S*\)\{\S*\}/)},{message:`В проверяющей части задайте условие выполнения цикла: <code class='keyvalue'>page <code class='keyword'><</code> totalPages</code>`,check:()=>~getJ().search(/for\((var|let)page=0;page<totalPages;\S*\)\{\S*\}/)},{message:`В дополняющей части опишите изменение счётчика: <code class='keyvalue'>page <code class='keyword'>=</code> page</code> <code class='keyword'>+</code> <code class='keytext'>1</code>`,check:()=>~getJ().search(/for\((var|let)page=0;page<totalPages;page(\+\+|\+=1|=page\+1)\)\{\S*\}/)},{message:`И в теле цикла добавьте команду печати страницы: <code>keks.print(<code class='keytext'>page</code>)</code>`,check:()=>~getJ().search(/for\((var|let)page=0;page<totalPages;page(\+\+|\+=1|=page\+1)\)\{\S*keks\.print\(page\)\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1036":{theory:`<div><h1>Исправляем цикл</h1><p>Что-то пошло не так, и вместо того, чтобы выводить страницы с первой по седьмую, драйвер выводит пустую страницу и затем страницы с первой по шестую. Рассмотрим, в какой последовательности выполняются части конструкции <code>for</code> на примере:</p><pre>for (var i = 0; i &lt; 5; i = i + 1) {\n  console.log(i);\n};\n</pre><ol><li>Сначала сработает <code>var i = 0;</code>. Будет создана переменная <code>i</code>, равная <code>0</code>.</li><li>Затем выполнится проверка <code>i &lt; 5;</code>. Так как <code>i</code> сейчас равна <code>0</code> и это значение меньше <code>5</code>, условие вернёт <code>true</code>. Это значит, что цикл может продолжить свою работу и перейти к выполнению кода из тела цикла.</li><li>Выполнится код из тела цикла. В нашем случае в консоль выведется <code>0</code> — текущее значение переменной <code>i</code>.</li><li>Выполнится <code>i = i + 1</code>. Переменная <code>i</code> станет равна <code>1</code>.</li><li>Выполнится проверка <code>i &lt; 5;</code>. Она снова вернёт <code>true</code>, так как <code>1</code> меньше <code>5</code>.</li><li>Снова выполнится тело цикла, затем значение <code>i</code> увеличится на единицу, и так дальше по кругу, пока условие <code>i &lt; 5;</code> не вернёт <code>false</code>. Тогда цикл закончит свою работу.</li></ol><p>Теперь посмотрим на пример из предыдущего задания. Почему сначала вывелась пустая страница?</p><p>На первом витке или, по-научному, <i>итерации</i> цикла переменная <code>page</code> ещё равна нулю. А увеличивается до единицы она уже после первой итерации. Если изменить исходное значение переменной <code>page</code> с <code>0</code> на <code>1</code>, то проблема исчезнет.</p><p>А почему страниц шесть, а не семь? Разберём цикл по шагам:</p><pre>Подготовка: totalPages = 7; page = 0\n1 итерация: page = 0; 0 &lt; 7? да! Вывод страницы 0; page = 1\n2 итерация: page = 1; 1 &lt; 7? да! Вывод страницы 1; page = 2\n3 итерация: page = 2; 2 &lt; 7? да! Вывод страницы 2; page = 3\n4 итерация: page = 3; 3 &lt; 7? да! Вывод страницы 3; page = 4\n5 итерация: page = 4; 4 &lt; 7? да! Вывод страницы 4; page = 5\n6 итерация: page = 5; 5 &lt; 7? да! Вывод страницы 5; page = 6\n7 итерация: page = 6; 6 &lt; 7? да! Вывод страницы 6; page = 7\n8 итерация: page = 7; 7 &lt; 7? нет! Завершаем цикл!\n</pre><p>Для получения седьмой страницы, нужно изменить сравнение с «меньше» на «меньше или равно». В этом случае проверка на восьмом витке цикла сработает и выведется седьмая страница.</p><pre>8 итерация: page = 7; 7 &lt;= 7? да! Вывод страницы 7; page = 8\n9 итерация: page = 8; 8 &lt;= 7? нет! Завершаем цикл!\n</pre><p>Подытожим: чтобы всё печаталось, как надо, нужно начать отсчёт со страницы номер <code>1</code> и использовать знак &lt;= в условии, чтобы включить последнюю страницу в расчёт.</p></div>`,html:``,css:``,hidden:``,js:`var totalPages = 7;\n\nfor (var page = 0; page < totalPages; page = page + 1) {\n    keks.print(page);\n}\n`,tasks:[{message:`Исправим режим печати всех страниц. Измените исходное значение переменной <code class='keyvalue'>page</code> на <code class='keytext'>1</code>`,check:()=>~getJ().indexOf('for(varpage=1;')},{message:`Измените в условии цикла «меньше» на «меньше или равно».`,check:()=>~getJ().indexOf('for(varpage=1;page<=totalPages;')},{message:`Чтобы убедиться, что всё работает, задайте переменной <code class='keyvalue'>totalPages</code> значение <code class='keytext'>5</code>. Вы должны получить пять страниц, начиная с первой.`,check:(o)=>o.totalPages===5||~getJ().search(/totalPages=5\D\S*for\(/)}],blocked:"4",editorOff:"8"},
"lesson1037":{theory:`<div><h1>Печатаем страницы в обратном порядке</h1><p>Второй режим работы драйвера завершён! Теперь принтер может печатать все страницы документа и копии заданной страницы. Впечатляет.</p><p>Переходим к третьему режиму: печати страниц в обратном порядке.</p><p>Это нужная и полезная функция. Если напечатать страницы в обратном порядке, то их можно сразу сшивать в один документ без необходимости переворачивать.</p><p>Вы уже знаете все детали работы цикла <code>for</code>, так что остальные режимы реализуете без проблем.</p><p>Для печати в обратном порядке сначала нужно вывести последнюю страницу, затем предпоследнюю и так далее, пока не дойдём до первой. Что это значит в терминах циклов:</p><ol><li>На подготовительном шаге нужно установить номер страницы равным количеству страниц в документе.</li><li>Перед каждой итерацией цикла проверяем, что номер страницы больше нуля (либо больше или равен единице).</li><li>После каждой итерации номер страницы нужно <em>уменьшать</em> на единицу, а не увеличивать, как мы делали ранее.</li></ol></div>`,html:``,css:``,hidden:``,js:`var totalPages = 5;\n\nfor (var page = 1; page <= totalPages; page = page + 1) {\n    keks.print(page);\n}\n`,tasks:[{message:`Выведем страницы в обратном порядке. Измените начальное значение <code class='keyvalue'>page</code> с единицы на <code class='keyvalue'>totalPages</code>`,check:()=>~getJ().indexOf('for(varpage=totalPages;')},{message:`Цикл должен выполняться, пока <code class='keyvalue'>page</code> больше нуля.`,check:()=>~getJ().indexOf('for(varpage=totalPages;page>0;')},{message:`После каждой итерации <code class='keyvalue'>page</code> должна уменьшаться на единицу.`,check:()=>~getJ().search(/for\(varpage=totalPages;page>0;page(--|-=1|=page-1)\)\{\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1038":{theory:`<div><h1>Печатаем только нечётные страницы</h1><p>Как быстро пошла работа! Вспоминаем, что ещё должен уметь принтер:</p><blockquote>Новый принтер достаточно простой, он должен уметь печатать <strike>все страницы в прямом</strike> и <strike>обратном порядке</strike>, печатать чётные и нечётные страницы и <strike>делать копии одной страницы</strike>.</blockquote><p>Осталась печать чётных и нечётных. Печатать только нечётные страницы легко:</p><ul><li>Начинать печать нужно с первой страницы.</li><li>После каждой итерации цикла нужно увеличивать номер текущей страницы на <code>2</code>, а не на <code>1</code>.</li></ul><p>Наверное вы уже заметили, что в циклах постоянно используется увеличение или уменьшение переменных на какое-то число. И нам постоянно приходится писать громоздкие конструкции, типа <code>page = page + 1</code>. К счастью, в JavaScript есть несколько удобных операторов, которые позволяют сократить код. Вот они:</p><table cellpadding="6"><tbody><tr><th align="left">Название</th><th align="left">Пример</th><th align="left">Аналог</th></tr><tr><td>Инкремент (увеличение на единицу)</td><td><code>i++</code></td><td><code>i = i + 1</code></td></tr><tr><td>Декремент (уменьшение на единицу)</td><td><code>i--</code></td><td><code>i = i - 1</code></td></tr><tr><td>К-к-комбо!</td><td><code>i += 2</code></td><td><code>i = i + 2</code></td></tr></tbody></table><p>Комбинировать можно не только сложение, но и остальные математические операции: вычитание <code>-=</code>, умножение <code>*=</code>, деление <code>/=</code> и нахождение остатка <code>%=</code>. Например, <code>i *= 10</code> будет аналогично <code>i = i * 10</code>.</p></div>`,html:``,css:``,hidden:``,js:`var totalPages = 7;\n\nfor (var page = 1; page <= totalPages; page++) {\n    keks.print(page);\n}\n`,tasks:[{message: `Выведем только нечётные страницы. Замените операцию увеличения номера страницы с <code class='keyvalue'>page</code><code class='keyword'>++</code> на <code class='keyvalue'>page</code> <code class='keyword'>+=</code> <code class='keytext'>2</code>`,check:()=>~getJ().indexOf('for(varpage=1;page<=totalPages;page+=2){')},{message:`Измените количество страниц с <code class='keytext'>7</code> на <code class='keytext'>12</code>`,check:(o)=>o.totalPages===12||~getJ().search(/totalPages=12\D\S*for\(/)}],blocked:"4",editorOff:"8"},
"lesson1039":{theory:`<div><h1>Печатаем только чётные страницы</h1><p>Печать чётных страниц отличается от печати нечётных совсем немного: по-прежнему печатаем страницы, увеличивая номер страницы на два, но начинаем не с первой страницы, а со второй.</p></div>`,html:``,css:``,hidden:``,js:`var totalPages = 12;\n\nfor (var page = 1; page <= totalPages; page += 2) {\n    keks.print(page);\n}\n`,tasks:[{message:`Теперь выведем только чётные страницы. Для этого поменяйте начальное значение переменной <code class='keyvalue'>page</code> на <code class='keytext'>2</code>`,check:()=>~getJ().indexOf('for(varpage=2;page<=totalPages;page+=2){')},{message:`Чтобы убедиться, что всё работает, поменяем количество страниц на нечётное <code class='keytext'>9</code>`,check:(o)=>o.totalPages===9||~getJ().search(/totalPages=9\D\S*for\(/)}],blocked:"4",editorOff:"8"},
"lesson1040":{theory:`<div><h1>Драйвер печати: режим копий</h1><p>Все режимы печати реализованы.</p><p>Настало время написать единую программу, которая, в зависимости от выставленного режима будет печатать страницы, как нам нужно: несколько копий одной страницы, все страницы документа в прямом и обратном порядке, только чётные или только нечётные страницы.</p><p>Начнём с режима копирования страницы и будем постепенно добавлять остальные режимы. Название режима будем хранить в переменной <code>mode</code>.</p><p>Конечно, тут не обойдётся без цикла. Давайте на примере разберёмся, как подобная формулировка переводится в код: «Добавьте цикл, который увеличивает переменную i с нуля до 10 включительно. Значение i должно увеличиваться на единицу после каждой итерации».</p><p>Лучше разбирать такую задачу по частям. «Добавьте цикл, который <b>увеличивает переменную i с нуля</b> до 10 включительно». Выходит, переменная, которая будет менять своё значение по ходу работы цикла, будет <code>i</code>. Значит, это и есть переменная-счётчик. Её значение будет меняться от <code>0</code> и дальше. То есть стартовое значение счётчика — <code>0</code>. Так и записываем:</p><pre>for (<b>var i = 0;</b>) {\n  …\n}\n</pre><p>Обратите внимание, что мы используем <code>var</code> для объявления счётчика. Это такая же переменная, как и любая другая, и объявлять её надо с помощью <code>var</code>.</p><p>Идём дальше. «...увеличивает переменную i с нуля <b>до 10 включительно</b>». Значит, значение счётчика (переменной <code>i</code>) будет расти до <code>10</code>. Так как в тексте сказано, «до 10 включительно», то последнее значение <code>i</code>, с которым цикл выполнится, будет <code>10</code>. Чтобы это значение попало в переменную <code>i</code> и цикл выполнился, используем знак <code>&lt;=</code>.</p><pre>for (var i = 0; <b>i &lt;= 10;</b>) {\n  …\n}\n</pre><p>«Значение i должно увеличиваться на единицу после каждой итерации». Значит, мы должны прибавлять к <code>i</code> единицу после каждого витка цикла. Будем использовать инкремент.</p><pre>for (var i = 0; i &lt;= 10; <b>i++</b>) {\n  …\n}\n</pre><p>В примере мы использовали стандартное название <code>i</code> для счётчика цикла. В случае c копиями страниц мы будем считать сколько копий уже сделано и сравнивать это число с необходимым количеством. То есть будем увеличивать число копий. Поэтому для счётчика тут вполне подойдёт имя <code>copies</code>.</p></div>`,html:``,css:``,hidden:``,js:`var mode = 'pageCopy'; // Режим работы драйвера печати\nvar pageNumber = 5; // Номер копируемой страницы\nvar copyCount = 7; // Количество копий\n`,tasks:[{message:`Добавим режим печати копий. После объявления переменных добавьте условие, проверяющее, что <code class='keyvalue'>mode</code> имеет значение <code class='keytext'>'pageCopy'</code>`,check:()=>~getJ().search(/varcopyCount=\S*if\(mode===?('|"|`)pageCopy\1\)\{\S*\}/)},{message:`Внутри этого условия добавьте цикл, который увеличивает переменную <code class='keyvalue'>copies</code> с единицы до <code class='keyvalue'>copyCount</code> включительно. Значение <code class='keyvalue'>copies</code> должно увеличиваться на единицу после каждой итерации.`,check:()=>~getJ().search(/varcopyCount=\S*if\(mode===?('|"|`)pageCopy\1\)\{\S*for\((var|let)copies=1;copies<=copyCount;copies(\+\+|\+=1|=copies\+1)\)\{\S*\}\S*\}/)},{message:`Внутри цикла добавьте команду печати копируемой страницы: <code>keks.print(<code class='keytext'>pageNumber</code>)</code>`,check:()=>~getJ().search(/varcopyCount=\S*if\(mode===?('|"|`)pageCopy\1\)\{\S*for\((var|let)copies=1;copies<=copyCount;copies(\+\+|\+=1|=copies\+1)\)\{\S*keks\.print\(pageNumber\)\S*\}\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1041":{theory:`<div><h1>Драйвер печати: все страницы</h1><p>Первый режим добавлен, хорошо!</p><p>Теперь добавим режим распечатки всех страниц документа. Он будет называться <code>'document'</code>. Общее количество страниц хранится в переменной <code>totalPages</code>.</p><p>Здесь мы будем печатать страницы одну за другой и следить, чтобы все они были напечатаны. Поэтому счётчик можно назвать <code>page</code>, он будет показывать номер страницы, которую напечатал принтер.</p></div>`,html:``,css:``,hidden:``,js:`var mode = 'pageCopy'; // Режим работы драйвера печати\nvar pageNumber = 5; // Номер копируемой страницы\nvar copyCount = 7; // Количество копий\nvar totalPages = 6; // Всего страниц в документе\n\nif (mode === 'pageCopy') {\n    for (var copies = 1; copies <= copyCount; copies++) {\n        keks.print(pageNumber);\n    }\n}\n`,tasks:[{message:`Добавим режим вывода всех страниц документа. В конец программы добавьте проверку, сравнивающую <code class='keyvalue'>mode</code> со значением <code class='keytext'>'document'</code>`,check:()=>~getJ().search(/if\(mode===?('|"|`)document\1\)\{\S*\}/)},{message:`Внутри этой проверки добавьте цикл, который увеличивает значение переменной <code class='keyvalue'>page</code> от <code class='keytext'>1</code> до <code class='keyvalue'>totalPages</code> включительно.`,check:()=>~getJ().search(/if\(mode===?('|"|`)document\1\)\{\S*for\((var|let)page=1;page<=totalPages;page(\+\+|\+=1|=page\+1)\)\{\S*\}\S*\}/)},{message:`Внутри цикла добавьте команду печати текущей страницы <code class='keyvalue'>page</code>`,check:()=>~getJ().search(/if\(mode===?('|"|`)document\1\)\{\S*for\((var|let)page=1;page<=totalPages;page(\+\+|\+=1|=page\+1)\)\{\S*keks\.print\(page\)\S*\}\S*\}/)},{message:`Измените значение переменной mode на <code class='keytext'>'document'</code>`,check:(o)=>o.mode==='document'||~getJ().search(/mode=('|"|`)document\1\D\S*if\(mode=/)}],blocked:"4",editorOff:"8"},
"lesson1042":{theory:`<div><h1>Драйвер печати: страницы в обратном порядке</h1><p>Теперь выведем страницы в обратном порядке.</p><p>Режим будет называться <code>'reverse'</code>, нужно добавить условие и отдельный цикл.</p><p>Как писать циклы по подобным условиям: «Добавьте цикл, который уменьшает значение переменной i от 10 до 1 включительно. Уменьшайте значение i на единицу на каждой итерации»? Как обычно, будет разбираться постепенно.</p><p>«...цикл, который уменьшает <b>значение переменной i от 10</b> до 1 включительно». Счётчик здесь <code>i</code>, а его стартовое значение <code>10</code>. Записываем.</p><pre>for (<b>var i = 10;</b>) {\n  …\n}\n</pre><p>«...цикл, который уменьшает значение переменной i <b>от 10 до 1 включительно</b>». Это значит, что цикл закончит свою работу, когда <code>i</code> станет равно <code>0</code>. При <code>i = 1</code> цикл совершит очередную итерацию. Так как стартовое значение счётчика <code>10</code> и оно будет уменьшаться до <code>1</code> включительно, нам подойдёт знак «больше или равно». Сранивать будем с <code>1</code> так как это значение, после которого цикл должен остановиться.</p><pre>for (var i = 10; <b>i &gt;= 1;</b>) {\n  …\n}\n</pre><p>Обратите внимание, что условие можно написать и немного по-другому. Если нам нужно учесть значение <code>1</code>, но при значении меньше <code>1</code> закончить работу цикла, то можно использовать знак «больше». Только сравнивать его с <code>0</code>. Тогда единица точно будет использоваться в качестве значения счётчика, а при <code>0</code> цикл закончит свою работу.</p><pre>for (var i = 10; <b>i &gt; 0;</b>) {\n  …\n}\n</pre><p>Есть два варианта написать условие в таких случаях, и оба верные. Можете использовать любой.</p><p>«Уменьшайте значение i на единицу на каждой итерации». Здесь привычное нам изменение значения на единицу. Только теперь мы не увеличиваем значение счётчика, а уменьшаем, поэтому используем декремент.</p><pre>for (var i = 10; i &gt; 0; <b>i--</b>) {\n  …\n}\n</pre><p>Вернёмся к принтеру. В этом режиме мы будем считать страницы в обратном порядке и ждать, когда напечатается последняя страница, в нашем случае первая, так как счёт идёт с конца. Счётчик <code>page</code> у нас уже был, поэтому используем <code>reversePage</code> раз считаем страницы в обратном порядке.</p></div>`,html:``,css:``,hidden:``,js:`var mode = 'document'; // Режим работы драйвера печати\nvar pageNumber = 5; // Номер копируемой страницы\nvar copyCount = 7; // Количество копий\nvar totalPages = 6; // Всего страниц в документе\n\nif (mode === 'pageCopy') {\n    for (var copies = 1; copies <= copyCount; copies++) {\n         keks.print(pageNumber);\n    }\n}\n\nif (mode === 'document') {\n    for (var page = 1; page <= totalPages; page++) {\n        keks.print(page);\n    }\n}\n`,tasks:[{message:`Добавим режим вывода страниц документа в обратном порядке. В конец программы добавьте проверку, сравнивающую <code class='keyvalue'>mode</code> со значением <code class='keytext'>'reverse'</code>`,check:()=>~getJ().search(/if\(mode===?('|"|`)reverse\1\)\{\S*\}/)},{message:`Внутри этой проверки добавьте цикл, который уменьшает значение переменной <code class='keyvalue'>reversePage</code> от <code class='keyvalue'>totalPages</code> до <code class='keytext'>1</code> включительно. Уменьшайте значение <code class='keyvalue'>reversePage</code> на единицу на каждой итерации.`,check:()=>~getJ().search(/if\(mode===?('|"|`)reverse\1\)\{\S*for\((var|let)reversePage=totalPages;reversePage>(=1|0);reversePage(--|-=1|=reversePage-1)\)\{\S*\}\S*\}/)},{message:`Внутри цикла добавьте команду печати текущей страницы <code class='keyvalue'>reversePage</code>`,check:()=>~getJ().search(/if\(mode===?('|"|`)reverse\1\)\{\S*for\((var|let)reversePage=totalPages;reversePage>(=1|0);reversePage(--|-=1|=reversePage-1)\)\{\S*keks\.print\(reversePage\)\S*\}\S*\}/)},{message:`Измените значение переменной <code class='keyvalue'>mode</code> на <code class='keytext'>'reverse'</code>`,check:(o)=>o.mode==='reverse'||~getJ().search(/mode=('|"|`)reverse\1\S*if\(mode/)}],blocked:"4",editorOff:"8"},
"lesson1043":{theory:`<div><h1>Драйвер печати: чётные и нечётные страницы</h1><p>Теперь добавим вывод страниц через одну.</p><p>Режим будет активироваться при значении <code>'alternate'</code> переменной <code>mode</code>.</p><p>Для выбора между чётностью и нечётностью выводимых страниц будем использовать переменную <code>startPage</code> — если она равна <code>1</code>, выводятся нечётные страницы, если <code>2</code> — чётные.</p><p>Так как у нас альтернативный вид печати, то и страницы печатаются в непривычном порядке. Счётчик можно назвать примерно так же, как режим печати <code>alternatePage</code>.</p><p>Обратите внимание, что инкремент здесь не пригодится. Счётчик будет увеличиваться на двойку, поэтому используйте запись вида <code>счётчик = счётчик + 2</code> или сокращённый вариант <code>счётчик += 2</code>.</p><p>Сейчас мы добавим новый режим печати, а в следующем задании поэкспериментируем с этим режимом и попереключаемся между печатью чётных и нечётных страниц.</p></div>`,html:``,css:``,hidden:``,js:`var mode = 'reverse'; // Режим работы драйвера печати\nvar pageNumber = 5; // Номер копируемой страницы\nvar copyCount = 7; // Количество копий\nvar totalPages = 6; // Всего страниц в документе\nvar startPage = 1; // Стартовая страница\n\nif (mode === 'pageCopy') {\n    for (var copies = 1; copies <= copyCount; copies++) {\n        keks.print(pageNumber);\n    }\n}\n\nif (mode === 'document') {\n    for (var page = 1; page <= totalPages; page++) {\n        keks.print(page);\n    }\n}\n\nif (mode === 'reverse') {\n    for (var reversePage = totalPages; reversePage >= 1; reversePage--) {\n        keks.print(reversePage);\n    }\n}`,tasks:[{message:`Добавим режим вывода чётных и нечётных страниц документа. Добавьте в конец программы проверку для режима <code class='keytext'>'alternate'</code>`,check:()=>~getJ().search(/mode=\S*if\(mode===?('|"|`)alternate\1\)\{\S*\}/)},{message:`Внутри этой проверки добавьте цикл, в котором значение переменной <code class='keyvalue'>alternatePage</code> увеличивается на <code class='keytext'>2</code> со значения <code class='keyvalue'>startPage</code> до <code class='keyvalue'>totalPages</code> включительно.`,check:()=>~getJ().search(/if\(mode===?('|"|`)alternate\1\)\{\S*for\((var|let)alternatePage=startPage;alternatePage<=totalPages;alternatePage(\+=2|=alternatePage\+2)\)\{\S*\}\S*\}/)},{message:`Внутри цикла добавьте команду печати страницы <code class='keyvalue'>alternatePage</code>`,check:()=>~getJ().search(/if\(mode===?('|"|`)alternate\1\)\{\S*for\((var|let)alternatePage=startPage;alternatePage<=totalPages;alternatePage(\+=2|=alternatePage\+2)\)\{\S*keks\.print\(alternatePage\)\S*\}\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1044":{theory:`<div><h1>Драйвер печати: переключение чётных и нечётных</h1><p>Пришло время проверить, как работает режим печати чётных и нечётных страниц.</p><p>Чтобы включить этот режим, зададим переменной <code>mode</code> значение <code>'alternate'</code>.</p><p>Чтобы вывести чётные страницы вместо нечётных, изменим стартовую страницу с первой на вторую.</p></div>`,html:``,css:``,hidden:``,js:`var mode = 'reverse'; // Режим работы драйвера печати\nvar pageNumber = 5; // Номер копируемой страницы\nvar copyCount = 7; // Количество копий\nvar totalPages = 6; // Всего страниц в документе\nvar startPage = 1; // Стартовая страница\n\nif (mode === 'pageCopy') {\n    for (var copies = 1; copies <= copyCount; copies++) {\n        keks.print(pageNumber);\n    }\n}\n\nif (mode === 'document') {\n   for (var page = 1; page <= totalPages; page++) {\n        keks.print(page);\n    }\n}\n\nif (mode === 'reverse') {\n    for (var reversePage = totalPages; reversePage >= 1; reversePage--) {\n        keks.print(reversePage);\n    }\n}\n\nif (mode === 'alternate') {\n    for (var alternatePage = startPage; alternatePage <= totalPages; alternatePage += 2) {\n        keks.print(alternatePage);\n    }\n}\n`,tasks:[{message:`А теперь давайте используем режим, добавленный в прошлом задании. Смените значение переменной <code class='keyvalue'>mode</code> на <code class='keytext'>'alternate'</code>`,check:(o)=>o.mode==='alternate'||~getJ().search(/mode=('|"|`)alternate\1\S*if\(mode===?('|"|`)alternate\2\)/)},{message:`Чтобы вывести чётные страницы, смените значение переменной <code class='keyvalue'>startPage</code> на <code class='keytext'>2</code>`,check:(o)=>o.startPage===2||~getJ().search(/startPage=2\D\S*if\(mode===?('|"|`)alternate\1\)/)}],blocked:"4",editorOff:"8"},
"lesson1045":{theory:`<div><h1>Накопление в цикле</h1><p>Внутри циклов можно не только запускать печать страниц, но и использовать обычные математические операции. Например, сложение:</p><pre>for (var i = 1; i &lt;= 5; i++) {\n  console.log(2 + 2);\n}\n</pre><p>Результат программы будет таким:</p><pre>LOG: 4 (number)\nLOG: 4 (number)\nLOG: 4 (number)\nLOG: 4 (number)\nLOG: 4 (number)\n</pre><p>Число 4 выведется в консоль 5 раз, ведь именно столько итераций в этом цикле. То есть на каждой итерации двойки будут складываться и выводиться в консоль. Но если на каждой итерации нам нужно получать новое, увеличенное, число, надо действовать по-другому. Нужно завести <em>перед</em> циклом ещё одну переменную, которая и будет хранить сумму:</p><pre>var sum = 0;\n\nfor (var i = 1; i &lt;= 5; i++) {\n  sum += 2;\n  console.log(sum);\n}\n</pre><p>Программа выведет:</p><pre>LOG: 2 (number)\nLOG: 4 (number)\nLOG: 6 (number)\nLOG: 8 (number)\nLOG: 10 (number)\n</pre><p>Теперь на каждой итерации мы добавляем 2 к переменной <code>sum</code>, накапливая её значение. Переменная <code>sum</code> объявлена снаружи цикла (а не внутри тела цикла, что важно), поэтому её значение не сбрасывается при попадании в тело цикла, а увеличивается на 2.</p><p>Такая операция называется накоплением значения в цикле.</p><p>Давайте потренируемся накапливать значения и посчитаем сумму чисел от <code>1</code> до <code>10</code>. Будем выводить в консоль промежуточные результаты, чтобы следить за изменениями суммы.</p></div>`,html:``,css:``,hidden:``,js:``,tasks:[{message:"В начале кода создайте переменную <code class='keyvalue'>sum</code>, которая равна <code class='keytext'>0</code>",check:(o)=>o.sum===0},{message:"Ниже, после переменной, создайте цикл <code class='keyword'>for</code>, который увеличивает значение счётчика <code class='keyvalue'>i</code> от <code class='keytext'>1</code> до <code class='keytext'>10</code> включительно.",check:()=>~getJ().search(/for\((var|let)i=1;i<=10;i(\+\+|\+=1|=i\+1)\)\{\S*\}/)},{message:"Внутри цикла на каждой итерации увеличивайте сумму на значение счётчика <code class='keyvalue'>sum <code class='keyword'>+=</code> i</code>;",check:()=>~getJ().search(/for\((var|let)i=1;i<=10;i(\+\+|\+=1|=i\+1)\)\{\S*sum(\+=i|=sum\+i)\S*\}/)},{message:"В теле цикла, после увеличения <code class='keyvalue'>sum</code>, выведите в <code class='keyword'>консоль</code> <code><code class='keytext'>'i: '</code> <code class='keyword'>+</code> <code class='keyvalue'>i</code></code>",check:()=>~getJ().search(/for\((var|let)i=1;i<=10;i(\+\+|\+=1|=i\+1)\)\{\S*sum(\+=i|=sum\+i)\S*\S*console\.log\(('|"|`)i:\4\+i\)\S*\}/)},{message:"Затем выведите в <code class='keyword'>консоль</code> <code><code class='keytext'>'sum: '</code> <code class='keyword'>+</code> <code class='keyvalue'>sum</code></code>",check:()=>~getJ().search(/for\((var|let)i=1;i<=10;i(\+\+|\+=1|=i\+1)\)\{\S*sum(\+=i|=sum\+i)\S*\S*console\.log\(('|"|`)sum:\4\+sum\)\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1046":{theory:`<div><h1>Проверки в циклах</h1><p>До этого мы писали циклы внутри условий, но можно и наоборот! Если добавить условие внутрь цикла, то оно будет проверяться на каждой итерации.</p><p>Например, можно проверять значение счётчика, и если оно больше двух, прибавлять к сумме 3, а не 2.</p><pre>var sum = 0;\n\nfor (var i = 1; i &lt;= 5; i++) {\n  if (i &gt; 2) {\n    sum += 3;\n  } else {\n    sum += 2;\n  }\n  console.log(sum);\n}\n</pre><p>Результат программы:</p><pre>LOG: 2 (number)\nLOG: 4 (number)\nLOG: 7 (number)\nLOG: 10 (number)\nLOG: 13 (number)\n</pre><p>Потренируемся добавлять условия в циклы. Добавим проверку в наш цикл из предыдущего задания. Если значение счётчика больше <code>5</code> будем прибавлять к <code>sum</code> число <code>2</code>.</p></div>`,html:``,css:``,hidden:``,js:`var sum = 0;\n\nfor (var i = 1; i <= 10; i++) {\n\n    // Добавляйте условие сюда\n\n    sum += i;\n    console.log('i: ' + i);\n    console.log('sum: ' + sum);\n}\n`,tasks:[{message:"Внутри цикла, до увеличения <code class='keyvalue'>sum</code>, добавьте проверку, что <code class='keyvalue'>i</code> больше <code class='keytext'>5</code>.",check:()=>~getJ().search(/for\(\S*\{\S*if\((i>5|5<i)\)\{\S*\}\S*sum\+=i/)},{message:"Если условие срабатывает, увеличивайте <code class='keyvalue'>sum</code> на <code class='keytext'>2</code>.",check:()=>~getJ().search(/for\(\S*\{\S*if\((i>5|5<i)\)\{\S*sum(\+=2|=sum\+2)\S*\}\S*sum\+=i/)},{message:"Добавьте ветку <code class='keyword'>else</code> и перенесите в неё строку <code class='keyvalue'>sum <code class='keyword'>+=</code> i</code>;",check:()=>~getJ().search(/for\(\S*\{\S*if\((i>5|5<i)\)\{\S*sum(\+=2|=sum\+2)\S*\}else\{\S*sum\+=i\S*\}\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1047":{theory:`<div><h1>Поиск чётного числа</h1><p>Проверки в циклах очень удобны. Они позволяют делать проверки на каждой итерации цикла.</p><p>Например, в цикле из прошлых заданий будем проверять чётное ли сейчас число <code>i</code>. И если число чётное, будем прибавлять к сумме <code>2</code>, а если число нечётное, будем прибавлять <code>1</code>.</p><p>Как проверить, что число чётное? Здесь может помочь оператор <code>%</code>. Он называется <em>остаток от деления</em> и, как понятно из названия, возвращает остаток от деления.</p><pre>10 % 5;  // Вернёт 0\n12 % 5;  // Вернёт 2\n7 % 3;   // Вернёт 1\n5.5 % 2; // Вернёт 1.5\n</pre><p>Как это поможет в определении чётного или нечётного числа? Чётное число делится на <code>2</code> без остатка. Поэтому, если деление <code>i % 2</code> возвращает <code>0</code> — число чётное, иначе число нечётное.</p><p>Напишем проверку с использованием <code>%</code> в нашем цикле.</p><p><span>Кстати,</span> значение, которое возвращает оператор <code>%</code> — то же самое, что остаток от деления в арифметике. Это деление проще понять на бытовом примере. Представьте, что у вас 13 конфет, а людей в компании 4 (включая вас). Как поделить конфеты на всех, чтобы никого не обидеть? Поровну не получится, потому что 13 не делится на 4 без дробных частей. Зато поровну на 4 части делится число 12. Можно раздать по 3 конфеты каждому. Тогда вы раздадите 12 конфет и ещё останется одна про запас, потому что изначально конфет было 13. Вот эта конфета «про запас» и есть остаток от деления.</p></div>`,html:``,css:``,hidden:``,js:`var sum = 0;\n\nfor (var i = 1; i <= 10; i++) {\n    console.log('i: ' + i);\n\n    // Проверку добавляйте сюда\n\n    console.log('sum: ' + sum);\n}\n`,tasks:[{message:"Внутри цикла добавьте проверку, что счётчик чётный <code class='keytext'>(<code class='keyvalue'>i</code> <code class='keyword'>%</code> 2 <code class='keyword'>===</code> 0)</code>",check:()=>~getJ().search(/for\S*\{\S*if\(i%2===?0\)\{\S*\}\S*\}/)},{message:"Если проверка выполняется, увеличивайте переменную <code class='keyvalue'>sum</code> на <code class='keytext'>2</code>",check:()=>~getJ().search(/for\S*\{\S*if\(i%2===?0\)\{\S*sum(\+=2|=sum\+2)\S*\}\S*\}/)},{message:"Внутри условия, после увеличения суммы, выводите в <code class='keyword'>консоль</code> строку <code class='keytext'>'чётное число'</code>",check:()=>~getJ().search(/for\S*\{\S*if\(i%2===?0\)\{\S*sum(\+=2|=sum\+2)\S*console\.log\(('|"|`)чётноечисло\2\)\S*\}\S*\}/)},{message:"После проверки добавьте ветку <code class='keyword'>else</code> и увеличивайте внутри неё <code class='keyvalue'>sum</code> на <code class='keytext'>1</code>",check:()=>~getJ().search(/for\S*\{\S*if\(i%2===?0\)\{\S*\}else\{\S*sum(\+=1|\+\+|=sum\+1)\S*\}\S*\}/)},{message:"Внутри <code class='keyword'>else</code>, после увеличения <code class='keyvalue'>sum</code>, выведите в <code class='keyword'>консоль</code> строку <code class='keytext'>'нечётное число'</code>",check:()=>~getJ().search(/for\S*\{\S*if\(i%2===?0\)\{\S*\}else\{\S*sum(\+=1|\+\+|=sum\+1)\S*console\.log\(('|"|`)нечётноечисло\2\)\S*\}\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1048":{theory:`<div><h1>Сколько стоит печать?</h1><p>Вернёмся к принтеру. Мы написали программу, которая умеет печатать страницы, но упустили из виду одну деталь — на печать каждой страницы тратится краска. В нашем принтере на одну страницу «уходит» 70 мг порошка с краской. Хорошо бы следить за расходом тонера и знать сколько тратится на печать одного документа.</p><p>Для решения этой задачи будем использовать накопление значений в цикле. Заведём внешнюю переменную, куда будем добавлять 70 мг (расход на одну страницу) при печати каждой страницы документа. Но сначала эту переменную нужно назвать.</p><p>Не нужно придумывать сложные имёна для переменных, их назначение должно быть понятным из названия. Поэтому мы определяем, что должно храниться в переменной, например, общий расход краски на все страницы, и переводим это на английский язык. Мы могли бы назвать переменную <code>consumptionColorForAllPages</code> или <code>consumptionTonerForAllPages</code>, но это избыточно. Мы решаем задачу только про расход тонера, другого кода у нас нет, поэтому название можно сократить и убрать указание на то, расход чего мы считаем. Это и так понятно, другой задачи у нас нет. А <code>ForAllPages</code> — слишком длинно. Если отбросить подробности, мы считаем общий расход краски. Для слова «общий» есть простое английское обозначение «total», поэтому назовём переменную <code>consumptionTotal</code> — это название краткое и при этом оно объясняет значение переменной.</p><p>Аналогично поступим с именем переменной, которая будет хранить расход краски на одну страницу (70 мг). Назовём её <code>consumptionPerPage</code>.</p><p>Посчитаем расход тонера на печать всех страниц. Считать будем в режиме печати обычного документа.</p></div>`,html:``,css:``,hidden:``,js:`var totalPages = 6; // Всего страниц в документе\n\nfor (var page = 1; page <= totalPages; page++) {\n    keks.print(page);\n}\n`,tasks:[{message:"После переменной <code class='keyvalue'>totalPages</code> объявите переменную <code class='keyvalue'>consumptionTotal</code> равную <code class='keytext'>0</code>",check:(o)=>o.consumptionTotal===0},{message:"После неё создайте переменную <code class='keyvalue'>consumptionPerPage</code>. Она равна <code class='keytext'>70</code>",check:(o)=>o.consumptionPerPage===70},{message:"Внутри цикла, после вызова команды <code>keks.print()</code>, увеличьте значение переменной <code class='keyvalue'>consumptionTotal</code> на <code class='keyvalue'>consumptionPerPage</code> с помощью оператора <code class='keyword'>+=</code>",check:()=>~getJ().search(/for\(\S*\{\S*keks\.print\S*consumptionTotal\+=consumptionPerPage\S*\}/)},{message:"Ниже, в цикле, выведите значение <code class='keyvalue'>consumptionTotal</code> в <code class='keyword'>консоль</code>.",check:()=>~getJ().search(/for\(\S*\{\S*consumptionTotal\+=consumptionPerPage\S*console\.log\(consumptionTotal\)\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1049":{theory:`<div><h1>Экономичная печать</h1><p>Нашим принтером часто пользуются студенты, а для студентов очень важна экономия. Экономия на всём. Наши аналитики выяснили, что преподаватели обычно читают не больше первых трёх страниц всех отчётов, курсовиков и прочих студенческих документов. Из этого тайного знания родилась идея режима печати для студентов: первые три страницы печатаем как обычно, а на оставшихся экономим тонер во все тяжкие (то есть используем в ДВА раза меньше тонера)!</p><p>Теперь нам нужно не просто увеличивать значение <code>consumptionTotal</code> при каждой итерации на <code>70</code>, но и проверять в каком режиме печати мы находимся (экономичном или обычном) и какую по счёту страницу документа печатаем. Тут пригодятся условия.</p><p>Используем условие в цикле, чтобы проверить режим печати. Если режим экономичный, будем отлавливать страницы с номером больше <code>3</code> и печатать их с меньшим расходом краски. Половину расхода будем записывать как <code>consumptionPerPage * 0.5</code>.</p></div>`,html:``,css:``,hidden:``,js:`var totalPages = 6; // Всего страниц в документе\n\nvar consumptionTotal = 0; // Общий расход тонера\nvar consumptionPerPage = 70; // Расход краски на одну страницу\n\nfor (var page = 1; page <= totalPages; page++) {\n    keks.print(page);\n\n    // Добавляйте условие сюда\n\n    consumptionTotal += consumptionPerPage;\n    console.log(consumptionTotal);\n}\n`,tasks:[{message:"После переменной <code class='keyvalue'>consumptionPerPage</code> создайте переменную <code class='keyvalue'>economyMode</code>, которая содержит <code class='keyword'>false</code>",check:(o)=>o.economyMode===false},{message:"В цикле после вызова <code>keks.print()</code> добавьте условие, которое срабатывает, если <code class='keyvalue'>economyMode</code> равен <code class='keyword'>true</code> и номер текущей страницы <code class='keyvalue'>page</code> больше <code class='keytext'>3</code>",check:()=>~getJ().search(/for\S*\{\S*keks\.print\S*if\((economyMode===?true&&page>3|page>3&&economyMode===?true)\)\{\S*\}\S*\}/)},{message:"Внутри этого условия увеличивайте <code class='keyvalue'>consumptionTotal</code> на <code class='keyvalue'>consumptionPerPage</code> <code class='keyword'>*</code> <code class='keytext'>0.5</code> с помощью оператора <code class='keyword'>+=</code>",check:()=>~getJ().search(/for\S*\{\S*keks\.print\S*if\((economyMode===?true&&page>3|page>3&&economyMode===?true)\)\{\S*consumptionTotal\+=(consumptionPerPage\*0?.5|0?.5\*consumptionPerPage)\S*\}\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1050":{theory:`<div><h1>Экономим краску</h1><p>Подсчёт расхода тонера почти готов. Сейчас код в теле цикла выглядит так:</p><pre>if (economyMode &amp;&amp; page &gt; 3) {\n    consumptionTotal += consumptionPerPage * 0.5;\n}\n\nconsumptionTotal += consumptionPerPage;\n</pre><p>Получается, если включен экономичный режим и номер страницы больше трёх, мы тратим половину краски от обычного режима на одну страницу. А потом, неважно, сработает условие или нет, мы обязательно увеличиваем расход ещё <code>consumptionTotal += consumptionPerPage;</code>. Получается не экономия, а сплошные расходы. Добавим ветку <code>else</code> к условию и перенесём туда строку <code>consumptionTotal += consumptionPerPage;</code>. Затем включим режим экономии тонера и проверим, что всё работает правильно.</p></div>`,html:``,css:``,hidden:``,js:`var totalPages = 6; // Всего страниц в документе\n\nvar consumptionTotal = 0; // Общий расход тонера\nvar consumptionPerPage = 70; // Расход краски на одну страницу\nvar economyMode = false;\n\nfor (var page = 1; page <= totalPages; page++) {\n    keks.print(page);\n\n    if (economyMode && page > 3) {\n        consumptionTotal += consumptionPerPage * 0.5;\n    }\n\n    consumptionTotal += consumptionPerPage;\n    console.log(consumptionTotal);\n}\n`,tasks:[{message:"Добавьте ветку <code class='keyword'>else</code> и перенесите туда <code class='keyvalue'>consumptionTotal <code class='keyword'>+=</code> consumptionPerPage</code>;",check:()=>~getJ().search(/if\(economyMode\S*\}else\{\S*consumptionTotal\+=consumptionPerPage\S*\}\S*\}/)},{message:"Поменяйте значение <code class='keyvalue'>economyMode</code> на <code class='keyword'>true</code>",check:(o)=>o.economyMode===true||~getJ().search(/economyMode=true\S*if\(economyMode/)}],blocked:"4",editorOff:"8"},
"lesson1051":{theory:`<section><h1>Конспект «Циклы». Часть 1</h1><h2>Цикл for</h2><h3>Синтаксис</h3><pre>for (var i = 0; i &lt; 10; i++) {\n  // повторяющиеся команды\n}\n</pre><p><code>var i = 0;</code> — подготовительная часть, исходное значение для счётчика. Задаётся с помощью <code>var</code>, как обычная переменная.</p><p><code>i &lt; 10;</code> — проверочная часть. Если условие возвращает <code>true</code>, цикл делает ещё одну итерацию иначе прекращает свою работу.</p><p><code>i++</code> — дополняющая часть, запускается на каждой итерации после выполнения кода из тела цикла. Меняет значение счётчика.</p><h3>Накопление значений в цикле:</h3><pre><b>var sum = 0;</b>\n\nfor (var i = 1; i &lt;= 5; i++) {\n    <b>sum += 2;</b>\n    console.log(sum);\n}\n</pre><p>Программа выведет:</p><pre>LOG: 2 (number)\nLOG: 4 (number)\nLOG: 6 (number)\nLOG: 8 (number)\nLOG: 10 (number)\n</pre><h3>Проверки в теле цикла</h3><pre>var sum = 0;\n\nfor (var i = 1; i &lt;= 5; i++) {\n    <b>if (i &gt; 2) {</b>\n        sum += 1;\n    <b>}</b>\n}\n</pre><h2>Поиск чётного числа</h2><p>Оператор % или «остаток от деления» возвращает остаток от деления.</p><pre>10 % 5;  // Вернёт 0\n12 % 5;  // Вернёт 2\n7 % 3;   // Вернёт 1\n5.5 % 2; // Вернёт 1.5\n</pre><p>Если остаток от деления числа на <code>2</code> равен <code>0</code> — число чётное, иначе нечётное.</p><br></section>`,html:``,css:``,hidden:``,js:`var sum = 0;\nvar finalNumber = 25;\n\n\/\/Цикл должен быть здесь:\n\nconsole.log(sum);`,tasks:[{message:"С помощью цикла найдите сумму чисел, кратных <code class='keytext'>3</code>, от <code class='keytext'>1</code> до <code class='keyvalue'>finalNumber</code>",check:(o)=>~o.log.indexOf(108)}],blocked:"4",editorOff:"9"},
"lesson1052":{theory:`<div><h1>Третья программа: «Протеиновый коктейль!»</h1><p>Пришло время для третьей собственной программы, которая поможет Кексу правильно запастись протеином на любой период, например, на 15 или 25 дней.</p><p>Особенность диеты Кекса в том, что количество протеина в чётные и нечётные дни разное. Впрочем, вот техническое задание, написанное лапой Кекса:</p><blockquote><p>Мяу! Программа должна считать сколько протеина я должен выпить за весь тренировочный период.</p><p>В чётные дни я пью <code>200</code> грамм. В нечётные <code>100</code> грамм.</p><p>Количество дней хранится в переменной <code>days</code>, количество протеина для приёма в чётный день — в переменной <code>evenDayAmount</code>, протеин в нечётный день — в переменной <code>oddDayAmount</code>, а результат необходимо записать в переменную <code>total</code>, которая уже задана.</p></blockquote><p>В этой программе удобно использовать цикл, в котором будет накапливаться количество протеина. Обратите внимание, что в задаче вы работаете с днями, поэтому <b>дни надо считать с 1</b>, а не с <code>0</code>.</p><p>Чтобы задача решалась верно, нужно определять чётные и нечётные дни в периоде. Используйте для этого оператор <code>%</code> (остаток от деления).</p></div>`,html:``,css:``,hidden:``,js:`var days = 9; // Дней в периоде\nvar evenDayAmount = 200; // Количество протеина в чётные дни\nvar oddDayAmount = 100; // Количество протеина в нечётные дни\nvar total = 0; // Общее количество протеина\n\n`,tasks:[{message:`<button onclick="fH1.a()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p><code class='keyword'>Мяу!</code> Программа должна считать сколько протеина я должен выпить за весь тренировочный период.</p><p>В чётные дни я пью <code class='keytext'>200</code> грамм. В нечётные <code class='keytext'>100</code> грамм.</p><p>Количество дней хранится в переменной <code class='keyvalue'>days</code>, количество протеина для приёма в чётный день — в переменной <code class='keyvalue'>evenDayAmount</code>, протеин в нечётный день — в переменной <code class='keyvalue'>oddDayAmount</code>, а результат необходимо записать в переменную <code class='keyvalue'>total</code>, которая уже задана.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1053":{theory:`<div><h1>Привет, «пока»!</h1><p>Замечательно! Вы разобрались с циклом <code>for</code>. Его удобно использовать, когда число повторений известно заранее, ещё до запуска цикла. Например, когда известно количество страниц в документе или количество дней.</p><p>Но встречаются ситуации, когда количество повторений заранее неизвестно. Например, биатлон: стреляй по мишеням, пока не закроешь все.</p><p>В таких случаях, когда цикл повторяется снова и снова, пока не выполнится условие, удобнее использовать цикл <code>while</code> (слово while в переводе с английского означает «пока»).</p><pre>while (условие) {\n  действия\n}</pre><p>Действия, указанные в цикле, будут выполняться снова и снова, пока условие не вернёт <code>false</code>.</p><p>Потренируемся использовать цикл <code>while</code>, пока босс не подкинул новую рабочую задачу.</p><p>В перерывах между работой босс любит сыграть в дартс. Он пытается поставить рекорд: набрать максимальное количество очков в серии бросков без промаха. Как только он промахивается, серия заканчивается (и судя по дыркам в стене, промахивается он часто).</p><p>Нам нужно написать простенькую программку, которая фиксирует эти рекорды. С помощью команды <code>keks.getScore()</code> мы получаем результат очередного броска. Если есть попадание, то возвращается число от <code>1</code> до <code>10</code>, если произошёл промах, то возвращается <code>-1</code>.</p></div>`,html:``,css:``,hidden:``,js:`var score;\n`,tasks:[{message:`Напишем основной цикл программы с помощью <code>keks.getScore()</code>. Задайте переменной <code class='keyvalue'>score</code> значение из команды <code>keks.getScore()</code>.`,check:()=>~getJ().indexOf('score=keks.getScore()')},{message:`Под переменной добавьте цикл <code><code class='keyword'>while</code> (<code class='keyvalue'>score</code> <code class='keyword'>></code> <code class='keytext'>-1</code>) { }</code>. На этом и следующем шагах может отображаться ошибка «<code class='keyword'>Timeout error</code>». Это нормально`,check:()=>~getJ().search(/score=\S*while\((score>-1|-1<score)\)\{\S*\}/)},{message:`<code class='keytext'>Внутри цикла</code> выведите переменную <code class='keyvalue'>score</code> в <code class='keyword'>консоль</code>.`,check:()=>~getJ().search(/score=\S*while\((score>-1|-1<score)\)\{\S*console\.log\(score\)\S*\}/)},{message:`Там же, после вывода в консоль, ещё раз задайте переменной <code class='keyvalue'>score</code> значение из команды <code>keks.getScore()</code>`,check:()=>~getJ().search(/score=\S*while\((score>-1|-1<score)\)\{\S*console\.log\(score\)\S*score=keks\.getScore\(\)\S*\}/)},],blocked:"4",editorOff:"8"},
"lesson1054":{theory:`<div><h1>Цикл while, суммирование</h1><p>На предыдущем шаге вы написали основной цикл. Самое главное, что этот цикл умеет останавливаться!</p><p>Вспомните условие:</p><pre>while (<b>score &gt; -1</b>) { }\n</pre><p>Чтобы цикл остановился, условие когда-нибудь должно стать ложным. Чтобы это случилось, переменная <code>score</code> должна изменяться внутри цикла. Что мы и обеспечили, когда начали на каждой итерации записывать в переменную результат очередного броска.</p><p>Если условие выхода из цикла не срабатывает, то цикл не может остановиться. Это бесконечный цикл, одна из любимых ошибок программистов. Кстати, цикл <code>for</code> тоже можно сделать бесконечным.</p><p>Часть логики работы программы готова: мы получаем результаты всех бросков и останавливаем игру, когда происходит промах. Осталось посчитать сумму очков.</p><p>Для этого до цикла объявим переменную <code>total</code> и в каждой итерации будем прибавлять к ней очки, полученные за бросок.</p><p>И, напоследок, выведем результат игры в консоль.</p></div>`,html:``,css:``,hidden:``,js:`var score = keks.getScore();\n\nwhile (score > -1) {\n    console.log(score);\n    score = keks.getScore();\n}\n`,tasks:[{message:`На следующей строке после переменной <code class='keyvalue'>score</code> объявите переменную <code class='keyvalue'>total</code>, которая равна <code class='keytext'>0</code>`,check:()=>~getJ().search(/(var|let)score\S*(var|let)total=0/)},{message:`<code class='keytext'>Внутри цикла</code> вместо вывода переменной <code class='keyvalue'>score</code> в консоль, увеличивайте значение <code class='keyvalue'>total</code> на <code class='keyvalue'>score</code> с помощью оператора <code class='keyword'>+=</code>`,check:()=>~getJ().search(/while\(\S*\{\S*total\+=score\S*\}/)},{message:`<code class='keytext'>После цикла</code> выведите значение переменной <code class='keyvalue'>total</code> в <code class='keyword'>консоль</code>.`,check:()=>~getJ().search(/while\(\S*\{\S*total\+=score\S*\}\S*console\.log\(total\)/)}],blocked:"4",editorOff:"8"},
"lesson1055":{theory:`<div><h1>Ещё один проект: дартс-машина</h1><p>Аппетит приходит во время еды. Босс случайно заметил программу, считающую количество набранных очков до первого промаха. Теперь он передаёт вам привет и новую задачу: драйвер для игрового дартс-автомата.</p><p>Правила работы автомата:</p><ul><li>Каждая игра начинается с <code>0</code> очков.</li><li>Чтобы выиграть, нужно набрать <code>100</code> и более очков.</li><li>В процессе игры можно совершить не более трёх промахов, иначе проиграешь.</li></ul><p>В процессе написания программы мы разберём использование цикла <code>while</code>, а также операторов <code>break</code> и <code>continue</code>.</p><p>Иногда программисты создают бесконечные циклы по ошибке, неправильно написав условие выхода. Такие циклы могут «подвесить» окно браузера в котором они исполняются. Но если пользоваться бесконечными циклами осмысленно, они могут принести пользу.</p><p>Мы создадим цикл, внутри которого будет происходить подсчёт очков, используя конструкцию <code>while</code>. Внутри условия выхода нам нужно каждый раз проверять набрал ли игрок необходимое количество очков.</p><p>На первом шаге мы изменим условие так, чтобы игра заканчивалась при достижении ста очков.</p></div>`,html:``,css:``,hidden:``,js:`var score = 0;\nvar total = 0;\n\nwhile (score > -1) {\n    score = keks.getScore();\n    total += score;\n}\n\nconsole.log(total);\n`,tasks:[{message:`Добавим цикл, получим в нём попадания и выведем в консоль. Добавьте переменную <code class='keyvalue'>victoryPoints</code>, которая будет хранить количество очков необходимое для выигрыша — <code class='keytext'>100</code>`,check:()=>~getJ().search(/(var|let)victoryPoints=100/)},{message:`Замените <code class='keytext'>условие выхода</code> из цикла на достижение необходимого количества очков <code class='keyvalue'>total <code class='keyword'><</code> victoryPoints</code>`,check:()=>~getJ().search(/(var|let)victoryPoints=100\S*while\((total<victoryPoints|victoryPoints>total)\)\{\S*\}/)},{message:`В цикле выведите в <code class='keyword'>консоль</code> результат броска из переменной <code class='keyvalue'>score</code>`,check:()=>~getJ().search(/(var|let)victoryPoints=100\S*while\((total<victoryPoints|victoryPoints>total)\)\{\S*console\.log\(score\)\S*\}/)},],blocked:"4",editorOff:"8"},
"lesson1056":{theory:`<div><h1>Дартс-машина: накапливаем промахи</h1><p>Ура! Наша программа работает! Но мы постоянно выигрываем.</p><p>Давайте добавим немного интриги и будем прерывать цикл как только мы промахнулись три раза.</p><p>Для этого нам понадобится переменная, которая будет считать промахи, назовём её <code>misses</code>. Каждый раз когда игрок промахивается мы будем увеличивать эту переменную на единицу.</p><p>Команда <code>keks.getScore()</code> возвращает <code>-1</code>, если игрок промахнулся. Поэтому внутри цикла нужно добавить проверку, что результат текущего броска меньше нуля. И если проверка срабатывает, то пишем в консоль про промах и увеличиваем на единицу счётчик промахов.</p><p>Действия внутри цикла должны будут выглядеть так:</p><ol><li>Получаем результат броска.</li><li>Проверяем, что результат броска меньше нуля. Если это так, то переходим к шагу три, иначе к шагу четыре.</li><li>Пишем в консоль про промах и увеличиваем счётчик промахов на единицу.</li><li>Увеличиваем общий результат <code>total</code> и выводим результат броска в консоль.</li></ol></div>`,html:``,css:``,hidden:``,js:`var score = 0;\nvar total = 0;\nvar victoryPoints = 100;\n\nwhile (total < victoryPoints) {\n    score = keks.getScore();\n\n    total += score;\n    console.log('Результат броска: ' + score);\n}\n\nconsole.log(total);\n`,tasks:[{message:`Добавим реакцию на промахи. Добавьте <code class='keytext'>перед циклом</code> переменную для промахов <code class='keyvalue'>misses</code> с <code class='keytext'>нулевым</code> значением.`,check:()=>~getJ().search(/(var|let)misses=0\S*while/)},{message:`В следующей после <code>keks.getScore()</code> строчке добавьте проверку на промах <code><code class='keyword'>if</code> (score <code class='keyword'><</code> <code class='keytext'>0</code>) { }</code>`,check:()=>~getJ().search(/(var|let)misses=0\S*while\S*\{\S*keks\.getScore\(\)\S*if\((score<0|0>score)\)\{\S*\}\S*\}/)},{message:`Если это условие выполняется, добавьте <code>console.log(<code class='keytext'>'Промах!'</code>)</code>;`,check:()=>~getJ().search(/(var|let)misses=0\S*while\S*\{\S*keks\.getScore\(\)\S*if\((score<0|0>score)\)\{\S*console.log\(('|"|`)Промах!\3\)\S*\}\S*\}/)},{message:`и увеличение переменной <code class='keyvalue'>misses</code> на <code class='keytext'>единицу</code>.`,check:()=>~getJ().search(/(var|let)misses=0\S*while\S*\{\S*keks\.getScore\(\)\S*if\((score<0|0>score)\)\{\S*misses(\+\+|\+=1|=misses\+1|=1\+misses)\S*\}\S*\}/)},{message:`В ветку <code class='keyword'>else</code> проверки на промах перенесите <code class='keytext'>увеличение суммарного количества очков и вывод результата броска</code> в <code class='keyword'>консоль</code>.`,check:()=>{var j=getJ();return ~j.search(/(var|let)misses=0\S*while\S*\{\S*keks\.getScore\(\)\S*if\(\S*\}else\{\S*total(\+=score|=total\+score|=score\+total)\S*\}\S*\}/)&&~j.search(/(var|let)misses=0\S*while\S*\{\S*keks\.getScore\(\)\S*if\(\S*\}else\{\S*console\.log\(('|"|`)Результатброска:\2\+score\)\S*\}\S*\}/)}}],blocked:"4",editorOff:"8"},
"lesson1057":{theory:`<div><h1>Дартс-машина: поражение</h1><p>Пора вырваться из этой бесконечной серии побед!</p><p>Программа уже умеет накапливать промахи в переменной <code>misses</code>. Осталось научить её завершать цикл по достижении трёх промахов. Но в каком месте цикла проверять это условие? В начале, середине или конце?</p><p>Вот текущий порядок команд в цикле:</p><ol><li>Получаем результат броска.</li><li>Проверяем, что результат броска меньше нуля. Если это так, то переходим к шагу три, иначе к шагу четыре.</li><li>Пишем в консоль про промах и увеличиваем счётчик промахов на единицу.</li><li>Увеличиваем общий результат <code>total</code> и выводим результат броска в консоль.</li></ol><p>Нам нужно, чтобы:</p><ul><li>Проверка на общее количество промахов гарантированно выполнялась на каждом витке цикла.</li><li>По достижении трёх промахов игра бы <em>сразу</em> завершалась.</li></ul><p>Поэтому проверку на общее количество промахов надо делать в самом начале цикла, ещё до выполнения броска и получения его результата.</p><p>Нам нужна команда, которая будет прерывать выполнение цикла.</p><p>Такой командой в JavaScript является оператор <code>break</code>. Добавим в начало цикла проверку количества промахов и как только промахов станет три — выходим из цикла.</p><p>Аналогично оператору прерывания цикла <code>break</code> существует оператор для быстрого перехода к следующей итерации цикла <code>continue</code>, но используют его крайне редко, так как он усложняет чтение кода и понимание работы цикла в целом. Использование <code>continue</code> без необходимости обычно является дурным тоном.</p><ul><li>Внутри <code>while</code> команда <code>continue</code> «перематывает» программу сразу к началу <em>следующей</em> итерации.</li><li>Внутри <code>for</code> команда <code>continue</code> «перематывает» программу к дополнительной части <em>текущей</em> итерации, после выполнения которой начинается <em>следующая</em> итерация цикла.</li></ul></div>`,html:``,css:``,hidden:``,js:`var score = 0;\nvar total = 0;\nvar victoryPoints = 100;\nvar misses = 0;\n\nwhile (total < victoryPoints) {\n    score = keks.getScore();\n\n    if (score < 0) {\n        console.log('Промах!');\n        misses++;\n    } else {\n        total += score;\n        console.log('Результат броска: ' + score);\n    }\n}\n\nconsole.log(total);\n`,tasks:[{message:`Сделаем, чтобы цикл заканчивался, если количество промахов достигло трёх. Добавьте в начало тела цикла условие <code><code class='keyword'>if</code> (misses <code class='keytext'>>=</code> <code class='keytext'>3</code>) { }</code>`,check:()=>~getJ().search(/while\(\S*\{\S*if\((misses>=3|3<=misses)\)\{\S*\}\S*\}/)},{message:"Внутрь этого условия добавьте оператор <code class='keyword'>break</code>",check:()=>~getJ().search(/while\(\S*\{\S*if\((misses>=3|3<=misses)\)\{\S*break\S*\}\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1058":{theory:`<div><h1>Дартс-машина: итоговое табло</h1><p>Подсчёты очков и промахов завершены. Самое время вывести результаты.</p><p>Выведем в консоль результат игры: победа или поражение. Также отобразим статистику, включающую количество набранных очков и количество промахов.</p><p>Как определить победу или поражение? Если после цикла количество очков больше или равно ста, то это победа. Иначе это поражение.</p><p>Вот и всё, программа готова!</p><p>И помните: даже бесконечный цикл всегда должен заканчиваться!</p></div>`,html:``,css:``,hidden:``,js:`var score = 0;\nvar total = 0;\nvar victoryPoints = 100;\nvar misses = 0;\n\nwhile (total < victoryPoints) {\n    if (misses >= 3) {\n        break;\n    }\n\n    score = keks.getScore();\n\n    if (score < 0) {\n        console.log('Промах!');\n        misses++;\n    } else {\n        total += score;\n        console.log('Результат броска: ' + score);\n    }\n}\n\nconsole.log(total);\n`,tasks:[{message:`Выведем результаты в консоль. Вместо <code>console.log(<code class='keytext'>total</code>)</code>; выведите результаты игры следующим образом: <code class='keytext'>После цикла</code> добавьте проверку условия <code class='keyvalue'>total <code class='keyword'>>=</code> victoryPoints</code>`,check:()=>~getJ().search(/if\((total>=victoryPoints|victoryPoints<=total)\)\{\S*\}/)},{message:"Если условие выполняется, выведите в <code class='keyword'>консоль</code> сообщение о победе: <code>console.log(<code class='keytext'>'Победа! Очков: '</code> <code class='keyword'>+</code> total <code class='keyword'>+</code> <code class='keytext'>', промахов: '</code> <code class='keyword'>+</code> misses)</code>",check:()=>~getJ().search(/if\((total>=victoryPoints|victoryPoints<=total)\)\{\S*console\.log\(('|"|`)Победа!Очков:\2\+total\+('|"|`),промахов:\3\+misses\)\S*\}/)},{message:"Иначе выведите в <code class='keyword'>консоль</code> сообщение о поражении: <code>console.log(<code class='keytext'>'Проигрыш. Очков: '</code> <code class='keyword'>+</code> total <code class='keyword'>+</code> <code class='keytext'>', промахов: '</code> <code class='keyword'>+</code> misses)</code>",check:()=>~getJ().search(/if\((total>=victoryPoints|victoryPoints<=total)\)\{\S*\}else\{\S*console\.log\(('|"|`)Проигрыш.Очков:\2\+total\+('|"|`),промахов:\3\+misses\)\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1059":{theory:`<section><h1>Конспект «Циклы». Часть 2</h1><h2>Цикл while</h2><h3>Синтаксис</h3><pre>while (условие) {\n  действия\n}\n</pre><p>Действия будут выполняться снова и снова пока условие не вернёт <code>false</code>.</p><h3>Накопление значений в цикле</h3><pre>var sum = 0;\nvar i = 0;\n\nwhile (i &lt;= 5) {\n  sum += 1;\n  i++;\n  console.log(i);\n}\n</pre><p>Программа выведет:</p><pre>LOG: 1 (number)\nLOG: 2 (number)\nLOG: 3 (number)\nLOG: 4 (number)\nLOG: 5 (number)\nLOG: 6 (number) // Код из тела цикла не выполнится, условие вернёт false\n</pre><h2>Поиск процента от числа</h2><p>Самый простой способ найти процент от числа — разделить число на 100 и умножить на процент.</p><pre>// Найдём 2 процента от 1000\n1000 / 100 * 2 = 20;\n\n// Найдём 7 процентов от 1200\n1200 / 100 * 7 = 84;\n</pre><br></section>`,html:``,css:``,hidden:``,js:`var number = ~~(11*Math.random());\n\n\/\/ Цикл написать здесь\n\n\nconsole.log(number);`,tasks:[{message:"Создайте цикл <code class='keyword'>while</code>, в котором каждую итерацию переменной <code class='keyvalue'>number</code> присваивается <code class='keytext'>случайное</code> значение от <code class='keytext'>1</code> до <code class='keytext'>10</code> (скопируйте внутрь цикла изначальную функцию вычисления значения</code> переменной <code class='keyvalue'>number</code>). Цикл должен заканчиваться, как только <code class='keyvalue'>number</code> будет равно <code class='keytext'>10</code>. Вывод в <code class='keytext'>консоль</code> после цикла не стирать.",check:(o)=>~o.log.indexOf(10)&&~getJ().search(/varnumber=\S*while\(\S*console\.log\(number\)/)}],blocked:"4",editorOff:"9"},
"lesson1060":{theory:`<div><h1>Четвёртая программа: «Бешеная сушка»</h1><p>Вы готовы написать четвёртую программу, которую босс будет тестировать собственными лапами. Вот техническое задание:</p><blockquote><p>Мяу! Меня утомляют диета и тренировки, поэтому я хочу узнать, сколько ещё дней осталось заниматься, чтобы добиться нужного веса к мероприятию.</p><p>Входные данные: вес в начале диеты и вес в конце.</p><p>Логика работы: пока я тренируюсь и сижу на диете, то теряю 5% своей массы в день (на сухом корме не особо пожируешь, а тренировки суровые). А тренируюсь я до тех пор, пока мой вес больше желаемого.</p><p>Просто посчитай, сколько дней понадобится провести в таком режиме и запиши количество в переменную <code>days</code>.</p></blockquote><p>Конечно, в этой программе удобнее использовать <code>while</code>, так как количество итераций заранее неизвестно.</p><p>Обратите внимание, что Кекс каждый день теряет <code>5%</code> от своего веса. При этом вес обновляется каждый день. Например, если сначала Кекс весил 5кг (то есть 5000 грамм), то на следующий день его вес станет 4750 грамм. И во второй день он уже потеряет 5% от нового веса, то есть от 4750 грамм. Учтите это при расчётах.</p></div>`,html:``,css:``,hidden:``,js:`var initialWeight = 6000; // Исходный вес в граммах\nvar targetWeight = 5000; // Желанный вес в граммах\n\n`,tasks:[{message:`<button onclick="fH1.b()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p><code class='keyword'>Мяу!</code> Меня утомляют диета и тренировки, поэтому я хочу узнать, сколько ещё дней осталось заниматься, чтобы добиться нужного веса к мероприятию.</p><p>Входные данные: вес в начале и вес в конце.</p><p>Логика работы: если я тренируюсь и сижу на диете, то теряю <code class='keytext'>5%</code> своей массы в день (на сухом корме не особо пожируешь, а тренировки суровые).</p><p>Просто посчитай, сколько дней понадобится провести в таком режиме и запиши количество в переменную <code class='keyvalue'>days</code>.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1061":{theory:`<div><h1>Геометрическая прогрессия</h1><p>Геометрическая прогрессия — последовательность чисел, где каждое следующее число — это предыдущее, увеличенное на множитель.</p><p>Например, нужно написать геометрическую прогрессию из пяти чисел, начиная с единицы. Множитель — двойка. Тогда числа будут такими: <code>1, 2, 4, 8, 16</code>. Здесь каждое следующее число — произведение предыдущего числа и множителя (двойки).</p><p>Напиши программу, которая <b>последовательно</b> выводит в консоль числа в геометрической прогрессии.</p><p>Стартовое значение, с которого должна начаться последовательность, записано в переменную <code>startNumber</code>.</p><p>Множитель записан в переменную <code>multiplier</code>.</p><p>Количество чисел записано в переменную <code>quantity</code>.</p></div>`,html:``,css:``,hidden:``,js:`var startNumber = 1;\nvar multiplier = 4;\nvar quantity = 7;\n\n`,tasks:[{message:`<button onclick="fH1.c()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p>Напишите программу, которая последовательно выводит в <code class='keyword'>консоль</code> числа в <code class='keytext'>геометрической прогрессии</code>.</p><p>Стартовое значение, с которого должна начаться последовательность, записано в переменную <code class='keyvalue'>startNumber</code>.</p><p>Множитель записан в переменную <code class='keyvalue'>multiplier</code>.</p><p>Количество чисел записано в переменную <code class='keyvalue'>quantity</code>.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1062":{theory:`<div><h1>Сумма чисел</h1><p>Есть такая детская математическая головоломка, в которой нужно найти самый быстрый способ посчитать сумму чисел от 1 до 100. В наших руках не просто ручка и листочек, а JavaScript и циклы, поэтому мы можем написать универсальную программу, которая сможет находить суммы любых чисел.</p><p>Напишите универсальную программу, которая вычисляет сумму чисел <code>от 1 до n</code>.</p><p>Число, до которого нужно складывать числа (включительно), указано в переменной <code>lastNumber</code>.</p><p>Найдите сумму всех чисел и сохраните результат в переменную <code>sum</code>.</p></div>`,html:``,css:``,hidden:``,js:`var lastNumber = 10;\nvar sum = 0;\n\n`,tasks:[{message:`<button onclick="fH1.d()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p>Напишите универсальную программу, которая вычисляет сумму чисел от <code class='keytext'>1</code> до <code class='keytext'>n</code>.</p><p>Число, до которого нужно складывать числа (включительно), указано в переменной <code class='keyvalue'>lastNumber</code>.</p><p>Найдите сумму всех чисел и сохраните результат в переменную <code class='keyvalue'>sum</code>.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1063":{theory:`<div><h1>Произведение чётных</h1><p>Кроме суммы чисел <code>от 1 до n</code> можно ещё найти их произведение. Но в этот раз задача усложнилась — нужно найти произведение не всех чисел из последовательности, а только чётных.</p><p>Напишите универсальную программу, которая находит произведение всех <b>чётных чисел</b> из последовательности <code>от 1 до n</code>.</p><p>Число, до которого идёт последовательность (включительно), записано в переменную <code>lastNumber</code></p><p>Найдите произведение всех чисел и сохраните результат в переменную <code>multiplicationResult</code>.</p></div>`,html:``,css:``,hidden:``,js:`var lastNumber = 5;\nvar multiplicationResult = 1;\n\n`,tasks:[{message:`<button onclick="fH1.e()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p>Напишите универсальную программу, которая находит произведение всех <code class='keytext'>чётных</code> чисел из последовательности от <code class='keytext'>1</code> до <code class='keytext'>n</code>.</p><p>Число, до которого идёт последовательность (включительно), записано в переменную <code class='keyvalue'>lastNumber</code>.</p><p>Найдите произведение всех чисел и сохраните результат в переменную <code class='keyvalue'>multiplicationResult</code>.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1064":{theory:`<div><h1>Делители</h1><p>Напишите программу, которая находит все делители числа, <b>кроме единицы и самого числа</b>.</p><p>Число, делители которого нужно найти, записано в переменную <code>number</code>.</p><p>Выводите делители в консоль последовательно, друг за другом.</p><p>Делитель — число, на которое другое число делится <b>без остатка</b>. Например, у числа <code>119</code> четыре делителя, на которые это число делится без остатка: <code>1, 7, 17, 119</code>. Для нашей задачи единица и само число не подходят. Поэтому в результате остаётся два числа: <code>7, 17</code>.</p><p>Чтобы узнать есть ли остаток от деления двух чисел, нужно использовать оператор «остаток от деления». Он обозначается знаком процента (<code>%</code>) и возвращает остаток от деления чисел. Если остатка от деления нет, вернётся <code>0</code>. Выглядит это так:</p><pre>12 % 5;  // Вернёт 2\n27 % 3;  // Вернёт 0\n13 % 3;  // Вернёт 1\n</pre></div>`,html:``,css:``,hidden:``,js:`var number = 15;\n\n`,tasks:[{message:`<button onclick="fH1.f()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p>Напишите программу, которая находит все делители числа, кроме единицы и самого числа.</p><p>Число, делители которого нужно найти, записано в переменную <code class='keyvalue'>number</code>.</p><p>Выводите делители в консоль последовательно, друг за другом.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1065":{theory:`<div><h1>Сколько цифр?</h1><p>Кексу так нравится автоматизация, что Босс пытается передать программам максимум задач, даже самых бытовых и с виду простых. Например, сейчас Кекс хочет, чтобы вы написали программу, которая умеет определять количество цифр в любом <b>целом</b> числе.</p><blockquote><p>Мяу! Напишу программу, которая определяет сколько цифр в одном <b>целом</b> числе.</p><p>Само число записано в переменную <code>number</code>.</p><p>Найди количество цифр в этом числе и запиши результат в переменную <code>quantity</code>.</p></blockquote><p>Попробуйте решить эту задачу самостоятельно. Но если у вас возникли сложности с решением, загляните в подсказку ниже.</p><p>Чтобы решить эту задачу, можно пойти разными путями. Например, математическим: делить число на 10 и округлять его на каждой итерации.</p></div>`,html:``,css:``,hidden:``,js:`var number = 123;\nvar quantity = 0;\n\n`,tasks:[{message:`<button onclick="fH1.g()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p>Напишу программу, которая определяет сколько цифр в одном числе.</p><p>Само число записано в переменную <code class='keyvalue'>number</code>.</p><p>Найди количество цифр в этом числе и запиши результат в переменную <code class='keyvalue'>quantity</code>.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1066":{theory:`<div><h1>Запасы протеина</h1><p>Пришло время для собственной программы, которая поможет Кексу правильно запастись протеином на любой период, например, на 15 или на 25 дней.</p><p>Программа усложняется тем, что Кекс принимает протеин не каждый день, а раз в три дня, да ещё и разное количество в будние дни и в выходные. Впрочем, вот техническое задание, написанное его лапой:</p><blockquote><p>Мяу! Программа должна считать количество протеина необходимое на период.</p><p>Во-первых, расчёт всегда начинается с понедельника. Это первый день.</p><p>Во-вторых, я принимаю протеин каждый третий день:<br> 1 день, понедельник — нет,<br> 2 день, вторник — нет,<br> 3 день, среда — да,<br> 4 день, четверг — нет,<br> 5 день, пятница — нет,<br> 6 день, суббота — да,<br> 7 день, воскресенье — нет,<br> 8 день, понедельник — нет,<br> 9 день, вторник — да<br> и так далее.</p><p>В-третьих, известно, сколько протеина я съедаю в будние и сколько в выходные дни.</p><p>В-четвёртых, период задаётся целым числом, от одного до бесконечности (хотя планы дальше чем на месяц я обычно не строю).</p><p>Программа должна возвращать общее количество протеина за период, записанное в переменную total.</p></blockquote><p>Количество дней хранится в переменной <code>days</code>, количество протеина для буднего дня — в переменной <code>workDayAmount</code>, для выходного — в переменной <code>weekendAmount</code>, период получения протеина — в переменной <code>period</code>, а результат необходимо записать в переменную <code>total</code>.</p><p>Конечно, в этой программе будет удобно использовать цикл, в котором будет накапливаться количество протеина.</p><p>В этом цикле будут две сложные проверки: как определить n-ый по счёту день и как отделить выходные от будних. Если будет сложно разобраться, откройте блок с подсказками, расположенный ниже.</p><p>Чтобы найти каждый n-ый день, можно воспользоваться оператором <code>%</code>, который находит остаток от деления. Если номер текущего дня делится нацело на заданный период, то этот оператор вернёт ноль, иначе он вернёт число больше нуля. Например, если заданный период равен <b>3</b>, а сейчас пятый день периода, то <code>5 % 3 === 2</code>, а если шестой день периода, то <code>6 % 3 === 0</code>.</p><p>Для определения дня недели тоже поможет <code>%</code>: номер дня <em>в периоде</em> делим на <code>7</code>, в остатке получаем номер дня <em>в неделе</em>. Для воскресенья остаток будет равен <code>0</code>. Например, поделим <code>15</code> по счёту день в периоде на <code>7</code>, в остатке получится <code>1</code>. Значит это понедельник.</p></div>`,html:``,css:``,hidden:``,js:`var days = 9; // Дней в периоде\nvar period = 3; // Как часто я ем протеин (раз в три дня)\nvar workDayAmount = 200; // Количество протеина в будние\nvar weekendAmount = 100; // Количество протеина в выходные\n\nvar total = 0;`,tasks:[{message:`<button onclick="fH1.h()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p><code class='keyword'>Мяу!</code> Программа должна считать количество протеина необходимое на период.</p><ol><li>Во-первых, расчёт всегда начинается с понедельника. Это первый день.</li><li><pre>Во-вторых, я принимаю протеин каждый третий день:\n1 день, понедельник – нет,\n2 день, вторник – нет,\n3 день, среда – да,\n4 день, четверг – нет,\n5 день, пятница – нет,\n6 день, суббота – да,\n7 день, воскресенье – нет,\n8 день, понедельник – нет,\n9 день, вторник – да\nи так далее.</pre></li><li>В-третьих, известно, сколько протеина я съедаю в будние и сколько в выходные дни.</li><li>В-четвёртых, период задаётся <code class='keytext'>целым числом</code>, от одного до бесконечности (хотя планы дальше чем на месяц я обычно не строю).</li></ol><p>Программа должна возвращать общее количество протеина за период, записанное в переменную <code class='keyvalue'>total</code>.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1067":{theory:`<div><h1>Сортировка выбором</h1><p><a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8" target="_blank">Алгоритмы сортировки</a> встречаются в программировании очень часто. Обычно разработчики используют встроенные в язык методы для разных видов сортировок, но сейчас вы попробуете написать один из алгоритмов самостоятельно. Важно понимать, как устроен и как быстро работает тот или иной способ сортировки, чтобы знать, в каких случаях его применить.</p><blockquote><p>Мяу! Напиши <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%BE%D0%BC" target="_blank"><b>сортировку массива выбором</b></a>.</p><p>Массив записан в переменную <code>numbers</code>.</p><p>Отсортируй значения в массиве по возрастанию, от самого маленького значения к наибольшему.</p></blockquote><p>Алгоритм этой сортировки устроен так:</p><ul><li><p>В массиве находится самый маленький элемент. Он меняется местами с нулевым элементом массива. Таким образом самый маленький элемент стоит в начале.</p></li><li><p>Затем мы исключаем из выборки нулевой элемент, ведь он уже найден. Среди элементов с первого (с индексом 1) по последний ищется самый маленький элемент. Когда он найден, он меняется местами с первым элементом. В итоге два самых маленьких значения в массиве стоят в начале.</p></li><li><p>Затем поиск наименьшего значения продолжается среди элементов с третьего (с индексом 2) по последний. И так до тех пор, пока массив не будет отсортирован по возрастанию значений.</p></li></ul></div>`,html:``,css:``,hidden:``,js:`var numbers = [3, 5, 15, 6, 2, 1];\n\n`,tasks:[{message:`<button onclick="fH1.i()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p>Напиши сортировку массива выбором.</p><p>Массив записан в переменную <code class='keyvalue'>numbers</code>.</p><p>Отсортируй значения в массиве <code class='keytext'>по возрастанию</code>, от самого маленького значения к наибольшему.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1068":{theory:`<div><h1>Палиндром</h1><p>Палиндромы — это слова или фразы, которые одинаково читаются слева направо и справа налево. Среди чисел тоже есть палиндромы. Например, <code>3223</code> или <code>1001</code>.</p><p>В этом задании вам нужно написать программу, которая будет определять является ли число палиндромом.</p><p>Алгоритм такой: нужно записать изначальное число задом наперёд и сравнить этот вариант с изначальным. Если оба числа равны — перед нами палиндром.</p><blockquote><p>Мяу! Напиши программу, которая проверяет, является ли число палиндромом.</p><p>Число записано в переменную <code>poly</code>.</p><p>Переменная, куда нужно записать «перевёрнутую» версию числа, называется <code>ylop</code>.</p><p>Выясни, является ли число из переменной <code>poly</code> палиндромом. Если да, значение флага <code>isPalindrome</code> должно быть <code>true</code>, если число не палиндром, то <code>false</code>.</p></blockquote><p>Если у вас возникли сложности с решением этой задачи, загляните в подсказку.</p><p>Один из способов решения этой задачи такой: на каждой итерации нужно брать остаток от деления числа <code>number</code> на <code>10</code> и собирать новое число. Разберём на примере. Проверим является ли число 505 палиндромом.</p><pre>// 1.Берём остаток от деления 505 на 10\n505 % 10 = 5;\n\n// 2.Уменьшаем изначальное число\n505 / 10 = 50;\n\n// 3.Начинаем собирать число 505 задом наперёд\n// 5 — остаток от деления\n// 50 — результат деления 505 на 10\n<mark>5</mark> * 10 + <mark>50</mark> % 10 = 50;\n\n// 4.Снова уменьшаем изначальное число\n50 / 10 = 5;\n\n// 5.Продолжаем собирать число\n// 50 — результат третьей операции\n// 5 — результат деления 50 на 10\n<mark>50</mark> * 10 + <mark>5</mark> % 10 = 505;\n\n// Получилось то же самое число\n// 505 — палиндром\n505 === 505\n</pre></div>`,html:``,css:``,hidden:``,js:`var poly = 1221;\nvar ylop = 0;\nvar isPalindrome = false;\n\n`,tasks:[{message:`<button onclick="fH1.j()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p><code class='keyword'>Мяу!</code> Напиши программу, которая проверяет, является ли число палиндромом.</p><p>Число записано в переменную <code class='keyvalue'>poly</code>.</p><p>Переменная, куда нужно записать «перевёрнутую» версию числа, называется <code class='keyvalue'>ylop</code>.</p><p>Выясни, является ли число из переменной <code class='keyvalue'>poly</code> палиндромом. Если да, значение флага <code class='keyvalue'>isPalindrome</code> должно быть <code class='keyword'>true</code>, если число не палиндром, то <code class='keyword'>false</code>.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"}};
hL();