keks={throwDice:(c,e)=>{var f=0;for(var i=0;i<c;i++){var t=Math.ceil(Math.random()*e/c);f+=t;};return f}};
fH1=()=>{var f=Academy.vars.getStatistics;var p=Academy.vars.log;if(typeof f!=="function"){p.push("error: getStatistics не функция!");printLog("Проверка задания");getR(false);return;};var l=[[{name:'Кексик',goals:7,passes:5},{name:'Хрюшка',goals:8,passes:11},{name:'Дымок',goals:4,passes:21},{name:'Снежочек',goals:8,passes:15},{name:'Рыжики',goals:17,passes:2}],[{name:'JS-программист',goals:8,passes:4},{name:'Верстальщик (HTML/CSS)',goals:3,passes:9},{name:'С#-программист',goals:6,passes:1},{name:'Python-программист',goals:9,passes:7}],[{name:'Криштиану Роналду',goals:12,passes:7},{name:'Неймар',goals:21,passes:6},{name:'Лионель Месси',goals:8,passes:12},{name:'Андрей Аршавин',goals:1,passes:2},{name:'Кристиан Мбампе',goals:11,passes:5},{name:'Чиро Иммобиле',goals:12,passes:7},{name:'Гарри Кейн',goals:9,passes:6}]];var r=[[{q:19,n:16},{q:27,n:18},{q:29,n:9},{q:31,n:18},{q:36,n:39}],[{q:20,n:31},{q:15,n:12},{q:13,n:23},{q:25,n:35}],[{q:31,n:16},{q:48,n:28},{q:28,n:11},{q:4,n:1},{q:27,n:15},{q:31,n:16},{q:24,n:12}]];for(var i=0;i<l.length;i++){var c= f(l[i]);p.push("Тест "+(i+1)+". Объект:");console.log(l[i]);if(!c){p.push("error: функция getStatistics ничего не вернула");printLog("Проверка задания");getR(false);return;};if(!Array.isArray(c)){p.push("error: функция getStatistics вернула не массив");printLog("Проверка задания");getR(false);return;};if(l[i].length!==c.length){p.push("error: длина возвращённого массива не совпадает с изначальной");printLog("Проверка задания");getR(false);return;};for(var j=0;j<l[i].length;j++){p.push(c[j].name + ":");p.push("Коэффициент полезности (ожидаемый/полученый) - "+r[i][j].q+" / "+c[j].coefficient);if(c[j].coefficient!==r[i][j].q){p.push("error: коэффициент полезности игрока не совпадает с ожидаемым!");printLog("Проверка задания");getR(false);return;};p.push("Процент голов (ожидаемый/полученый) - "+r[i][j].n+" / "+c[j].percent);if(c[j].percent!==r[i][j].n){p.push("error: процент голов игрока не совпадает с ожидаемым!");printLog("Проверка задания");getR(false);return;}}};p.push("Все тесты пройдены!");printLog("Проверка задания");getR(true);};
fH2=()=>{var p=Academy.vars.log;if(Academy.vars.house){try{var h=Academy.vars.house;var m={"wood":"деревянный","stone":"каменный","brick":"кирпичный"};var materialPrice=Academy.vars.materialPrice;h.rooms=10;h.floors=5;h.material='wood';h.coefficient=10.5;p.push("Наш дом: "+h.rooms+" комнат, "+h.floors+" этажей, "+m[h.material]+", "+"ср.площадь комнаты: "+h.coefficient);p.push("Площадь (ожидаемая/полученая): 525/"+h.calculateSquare());if(h.calculateSquare()!=525){p.push('error: площадь, полученная функцией house.calculateSquare не совпадает с ожидаемой!');printLog("Проверка задания");getR(false);return;};p.push("Цена строительства (ожидаемая/полученая): "+525*materialPrice["wood"]+"/"+h.calculatePrice());if(h.calculatePrice()!=525*materialPrice["wood"]){p.push('error: цена, полученная функцией house.calculatePrice не совпадает с ожидаемой!');printLog("Проверка задания");getR(false);return;};h.rooms=5;h.floors=2;h.material='brick';h.coefficient = 15;p.push("Ещё один дом: "+h.rooms+" комнат, "+h.floors+" этажа, "+m[h.material]+", "+"ср.площадь комнаты: "+h.coefficient);p.push("Площадь (ожидаемая/полученая): 150/"+h.calculateSquare());if(h.calculateSquare()!=150){p.push('error: площадь, полученная функцией house.calculateSquare не совпадает с ожидаемой!');printLog("Проверка задания");getR(false);return;};p.push("Цена строительства (ожидаемая/полученая): "+150*materialPrice["brick"]+"/"+h.calculatePrice());if(h.calculatePrice()!=150.0*materialPrice["brick"]){p.push('error: цена, полученная функцией house.calculatePrice не совпадает с ожидаемой!');printLog("Проверка задания");getR(false);return;};p.push("Все показатели совпадают!");printLog("Проверка задания");getR(true);return;}catch(e){p.push(e);printLog("Проверка задания");getR(false);return;}};p.push('error: у переменной house нет значения');printLog("Проверка задания");getR(false);return;};
tj1=`var gameRules = {\n    diceNumber: 2,\n    maxAttempts: 3\n};\n\nvar firstCat = {\n    name: 'Кекс',\n    points: 0\n};\n\nvar secondCat = {\n    name: 'Рудольф',\n    points: 0\n};\n\nvar cats = [firstCat, secondCat];\n\nvar runGame = function (rules, players) {\n    for (var currentAttempt = 1; currentAttempt <= rules.maxAttempts; currentAttempt++) {\n        for (var i = 0; i < players.length; i++) {\n            var throwResult = keks.throwDice(rules.diceNumber, rules.diceNumber * 6);\n            players[i].points += throwResult;\n            console.log(players[i].name + ' выбросил ' + players[i].points);\n        }\n    }\n    return players;\n};\n`

LessonsData = {
"lesson1136":{theory:`<div><h1>Сыграем?</h1><p>У вас выдалось немного свободного времени между бесконечными поручениями Босса. Почему бы не написать что-то для себя, например, игру в кости?</p><p>Принцип такой — игроки по очереди бросают две игральные кости. Результат броска — очки участника. Побеждает тот, кто набрал большее количество очков. Для интриги у каждого игрока будет три попытки.</p><p>Будем писать программу постепенно и начнём с того, что создадим функцию <code>runGame</code>, где в будущем будет запускаться игра (броски костей и накопление очков).</p><p>Для броска игральных костей воспользуемся функцией <code>keks.throwDice(min, max)</code>, которая генерирует случайные числа в заданном промежутке, включая минимальное и максимальное значение. Эта функция существует только в курсе, в самом JavaScript такой функции нет, но есть другие, которые делают похожие действия. О них мы поговорим позже, в других курсах. А пока будем использовать <code>keks.throwDice(min, max)</code>. Какие значения будут минимальными и максимальными?</p><p>Если бросать одну кость, то можно выбросить число от <code>1</code> до <code>6</code>, ведь у кости шесть граней. А если бросать две кости, то получится число от <code>2</code> до <code>12</code>.</p><p>Ясно, передаём в функцию аргументы <code>2</code> и <code>12</code>? Нет, сделаем лучше! Привяжем аргументы к количеству костей: если кость одна, то значения аргументов будут одни, если кости три, то другие.</p><p>Худший результат в игре получается, когда на всех костях выпала единица, а лучший, если выпали все шестёрки. Получается, что минимальное значение равно количеству костей, а максимальное — <code>6 * количество костей</code>.</p><p>Осталось объявить переменную, которая будет хранить количество костей и использовать её для вычисления аргументов функции <code>runGame</code>.</p><p>Бросим кости и убедимся, что функция работает.</p><p>Let the game begin!</p></div>`,html:``,css:``,hidden:``,js:``,tasks:[{message:"Объявите переменную <code class='keyvalue'>diceNumber</code> со значением <code class='keyword'>2</code>.",check:(o)=>o&&o.diceNumber===2},{message:"Создайте функцию <code>runGame</code> с параметром <code class='keytext'>quantity</code>.",check:()=>~getJ().search(/(runGame=function|functionrunGame)\(quantity\)\{\S*\}/)},{message:"В теле функции выведите в <code class='keyword'>консоль</code> результат одного броска <code>keks.throwDice(<code class='keytext'>quantity, quantity * 6</code>)</code>.",check:()=>~getJ().search(/(runGame=function|functionrunGame)\(quantity\)\{\S*console\.log\(keks\.throwDice\(quantity,quantity\*6\)\)\S*\}/)},{message:"Вызовите функцию <code>runGame</code> с аргументом <code class='keytext'>diceNumber</code>.",check:()=>~getJ().search(/(runGame=function|functionrunGame)\(quantity\)\{\S*\}\S*runGame\(diceNumber\)/)}],blocked:"4",editorOff:"8"},
"lesson1137":{theory:`<div><h1>Игроки, в студию!</h1><p>Теперь, когда мы убедились, что бросок костей работает, надо ввести игроков, которые будут бросать эти самые кости и получать игровые очки в результате броска.</p><p>Пусть игроками будут Кекс и его приятель Рудольф. Добавим переменные для хранения очков и имени каждого игрока, чтобы в дальнейшем определять и выводить результаты победителя в консоль. Получается, для каждого игрока будут созданы две переменных: имя и очки.</p><p>А так как у нас есть функция, внутри которой будут начисляться и выводиться в консоль игровые очки, переменные с именами и очками игроков должны передаваться в эту функцию. Да, у функции <code>runGame</code> теперь будет пять параметров, но что поделать? Такова игра.</p><p>Кстати, обратите внимание, что названия переменных и параметров функции не совпадают. Переменная, хранящая количество костей, называется <code>diceNumber</code>, а имя соответствующего параметра <code>quantity</code>. Дело в том, что функция <code>runGame</code> абстрактная. Мы учитываем, что игра может измениться. Например, коты захотят играть в карты или игроками станут люди. Именно поэтому и параметры, которые хранят данные игроков мы назовём абстрактно — <code>firstPlayerName</code>, <code>firstPlayerPoints</code>, <code>secondPlayerName</code>, <code>secondPlayerPoints</code>.</p></div>`,html:``,css:``,hidden:``,js:`var diceNumber = 2;\n\nvar runGame = function (quantity) {\n    console.log(keks.throwDice(quantity, quantity * 6));\n};\n\nrunGame(diceNumber);\n`,tasks:[{message:`После <code class='keyvalue'>diceNumber</code> и перед функцией <code>runGame</code> объявите переменные: <code class='keyvalue'>firstCatName</code> с именем первого игрока <code class='keytext'>'Кекс'</code>.`,check:(o)=>o&&o.firstCatName==='Кекс'},{message:"<code class='keyvalue'>firstCatPoints</code> со значением <code class='keytext'>0</code>.",check:(o)=>o&&o.firstCatPoints===0},{message:"<code class='keyvalue'>secondCatName</code>, которая содержит имя второго игрока <code class='keytext'>'Рудольф'</code>.",check: (o)=>o&&o.secondCatName==='Рудольф'},{message:"<code class='keyvalue'>secondCatPoints</code> со значением <code class='keytext'>0</code>.",check:(o)=>o&&o.secondCatPoints===0},{message:`В функцию <code>runGame</code>, после параметра <code class='keytext'>quantity</code>, добавьте параметры <code class='keytext'>firstPlayerName</code>, <code class='keytext'>firstPlayerPoints</code>, <code class='keytext'>secondPlayerName</code>, <code class='keytext'>secondPlayerPoints</code> и передайте новые переменные в эту функцию после аргумента <code class='keytext'>diceNumber</code>.`,check:(o)=>~getF(o.runGame).search(/function\(quantity,firstPlayerName,firstPlayerPoints,secondPlayerName,secondPlayerPoints\)\{\S*\}/)&&~getJ().search(/runGame\(diceNumber,firstCatName,firstCatPoints,secondCatName,secondCatPoints\)/)}],blocked:"4",editorOff:"8"},
"lesson1138":{theory:`<div><h1>Моя попытка номер раз</h1><p>У нас есть два игрока, готовых бросать кости. Дадим им возможность совершить первый бросок!</p><p>Мы уже передали переменные <code>firstCatName</code>, <code>firstCatPoints</code>, <code>secondCatName</code>, <code>secondCatPoints</code> в функцию <code>runGame</code>. Используем их, чтобы увеличивать игровые очки котов на результат броска и выводить новое значение в консоль, указывая, какому именно игроку принадлежит результат.</p><p>Увеличивать игровые очки будем с помощью оператора сокращённого сложения <code>+=</code>, он знаком вам ещё с курса по циклам.</p></div>`,html:``,css:``,hidden:``,js:`var diceNumber = 2;\n\nvar firstCatName = 'Кекс';\nvar firstCatPoints = 0;\n\nvar secondCatName = 'Рудольф';\nvar secondCatPoints = 0;\n\nvar runGame = function (quantity, firstPlayerName, firstPlayerPoints, secondPlayerName, secondPlayerPoints) {\n    console.log(keks.throwDice(quantity, quantity * 6));\n};\n\nrunGame(diceNumber, firstCatName, firstCatPoints, secondCatName, secondCatPoints);\n`,tasks:[{message:`Внутри <code>runGame</code> замените <code class'keytext'>вывод броска в консоль</code> на увеличение очков первого игрока <code class='keyvalue'>firstPlayerPoints</code> <code class='keyword'>+=</code> <code>keks.throwDice(<code class='keytext'>quantity, quantity * 6</code>)</code>;.`,check:(o)=>{var f=getF(o.runGame);return ~f.search(/firstPlayerPoints\+=keks\.throwDice\(quantity,(quantity\*6|6\*quantity)\)/)&&!~f.search(/console\.log\(keks\.throwDice/)}},{message:"По аналогии увеличьте очки второго игрока <code class='keyvalue'>secondPlayerPoints</code>.",check:(o)=>~getF(o.runGame).search(/secondPlayerPoints\+=keks\.throwDice\(quantity,(quantity\*6|6\*quantity)\)/)},{message:"Выведите в <code class='keyword'>консоль</code> очки первого игрока <code class='keyvalue'>firstPlayerName</code> <code class='keytext'>+ ' выбросил ' +</code> <code class='keyvalue'>firstPlayerPoints</code>.",check:(o)=>~getF(o.runGame).search(/firstPlayerPoints\+=\S*console\.log\(firstPlayerName\+('|"|`)выбросил\1\+firstPlayerPoints\)/)},{message:"По аналогии добавьте <code class='keytext'>вывод</code> для </code class='keytext'>очков второго игрока</code>.",check:(o)=>~getF(o.runGame).search(/secondPlayerPoints\+=\S*console\.log\(secondPlayerName\+('|"|`)выбросил\1\+secondPlayerPoints\)/)}],blocked:"4",editorOff:"8"},
"lesson1139":{theory:`<div><h1>Привет, объект!</h1><p>Каждый игрок бросает кости и получает игровые очки, всё работает, но обратите внимание на количество параметров в функции <code>runGame</code>. Что будет, если игроков станет три, четыре, пять, десять? А если характеристик каждого игрока станет больше? Ответ очевиден: функция с сорока двумя параметрами. Но этим путём мы не пойдём.</p><p>У каждого кота есть набор показателей: имя и очки. Есть ли более удобный способ хранения значений, относящихся к одной сущности? Есть, это <b>объекты</b>.</p><p>Объект — тип данных, который хранит в себе информацию в виде пар «ключ-значение». Если массив — нумерованный список, где каждый элемент имеет свой порядковый номер, то объект — список, в котором каждый элемент сопоставлен со своим ключом и порядок совсем неважен. Рассмотрим объекты на примере. Опишем объект кота.</p><p><b>Создаём объект.</b> В первую очередь объект надо создать. Для этого используют уже знакомые вам фигурные скобки <code>{ }</code>. Дадим объекту имя, оно задаётся точно так же, как и имя любой переменной.</p><pre><mark>var cat = {};</mark>\n// Так создаётся объект с именем cat\n</pre><p><b>Добавляем свойства.</b> Пары «ключ-значение», которые содержит в себе объект, называются свойствами или атрибутами. Выглядят они так:</p><pre>var cat = {\n  <mark>name: 'Кекс',</mark>\n  // Добавили новое свойство, где name — ключ, 'Кекс' — значение\n  <mark>age: 5</mark>\n  // Новое свойство. Ключ — age, значение — 5\n};\n</pre><p>Свойства называются по имени ключа, то есть можно сказать, что у объекта кота есть свойство для хранения имени, где ключ <code>name</code>, а значение <code>'Кекс'</code> или, что у объекта кота есть свойство <code>name</code> со значением <code>'Кекс'</code>.</p><p>Несколько правил синтаксиса:</p><ul><li>Ключ обособляется от значения двоеточием.</li><li>Пары «ключ-значение» отделяются друг от друга запятыми.</li><li>Значениями могут быть данные любого типа (число, строка, массив и так далее).</li></ul><p>Давайте вместо набора переменных создадим объекты игроков. У каждого игрока будет свойство с именем и игровыми очками.</p></div>`,html:``,css:``,hidden:``,js:`var diceNumber = 2;\n\nvar firstCatName = 'Кекс';\nvar firstCatPoints = 0;\n\nvar secondCatName = 'Рудольф';\nvar secondCatPoints = 0;\n\nvar runGame = function (quantity, firstPlayerName, firstPlayerPoints, secondPlayerName, secondPlayerPoints) {\n    firstPlayerPoints += keks.throwDice(quantity, quantity * 6);\n    secondPlayerPoints += keks.throwDice(quantity, quantity * 6);\n    console.log(firstPlayerName + ' выбросил ' + firstPlayerPoints);\n    console.log(secondPlayerName + ' выбросил ' + secondPlayerPoints);\n};\n\nrunGame(diceNumber, firstCatName, firstCatPoints, secondCatName, secondCatPoints);\n`,tasks:[{message:"До функции <code>runGame</code> добавьте объект первого игрока <code class='keyvalue'>firstCat</code>.",check:(o)=>o&&typeof o.firstCat==='object'&&~getJ().search(/(var|let)firstCat\S*(var|let)runGame/)},{message:"Добавьте объекту <code class='keyvalue'>firstCat</code> свойство с именем игрока: ключ <code class='keytext'>name</code>, значение <code class='keytext'>'Кекс'</code>.",check:(o)=>o&&o.firstCat&&o.firstCat.name==='Кекс'},{message:"После объекта <code class='keyvalue'>firstCat</code> добавьте объект <code class='keyvalue'>secondCat</code> с именем <code class='keytext'>'Рудольф'</code>.",check:(o)=>o&&o.secondCat&&o.secondCat.name==='Рудольф'&&~getJ().search(/firstCat=\S*secondCat=/)},{message:"Добавьте каждому объекту свойство для хранения очков: ключ <code class='keytext'>points</code>, значение <code class='keytext'>0</code>.",check:(o)=>o&&o.firstCat&&o.secondCat&&o.firstCat.points===0&&o.secondCat.points===0}],blocked:"4",editorOff:"8"},
"lesson1140":{theory:`<div><h1>Читаем из объекта</h1><p>Мы создали объекты игроков, а что с ними делать дальше? Конечно, их надо передать в функцию <code>runGame</code> вместо переменных, которые содержали имена и очки. Но как их использовать внутри функции?</p><p>К свойствам объекта можно обращаться и получать их значения. Для доступа к отдельному свойству есть два способа, один мы рассмотрим прямо сейчас, а со вторым познакомимся чуть позже.</p><p>Чтобы получить значение свойства, к нему надо обратиться через точку <code>объект.ключ</code>. Такая запись называется <i>точечной нотацией</i> и возвращает значение свойства объекта, если такое свойство есть. В противном случае вы получите <code>undefined</code>, то есть ничего. На практике это выглядит так:</p><pre>var cat = {\n  name: 'Кекс',\n  age: 5\n};\nconsole.log(<mark>cat.name</mark>); // Выведет в консоль 'Кекс'\nconsole.log(<mark>cat.age</mark>); // Выведет в консоль 5\nconsole.log(<mark>cat.color</mark>); // Выведет undefined, такого ключа в объекте нет\n</pre><p>Заменим в параметрах функции <code>runGame</code> переменные на объекты игроков, с учётом этого заменим обращение к параметрам в теле функции.</p></div>`,html:``,css:``,hidden:``,js:`var diceNumber = 2;\n\nvar firstCat = {\n    name: 'Кекс',\n    points: 0\n};\n\nvar secondCat = {\n    name: 'Рудольф',\n    points: 0\n};\n\nvar firstCatName = 'Кекс';\nvar firstCatPoints = 0;\n\nvar secondCatName = 'Рудольф';\nvar secondCatPoints = 0;\n\nvar runGame = function (quantity, firstPlayerName, firstPlayerPoints, secondPlayerName, secondPlayerPoints) {\n    firstPlayerPoints += keks.throwDice(quantity, quantity * 6);\n    secondPlayerPoints += keks.throwDice(quantity, quantity * 6);\n    console.log(firstPlayerName + ' выбросил ' + firstPlayerPoints);\n    console.log(secondPlayerName + ' выбросил ' + secondPlayerPoints);\n};\n\nrunGame(diceNumber, firstCatName, firstCatPoints, secondCatName, secondCatPoints);\n`,tasks:[{message:`Удалите в объявлении функции <code>runGame</code> все параметры, кроме <code class='keytext'>quantity</code>, и добавьте новые параметры: <code class='keytext'>firstPlayer</code> и <code class='keytext'>secondPlayer</code>.`,check:(o)=>~getF(o.runGame).indexOf('function(quantity,firstPlayer,secondPlayer){')},{message:`Удалите в вызове функции <code>runGame</code> все аргументы, кроме <code class='keytext'>diceNumber</code>, и добавьте новые аргументы <code class='keytext'>firstCat</code> и <code class='keytext'>secondCat</code>.`,check:()=>~getJ().indexOf('runGame(diceNumber,firstCat,secondCat)')},{message:`В теле <code class='keytext'>функции</code> замените <code class='keyvalue'>firstPlayerPoints</code> на <code class='keyvalue'>firstPlayer</code><code class='keytext'>.points</code>, <code class='keyvalue'>firstPlayerName</code> на <code class='keyvalue'>firstPlayer</code><code class='keytext'>.name</code>.`,check:(o)=>~getF(o.runGame).search(/firstPlayer\.points\+=keks\.throwDice\S*console\.log\(firstPlayer\.name\+\S*\+firstPlayer\.points\)/)},{message:"По аналогии замените <code class='keytext'>переменные</code> на <code class='keytext'>объекты</code> для <code class='keytext'>второго игрока</code>.",check:(o)=>~getF(o.runGame).search(/secondPlayer\.points\+=keks\.throwDice\S*console\.log\(secondPlayer\.name\+\S*\+secondPlayer\.points\)/)},{message:"Удалите переменные <code class='keyvalue'>firstCatName</code>, <code class='keyvalue'>firstCatPoints</code>,  <code class='keyvalue'>secondCatName</code>, <code class='keyvalue'>secondCatPoints</code>.",check:()=>!~getJ().search(/(firstCatName|firstCatPoints|secondCatName|secondCatPoints)/)}],blocked:"4",editorOff:"8"},
"lesson1141":{theory:`<div><h1>По порядку рассчитайсь!</h1><p>С помощью объектов мы удобно описали игроков и теперь используем эти данные в функции. Параметров стало меньше, но снова возникает вопрос о росте количества участников игры. Что делать, если их станет десять? Создавать ещё объекты? Да! Но есть два минуса:</p><ul><li>Число параметров будет расти вместе с числом игроков.</li><li>Код в теле функции будет раздуваться, ведь для каждого игрока есть строчка с увеличением очков и выводом результатов в консоль. Чем больше игроков, тем больше кода будет в функции.</li></ul><p>Было бы здорово написать код функции так, чтобы она работала для любого количества игроков. Есть ли такая структура, которая может хранить в себе много данных и которую удобно обрабатывать? Да! Массивы! И вы с ними уже знакомы!</p><p>Вот краткое напоминание на всякий случай: массив — список элементов. У каждого из них есть порядковый номер. Массивы и чтение из них выглядят так:</p><pre>// Массив чисел\nvar array = [10, 20, 30, 40, 50];\n\n// Читаем элементы из массива по индексу (порядковому номеру)\nconsole.log(array[0]); // Выведет 10\nconsole.log(array[3]); // Выведет 40\n</pre><p>Если вы совсем забыли, что такое массивы и как они работают, пройдите курс «Массивы».</p><p>Вернёмся к нашей задаче и введём массив с объектами игроков. Будем передавать в функцию именно его. Тогда мы сможем перебирать массив в цикле и для каждого игрока делать одно и то же: бросать кубики, записывать результат и показывать его.</p></div>`,html:``,css:``,hidden:``,js:`var diceNumber = 2;\n\nvar firstCat = {\n    name: 'Кекс',\n    points: 0\n};\n\nvar secondCat = {\n    name: 'Рудольф',\n    points: 0\n};\n\nvar runGame = function (quantity, firstPlayer, secondPlayer) {\n    firstPlayer.points += keks.throwDice(quantity, quantity * 6);\n    secondPlayer.points += keks.throwDice(quantity, quantity * 6);\n    console.log(firstPlayer.name + ' выбросил ' + firstPlayer.points);\n    console.log(secondPlayer.name + ' выбросил ' + secondPlayer.points);\n};\n\nrunGame(diceNumber, firstCat, secondCat);\n`,tasks:[{message:"Перед функцией <code>runGame</code> создайте массив <code class='keyvalue'>cats</code> с элементами <code class='keytext'>firstCat</code>, <code class='keytext'>secondCat</code>.",check:(o)=>o&&o.cats&&Array.isArray(o.cats)&&~o.cats.indexOf(o.firstCat)&&~o.cats.indexOf(o.secondCat)},{message: "Удалите в объявлении функции <code>runGame</code> параметры <code class='keytext'>firstPlayer</code> и <code class='keytext'>secondPlayer</code> и вместо них добавьте параметр <code class='keytext'>players</code>.",check:(o)=>~getF(o.runGame).indexOf('function(quantity,players){')},{message: "Удалите в вызове функции <code>runGame</code> аргументы <code class='keytext'>firstCat</code> и <code class='keytext'>secondCat</code> и вместо них добавьте аргумент <code class='keytext'>cats</code>.",check:()=>~getJ().indexOf('runGame(diceNumber,cats)')},{message:`В теле функции <code>runGame</code> вместо всего кода напишите цикл, который увеличивает переменную <code class='keyvalue'>i</code> со значения <code class='keytext'>0</code> до <code class='keyvalue'>players</code><code class='keytext'>.length</code> (не включая это значение). Значение <code class='keyvalue'>i</code> должно увеличиваться на <code class='keytext'>единицу</code> после каждой итерации.`,check:(o)=>~getF(o.runGame).search(/for\((var|let)i=0;i<players\.length;i(\+\+|\+=1|=i\+1)\)\{\S*\}/)},{message: "Внутри цикла выводите в <code class='keyword'>консоль</code> текущий элемент массива <code class='keyvalue'>players</code>.",check:(o)=>~getF(o.runGame).search(/for\((var|let)i=0;i<players\.length;i(\+\+|\+=1|=i\+1)\)\{\S*console\.log\(players\[i\]\)\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1142":{theory:`<div><h1>Переопределяем свойства объекта</h1><p>Мы убедились, что цикл внутри функции работает и в консоль выводится текущий элемент массива игроков. Что дальше?</p><p>После каждого броска мы должны увеличивать игровые очки на результат этого броска. Получается запись вида <code>player.points += результат броска</code>. Как это работает?</p><p><b>Переопределение свойств.</b></p><p>Свойства объектов можно не только читать, но и переопределять, как и обычные переменные. Вернёмся к объекту кота.</p><pre>var cat = {\n  name: 'Кекс',\n  age: 5\n};\n\n<mark>cat.age++;</mark> // Увеличили возраст кота на 1\nconsole.log(cat.age) // Выведет в консоль 6\n\n<mark>cat.name = 'Рокки';</mark> // Заменили снаружи значение свойства name\nconsole.log(cat.name); // Выведет в консоль 'Рокки'\n</pre><p>Внутри цикла будем вызывать функцию броска <code>throwDice</code>, записывать результат в переменную и увеличивать на это значение игровые очки текущего игрока. Чтобы удобней было отследить события в игре, будем выводить результат броска каждого игрока в консоль.</p><div><span>Кстати,</span><p>Как вы уже знаете, при обращении <code>массив[индекс]</code> мы получаем элемент массива. В нашем случае это объект игрока, из которого можно читать, как из любого другого объекта через точку. Поэтому запись в теле нашего цикла <code>массив[индекс].ключ</code> то же самое, что запись <code>объект.ключ</code> при работе с объектом напрямую.</p></div></div>`,html:``,css:``,hidden:``,js:`var diceNumber = 2;\n\nvar firstCat = {\n    name: 'Кекс',\n    points: 0\n};\n\nvar secondCat = {\n    name: 'Рудольф',\n    points: 0\n};\n\nvar cats = [firstCat, secondCat];\n\nvar runGame = function (quantity, players) {\n    for (var i = 0; i < players.length; i++) {\n        console.log(players[i]);\n    }\n};\n\nrunGame(diceNumber, cats);\n`,tasks:[{message:"Внутри <code class='keytext'>цикла</code> в теле <code class='keytext'>функции</code> удалите вывод элемента в <code class='keytext'>консоль</code>.",check:(o)=>!~getF(o.runGame).search(/console\.log\(players\[i\]\)/)},{message:`Объявите внутри цикла переменную <code class='keyvalue'>throwResult</code>, которая содержит результат одного броска <code>keks.throwDice(<code class='keytext'>quantity, quantity * 6</code>)</code>;.`,check:(o)=>~getF(o.runGame).search(/for\S*\{\S*(var|let)throwResult=keks\.throwDice\(quantity,quantity\*6\)\S*\}/)},{message:"Текущему игроку увеличьте количество очков на результат броска <code class='keyvalue'>players[i]</code><code class='keytext'>.points</code> <code class='keyword'>+=</code> <code class='keyvalue'>throwResult</code>;.",check:(o)=>~getF(o.runGame).search(/for\S*\{\S*(var|let)throwResult=\S*players\[i\]\.points\+=throwResult\S*\}/)},{message:"Выведите в <code class='keyword'>консоль</code> имя игрока и количество его игровых очков <code class='keyvalue'>players[i]</code><code class='keytext'>.name</code> <code class='keyword'>+</code> <code class='keytext'>' выбросил '</code> <code class='keyword'>+</code> <code class='keyvalue'>players[i]</code><code class='keytext'>.points</code>.",check:(o)=>~getF(o.runGame).search(/for\S*\{\S*players\[i\]\.points\+=throwResult\S*console\.log\(players\[i\]\.name\+('|"|`)выбросил\1\+players\[i\]\.points\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1143":{theory:`<div><h1>Передаём объект по ссылке</h1><p>Перед тем, как мы продолжим писать игру в кости, рассмотрим одну важную особенность объектов на практике.</p><pre>var firstCat = {\n  name: 'Кекс',\n  age: 5\n};\n\nvar secondCat = firstCat;\nconsole.log(secondCat);\n// Выведет {"name":"Кекс","age":5}\n\n<mark>firstCat.name = 'Снежок';</mark>\nconsole.log(secondCat);\n// Выведет <mark>{"name":"Снежок","age":5}</mark></pre><p>Мы же не трогали второй объект <code>secondCat</code>, но он изменился вместе с первым объектом <code>firstCat</code>. Почему так? Это вообще законно?</p><p>В JavaScript вполне. Объект здесь всегда один, в памяти не создаётся новое место под копию объекта. Каждая переменная содержит не новую отдельную сущность, а ссылку на один-единственный объект. Поэтому когда мы меняем что-то в объекте через одну из переменных, в которой содержится ссылка на него, изменения видны во всех других переменных, будь их хоть двадцать или сорок. Это важная особенность объектов, которую надо запомнить. Она так и называется — <i>передача объектов по ссылке</i>.</p><p>В нашей программе происходит то же самое. Мы создаём массив <code>cats</code> с объектами игроков и передаём его в функцию <code>runGame</code>. Внутри функции мы используем этот массив под другим именем, <code>players</code>, и меняем хранящиеся в нём объекты. Если после окончания работы функции вывести <code>cats</code> в консоль, то окажется, что его содержимое поменялось, хотя мы ничего не возвращали из функции и вроде бы работали с совсем другим массивом.</p><p>Несмотря на то, что такое поведение объектов — известный факт, работа программы может стать неочевидной, если мы захотим передать изменённый массив ещё куда-то, ведь мы меняем массив неявно по ходу работы цикла. Код нужно писать максимально просто и понятно для себя и других разработчиков. Поэтому мы будем возвращать изменённый массив <code>players</code> из функции и записывать его в массив <code>cats</code>, явно обновляя его.</p></div>`,html:``,css:``,hidden:``,js:`var diceNumber = 2;\n\nvar firstCat = {\n    name: 'Кекс',\n    points: 0\n};\n\nvar secondCat = {\n    name: 'Рудольф',\n    points: 0\n};\n\nvar cats = [firstCat, secondCat];\n\nvar runGame = function (quantity, players) {\n    for (var i = 0; i < players.length; i++) {\n        var throwResult = keks.throwDice(quantity, quantity * 6);\n        players[i].points += throwResult;\n        console.log(players[i].name + ' выбросил ' + players[i].points);\n    }\n};\n\nrunGame(diceNumber, cats);\n`,tasks:[{message:"Выведите в <code class='keyword'>консоль</code> массив <code class='keyvalue'>cats</code> сразу перед и сразу после вызова функции <code>runGame</code>.",check:(o)=>{if(!o.hA)Academy.vars.hA=~getJ().search(/console\.log\(cats\)\S*runGame\(diceNumber\S*console\.log\(cats\)/); return o.hA}},{message:"После <code class='keytext'>цикла</code> возвращайте из функции <code>runGame</code> массив игроков <code class='keyvalue'>players</code>.",check:(o)=>~getF(o.runGame).indexOf('returnplayers')},{message:"Вместо обычного вызова <code>runGame</code> записывайте результат работы функции в переменную <code class='keyvalue'>cats</code>.",check:()=>~getJ().indexOf('cats=runGame(diceNumber,cats)')},{message:"Удалите первый вывод <code class='keyvalue'>cats</code> в <code class='keytext'>консоль</code>.",check:(o)=>o.hA&&!~getJ().search(/console\.log\(cats\)\S*runGame\(diceNumber,cats\)/)}],blocked:"4",editorOff:"8"},
"lesson1144":{theory:`<div><h1>Моя игра</h1><p>Наши игроки бросают кости, получают игровые очки, вроде всё здорово, но чего-то внутри игрового цикла не хватает. Чего же?</p><p>Сейчас каждый кот бросает кости один раз, а в нашей игре игрок имеет три попытки для броска. Пора записать это правило в виде кода.</p><p>Для начала нам нужно добавить переменную, которая будет содержать количество попыток игроков. Или не переменную?</p><p>В игре уже есть переменная, которая хранит количество игральных костей. Вместе с переменной количества попыток они образуют игровые правила. Поэтому создадим единую сущность с правилами игры, объект <code>gameRules</code>.</p><p>Перед дополнением игрового цикла придётся поправить параметры, аргументы и код в теле функции <code>runGame</code> с учётом нового объекта с правилами игры.</p><p>Скорей за дело!</p></div>`,html:``,css:``,hidden:``,js:`var diceNumber = 2;\n\nvar firstCat = {\n    name: 'Кекс',\n    points: 0\n};\n\nvar secondCat = {\n    name: 'Рудольф',\n    points: 0\n};\n\nvar cats = [firstCat, secondCat];\n\nvar runGame = function (quantity, players) {\n    for (var i = 0; i < players.length; i++) {\n        var throwResult = keks.throwDice(quantity, quantity * 6);\n        players[i].points += throwResult;\n        console.log(players[i].name + ' выбросил ' + players[i].points);\n    }\n    return players;\n};\n\ncats = runGame(diceNumber, cats);\nconsole.log(cats);\n`,tasks:[{message:"В начале кода, перед объектами игроков, создайте объект <code class='keyvalue'>gameRules</code> со свойствами <code class='keytext'>diceNumber: 2</code> и <code class='keytext'>maxAttempts: 3</code>.",check:(o)=>o&&o.gameRules&&o.gameRules.diceNumber===2&&o.gameRules.maxAttempts===3},{message:"В объявлении функции <code>runGame</code> переименуйте параметр <code class='keytext'>quantity</code> в <code class='keytext'>rules</code>.",check:(o)=>~getF(o.runGame).indexOf('function(rules,players){')},{message:"В вызове функции <code>runGame</code> замените аргумент <code class='keytext'>diceNumber</code> на <code class='keytext'>gameRules</code>.",check:()=>~getJ().indexOf('runGame(gameRules,cats)')},{message:"В теле функции <code>runGame</code> замените обращение к параметру <code class='keyvalue'>quantity</code> на обращение к свойству <code class='keytext'>diceNumber</code> параметра <code class='keyvalue'>rules</code>.",check:(o)=>~getF(o.runGame).search(/throwResult=keks\.throwDice\(rules\.diceNumber,(rules\.diceNumber\*6|6\*rules\.diceNumber)\)/)},{message:"Удалите переменную <code class='keyvalue'>diceNumber</code>.",check:()=>!~getJ().search(/(var|let)diceNumber/)}],blocked:"4",editorOff:"8"},
"lesson1145":{theory:`<div><h1>Раздаём попытки</h1><p>Мы создали объект с правилами игры и теперь можем добавить каждому игроку по три попытки броска. В этом нам поможет цикл.</p><p>Введём счётчик, чтобы следить за количеством попыток и выходить из цикла, когда число будет равно <code>3</code>. Назовём счётчик <code>currentAttempt</code> и начнём отсчёт с <code>1</code>, ведь в игре в кости нет нулевой попытки.</p><p>Обернём в новый цикл всю логику из тела функции <code>runGame</code> и коты начнут бросать кости по три раза. Получится цикл в цикле. Если поменять число в <code>gameRules.maxAttempts</code>, программа всё равно будет работать корректно, бросков будет столько, сколько вы укажете.</p><p>Проверьте сами!</p></div>`,html:``,css:``,hidden:``,js:`var gameRules = {\n    diceNumber: 2,\n    maxAttempts: 3\n};\n\nvar firstCat = {\n    name: 'Кекс',\n    points: 0\n};\n\nvar secondCat = {\n    name: 'Рудольф',\n    points: 0\n};\n\nvar cats = [firstCat, secondCat];\n\nvar runGame = function (rules, players) {\n    for (var i = 0; i < players.length; i++) {\n        var throwResult = keks.throwDice(rules.diceNumber, rules.diceNumber * 6);\n        players[i].points += throwResult;\n        console.log(players[i].name + ' выбросил ' + players[i].points);\n    }\n    return players;\n};\n\ncats = runGame(gameRules, cats);\nconsole.log(cats);\n`,tasks:[{message:"В теле функции <code>runGame</code> напишите цикл <code class='keyword'>for</code>, который увеличивает счётчик <code class='keyvalue'>currentAttempt</code> с <code class='keytext'>1</code> до <code class='keyvalue'>rules</code><code class='keytext'>.maxAttempts</code> включительно на единицу после каждой итерации.",check:(o)=>~getF(o.runGame).search(/for\((var|let)currentAttempt=1;currentAttempt<=rules\.maxAttempts;currentAttempt(\+\+|\+=1|=currentAttempt\+1)\)\{\S*\}/)},{message:"В новый <code class='keytext'>цикл</code> перенесите весь <code class='keytext'>остальной код</code> тела <code class='keytext'>функции</code>, кроме <code class='keyword'>return</code>.",check:(o)=>o&&~getF(o.runGame).search(/for\(\S*\)\{\S*for\((var|let)i=0;i<players\.length;i\S*\{\S*throwResult=keks\.throwDice\(rules\.diceNumber\S*players\[i\]\.points\+=throwResult\S*console\.log\(players\[i\]\.name\+\S*\}\S*\}returnplayers/)}],blocked:"4",editorOff:"8"},
"lesson1146":{theory:`<div><h1>Кому отдать победу?</h1><p>Мы сделали самое сложное — разложили игру на составляющие и написали игровой цикл!</p><p>Пока мы можем определить победителя игры, посмотрев на список игровых очков в консоли. Сделаем так, чтобы программа сама выявляла чемпиона. Будем писать код в несколько этапов, проверяя работу программы на каждом шагу.</p><p>Создадим функцию <code>getWinners</code>, которая будет получать массив игроков, обрабатывать его и определять победителей.</p><p>Задача нахождения чемпиона похожа на поиск максимального элемента в массиве: нам нужно пройтись по массиву игроков и найти того, кто набрал наибольшее количество очков. Тут есть сложность: победителей может оказаться больше одного, ведь по ходу игры несколько котов могут набрать одинаковое количество очков. Как быть в этом случае?</p><p>Оптимизируем алгоритм поиска максимального элемента в массиве так, чтобы учитывались все игроки с наибольшим количеством очков. Для этого мы заведём массив победителей. Чаще всего этот массив будет состоять из одного элемента, но если в игре окажется несколько чемпионов, мы никого не обидим и запишем всех в ряды победителей.</p><p>Для начала введём пустой массив, вернём его из <code>getWinners</code> и проверим, что всё работает.</p></div>`,html:``,css:``,hidden:``,js:tj1+`\ncats = runGame(gameRules, cats);\nconsole.log(cats);\n`,tasks:[{message:"После функции <code>runGame</code> объявите функцию <code>getWinners</code> с параметром <code class='keytext'>players</code>.",check:()=>~getJ().search(/(getWinners=function|functiongetWinners)\(players\)\{\S*\}/)},{message:"В теле <code class='keytext'>функции</code> объявите пустой массив <code class='keyvalue'>winners</code> и <code class='keytext'>верните</code> его из <code class='keytext'>функции</code>.",check:()=>~getJ().search(/(getWinners=function|functiongetWinners)\(players\)\{\S*(var|let)winners=\[\]\S*returnwinners\S*\}/)},{message:`В коде программы, после вывода в <code class='keytext'>консоль</code> массива <code class='keyvalue'>cats</code>, создайте переменную <code class='keyvalue'>tops</code> и запишите в неё результат работы функции <code>getWinners(<code class='keytext'>cats</code>)</code>.`,check:()=>~getJ().search(/console\.log\(cats\)\S*(var|let)tops=getWinners\(cats\)/)},{message:"Выведите в <code class='keyword'>консоль</code> переменную <code class='keyvalue'>tops</code>.",check:()=>~getJ().search(/(var|let)tops\S*console\.log\(tops\)/)}],blocked:"4",editorOff:"8"},
"lesson1147":{theory:`<div><h1>Огласите весь список, пожалуйста</h1><p>Новая функция работает. Начнём описывать логику выявления победителя.</p><p>В функцию <code>getWinners</code> мы передаём массив игроков, которые уже использовали попытки для бросков и имеют какое-то количество игровых очков. В первую очередь будем перебирать этот массив и выводить в консоль текущий элемент. Снова проверим, что всё работает и только потом будем писать код дальше. Программа становится всё больше и сложнее, поэтому проверять работоспособность кода на каждом шаге очень полезно, так мы минимизируем ошибки в игре.</p></div>`,html:``,css:``,hidden:``,js:tj1+`\nvar getWinners = function (players) {\n    var winners = [];\n    return winners;\n};\n\ncats = runGame(gameRules, cats);\nconsole.log(cats);\nvar tops = getWinners(cats);\nconsole.log(tops);\n`,tasks:[{message:`В теле функции <code>getWinners</code>, после объявления переменной <code class='keyvalue'>winners</code>, напишите <code class='keyword'>цикл</code>, который увеличивает переменную <code class='keyvalue'>i</code> с <code class='keytext'>0</code> до длины массива <code class='keyvalue'>players</code> (не включая это значение). <code class='keyvalue'>i</code> должно увеличиваться на <code class='keytext'>единицу</code> после каждой итерации.`,check:(o)=>o&&~getF(o.getWinners).search(/(var|let)winners=\[\]\S*for\((var|let)i=0;i<players\.length;i(\+\+|\+=1|=i\+1)\)\{\S*\}/)},{message:"Внутри </code class='keytext'>цикла</code> создайте переменную <code class='keyvalue'>currentPlayer</code>, которая равна <code class='keytext'>текущему элементу массива</code>.",check:(o)=>o&&~getF(o.getWinners).search(/for\((var|let)i=0;i<players\.length;i(\+\+|\+=1|=i\+1)\)\{\S*(var|let)currentPlayer=players\[i\]\S*\}/)},{message:"Выведите в <code class='keyword'>консоль</code> переменную <code class='keyvalue'>currentPlayer</code>.",check:(o)=>o&&~getF(o.getWinners).search(/for\(\S*i=0;i<players\.length;i\S*\)\{\S*currentPlayer=players\[i\]\S*console\.log\(currentPlayer\)\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1148":{theory:`<div><h1>Ищем результативного кота</h1><p>Теперь, когда мы убедились, что цикл работает корректно, начнём искать победителя, то есть игрока с максимальным количеством очков.</p><p>В первую очередь нужно выбрать игрока, с которым мы будем сравнивать результаты остальных котов. Так как мы храним игроков в массиве, логично и удобно для начала назначить первого участника, как самого результативного.</p><p>Будем перебирать элементы массива в цикле и сравнивать количество очков с первым игроком. Если у какого-то игрока результат лучше, назначим его чемпионом и продолжим сравнение уже с этим игроком. Чтобы отслеживать изменения победителей, будем выводить максимальный результат в консоль.</p></div>`,html:``,css:``,hidden:``,js:tj1+`\nvar getWinners = function (players) {\n    var winners = [];\n\n    for (var i = 0; i < players.length; i++) {\n        var currentPlayer = players[i];\n        console.log(currentPlayer);\n    }\n\n    return winners;\n};\n\ncats = runGame(gameRules, cats);\nconsole.log(cats);\nvar tops = getWinners(cats);\nconsole.log(tops);\n`,tasks:[{message:`В теле функции <code>getWinners</code> перед <code class='keytext'>циклом</code> создайте переменную <code class='keyvalue'>max</code>, которая содержит <code class='keytext'>первый</code> элемент массива <code class='keyvalue'>players</code>.`,check:(o)=>o&&~getF(o.getWinners).search(/(var|let)max=players\[0\]\S*for\(/)},{message:"Внутри <code class='keytext'>цикла</code> вместо вывода в <code class='keytext'>консоль</code> добавьте <code class='keytext'>проверку</code>, что у текущего игрока очков <code class='keytext'>больше</code>, чем у рекордсмена.",check:(o)=>o&&~getF(o.getWinners).search(/for\S*\{\S*(?!console\.log\(currentPlayer\))\S*if\((currentPlayer\.points>max\.points|max\.points<currentPlayer\.points)\)\{\S*\}\S*(?!console\.log\(currentPlayer\))\S*\}/)},{message:"Если <code class='keytext'>условие выполняется</code>, сделайте <code class='keytext'>текущего игрока рекордсменом</code>.",check:(o)=>o&&~getF(o.getWinners).search(/for\S*\{\S*if\((currentPlayer\.points>max\.points|max\.points<currentPlayer\.points)\)\{\S*max=currentPlayer\S*\}\S*\}/)},{message:"A также выведите в консоль <code class='keytext'>'Новый рекордсмен: '</code> <code class='keyword'>+</code> <code class='keyvalue'>currentPlayer</code><code class='keytext'>.points</code>.",check:(o)=>o&&~getF(o.getWinners).search(/for\S*\{\S*if\((currentPlayer\.points>max\.points|max\.points<currentPlayer\.points)\)\{\S*console\.log\(('|"|`)Новыйрекордсмен:\2\+currentPlayer\.points\)\S*\}\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1149":{theory:`<div><h1>Никому не спрятаться</h1><p>Мы научились находить победителей, а теперь начнём записывать их в массив <code>winners</code>. При переборе массива игроков возможны две интересные ситуации.</p><p>В первой мы встречаем игрока, у которого очков больше, чем у текущего чемпиона. Такой случай мы уже умеем обрабатывать. Осталось правильно внести данные в массив победителей.</p><p>Рекордсменов мы находим по одному, поэтому и в массиве победителей игрок должен оказаться в гордом одиночестве. Удаляем бывших рекордсменов из массива и записываем туда нового потенциального чемпиона. Легче всего это сделать, полностью перезаписав массив:</p><pre>// Записываем в <code>winners</code> массив из одного элемента, max\nwinners = [max];\n</pre><p>Во второй ситуации мы встречаем игрока с таким же количеством очков, как у текущего претендента на победу. Этот случай мы пока не описали. Как понять, что мы встретили равного сильнейшему? Например, вот так:</p><pre><em>Если</em> у текущего игрока очков больше, чем у чемпиона, то делаем его новым победителем.\n<em>Иначе</em><em>Если</em> у текущего игрока очков столько же, сколько у чемпиона, то добавляем его в массив победителей.\n</pre><p>То есть мы можем использовать вложенное условие внутри альтернативной ветки проверки на чемпионство.</p><p>Чтобы добавить несколько победителей в массив, удобнее всего использовать метод <code>push</code>. Этот метод добавляет переданные ему элементы в конец указанного массива. Например:</p><pre>var purchases = ['молоко', 'кефир'];\n\n<mark>purchases.push('колбаса', 'конфеты', 'мармелад');</mark>\nconsole.log(purchases);\n// Выведет <mark>["молоко","кефир","колбаса","конфеты","мармелад"]</mark></pre><p>Много всего? Ничего, тяжело в учении, легко в задачах от Босса! <em>Но это неточно</em>.</p></div>`,html:``,css:``,hidden:``,js:tj1+`\nvar getWinners = function (players) {\n    var winners = [];\n    var max = players[0];\n\n    for (var i = 0; i < players.length; i++) {\n        var currentPlayer = players[i];\n        if (currentPlayer.points > max.points) {\n            max = currentPlayer;\n            console.log('Новый рекордсмен: ' + currentPlayer.points);\n        }\n    }\n\n    return winners;\n};\n\ncats = runGame(gameRules, cats);\nconsole.log(cats);\nvar tops = getWinners(cats);\nconsole.log(tops);\n`,tasks:[{message:`В проверке на нового рекордсмена, после <code>max <code class='keyword'>=</code> currentPlayer</code>, запишите в переменную <code class='keyvalue'>winners</code> массив из одного элемента <code class='keyvalue'>max</code>.`,check:(o)=>o&&~getF(o.getWinners).search(/if\S*max=currentPlayer\S*winners=\[max\]\S*/)},{message:"Вывод сообщения в <code class='keytext'>консоль</code> про рекордсмена <code class='keytext'>удалите</code>.",check:(o)=>o&&!~getF(o.getWinners).indexOf('console.log')},{message:"Добавьте в условие ветку <code class='keyword'>else</code>.",check:(o)=>o&&~getF(o.getWinners).search(/winners=\[max\]\S*\}else\{\S*\}/)},{message:`Внутри <code class='keyword'>else</code> напишите вложенный <code class='keyword'>if</code>, который проверяет равенство очков текущего игрока и рекордсмена (используйте строгое сравнение <code class='keyword'>===</code>).`,check:(o)=>o&&~getF(o.getWinners).search(/winners=\[max\]\S*\}else\{\S*if\((currentPlayer\.points===max\.points|max\.points===currentPlayer\.points)\)\{\S*\}\S*\}/)},{message:"Если это <code class='keytext'>условие выполняется</code>, добавляйте текущего игрока в массив победителей с помощью метода <code>push</code>.",check:(o)=>o&&~getF(o.getWinners).search(/winners=\[max\]\S*\}else\{\S*if\((currentPlayer\.points===max\.points|max\.points===currentPlayer\.points)\)\{\S*winners\.push\(currentPlayer\)\S*\}\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1150":{theory:`<div><h1>Новые условия</h1><p>Мы использовали вложенные условия, чтобы добавить проверку на несколько победителей с одинаковыми результатами. Такие условия работают, но делают код трудночитаемым.</p><p>Рассмотрим на простом бытовом примере. Вы пошли в магазин за молоком. Если молока в магазине не окажется, но будет кефир, вы купите его. Если и кефира не будет, придётся взять йогурт. А вот если и йогурт закончился, вам придётся купить ряженку, хоть вы её не очень-то жалуете. Код с вложенными условиями будет выглядеть так:</p><pre>var isMilk = false;\nvar isKefir = false;\nvar isYogurt = true;\n\nif (isMilk) {\n console.log('Отлично! Беру молоко!');\n} else {\n if (isKefir) {\n  console.log('Тогда возьму кефир!');\n } else {\n  if (isYogurt) {\n   console.log('Ну и ладно! Куплю йогурт!');\n  } else {\n   console.log('Ну вот, придётся брать ряженку!');\n  }\n }\n};\n\n// В консоль выведется 'Ну и ладно! Куплю йогурт!'</pre><p>Согласитесь, код выглядит громоздко? Есть более удобный способ записи — цепочка условных конструкций. Она подходит, когда необходимо проверить больше двух условий и закончить проверку, если какое-то из условий срабатывает.</p><p>Синтаксис вам знаком, только во второй и последующих ветках <code>if</code> можно писать через пробел сразу после <code>else</code>, а затем добавить новое условие. Тогда, если первая проверка не выполняется, программа проверит условие в следующей ветке. Если и там условие неверно, код будет проверяться дальше. В конце конструкции можно добавить ветку с обычным <code>else</code> на случай, если ни одно из предыдущих условий не будет выполнено.</p><p>С цепочкой условий код похода в магазин будет выглядеть так:</p><pre>var isMilk = false;\nvar isKefir = false;\nvar isYogurt = true;\nif (isMilk) {\n console.log('Отлично! Беру молоко!');\n} <mark>else if</mark> (isKefir) {\n console.log('Тогда возьму кефир!');\n} <mark>else if</mark> (isYogurt) {\n console.log('Ну и ладно! Куплю йогурт!');\n} else {\n console.log('Ну вот, придётся брать ряженку!');\n}\n// В консоль выведется 'Ну и ладно! Куплю йогурт!'</pre><p>Так код выглядит аккуратней, логичней и легко читается.</p><p>Используем цепочку условий в нашем коде.</p></div>`,html:``,css:``,hidden:``,js:tj1+`\nvar getWinners = function (players) {\n    var winners = [];\n    var max = players[0];\n\n    for (var i = 0; i < players.length; i++) {\n        var currentPlayer = players[i];\n        if (currentPlayer.points > max.points) {\n            max = currentPlayer;\n            winners = [max];\n        } else {\n            if (currentPlayer.points === max.points) {\n                winners.push(currentPlayer);\n            }\n        }\n    }\n\n    return winners;\n};\n\ncats = runGame(gameRules, cats);\nconsole.log(cats);\nvar tops = getWinners(cats);\nconsole.log(tops);\n`,tasks:[{message:"Замените вложенное условие в функции <code>getWinners</code> на <code class='keyword'>else if</code>.",check:(o)=>o&&~getF(o.getWinners).search(/\}elseif\((currentPlayer\.points===max\.points|max\.points===currentPlayer\.points)\)\{\S*winners\.push\(currentPlayer\)\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1151":{theory:`<div><h1>Большая редкость</h1><p>Мы написали ещё одну функцию и теперь программа умеет определять победителей игры, но пока никуда их не выводит. Напишем ещё немного кода, чтобы имена победителей и их игровые очки выводились в консоль.</p><p>Начнём с того, что создадим функцию <code>printWinners</code> и обработаем редкую ситуацию, когда все игроки выбросили одинаковое количество очков. Чем игроков больше, тем меньше вероятность ничейного результата, но такое может случиться, и мы должны учесть такой поворот событий.</p><p>Как определить, что все коты набрали одинаковое количество очков? Достаточно передать в функцию <code>printWinners</code> массив игроков и массив победителей, проверить длины этих массивов и, если они совпадают, значит, у нас коллективная ничья. Ведь победителей не может быть больше, чем игроков, а если их меньше, значит, выиграли не все.</p></div>`,html:``,css:``,hidden:``,js:tj1+`var getWinners = function (players) {\n    var winners = [];\n    var max = players[0];\n\n    for (var i = 0; i < players.length; i++) {\n        var currentPlayer = players[i];\n        if (currentPlayer.points > max.points) {\n            max = currentPlayer;\n            winners = [max];\n        } else if (currentPlayer.points === max.points) {\n            winners.push(currentPlayer);\n        }\n    }\n\n    return winners;\n};\n\ncats = runGame(gameRules, cats);\nconsole.log(cats);\nvar tops = getWinners(cats);\nconsole.log(tops);\n`,tasks:[{message:`После функции <code>getWinners</code> объявите функцию <code>printWinners</code> с параметрами <code class='keytext'>players</code> и <code class='keytext'>winners</code>.`,check:()=>~getJ().search(/getWinners\S*(printWinners=function|functionprintWinners)\(players,winners\)\{\S*\}/)},{message:"В конце программы вызовите <code>printWinners</code> с аргументами <code class='keytext'>cats</code> и <code class='keytext'>tops</code>.",check:()=>~getJ().indexOf('printWinners(cats,tops)')},{message:`Внутри функции <code>printWinners</code> добавьте <code class='keytext'>проверку на равенство</code> длин массивов <code class='keyvalue'>players</code> и <code class='keyvalue'>winners</code>.`,check:()=>~getJ().search(/getWinners\S*(printWinners=function|functionprintWinners)\(players,winners\)\{\S*if\((players\.length={2,3}winners\.length|winners\.length={2,3}players\.length)\)\{\S*\}\S*\}/)},{message:"Если условие выполняется, выведите в <code class='keyword'>консоль</code> <code class='keytext'>'Все коты как на подбор!'</code>.",check:()=>~getJ().search(/getWinners\S*(printWinners=function|functionprintWinners)\(players,winners\)\{\S*if\((players\.length={2,3}winners\.length|winners\.length={2,3}players\.length)\)\{\S*console\.log\(('|"|`)Всекотыкакнаподбор!\3\)\S*\}\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1152":{theory:`<div><h1>Выводим на чистую воду</h1><p>Мы обработали ситуацию с одинаковым результатом у всех игроков. При встрече этого редкого события можно вывести сообщение в консоль и сразу же завершить работу функции. Этот приём позволяет упростить дальнейшие проверки, ведь мы точно знаем, что одно условие уже обрабатывать не нужно.</p><p>Теперь опишем случаи, когда победителей несколько (но не все) или один. Что для этого нужно?</p><ul><li>Если победили не все участники, сообщение будет начинаться одинаково, со слова «Победил». Поэтому создадим переменную, которая будет хранить начало сообщения. И не забудем про пробел после слова.</li><li>Так как объекты победителей находятся в массиве, мы будем перебирать массив, получать имена игроков и добавлять их с помощью конкатенации строк в сообщение.</li><li>Добавим в сообщение информацию о количестве игровых очков у победителей. Для этого не нужно перебирать массив, ведь результат у победителей одинаковый. Для простоты возьмём игровые очки первого игрока и добавим их в сообщение.</li><li>Выведем сообщение в консоль и посмотрим, что получилось.</li></ul></div>`,html:``,css:``,hidden:``,js:tj1+`\nvar getWinners = function (players) {\n    var winners = [];\n    var max = players[0];\n\n    for (var i = 0; i < players.length; i++) {\n        var currentPlayer = players[i];\n        if (currentPlayer.points > max.points) {\n            max = currentPlayer;\n            winners = [max];\n        } else if (currentPlayer.points === max.points) {\n            winners.push(currentPlayer);\n        }\n    }\n\n    return winners;\n};\n\nvar printWinners = function (players, winners) {\n    if (players.length === winners.length) {\n        console.log('Все коты как на подбор!');\n    }\n};\n\ncats = runGame(gameRules, cats);\nconsole.log(cats);\nvar tops = getWinners(cats);\nconsole.log(tops);\nprintWinners(cats, tops);\n`,tasks:[{message:`Доработайте функцию <code>printWinners</code>: после вывода <code class='keytext'>'Все коты как на подбор!'</code>, закончите работу функцию с помощью <code class='keyword'>return</code>.`,check:(o)=>o&&~getF(o.printWinners).search(/console\.log\(('|"|`)Всекотыкакнаподбор!\1\);?return/)},{message:`После первого условия создайте переменную <code class='keyvalue'>message</code>, которая содержит строку <code class='keytext'>'Победил '</code>.`,check:(o)=>o&&~getF(o.printWinners).search(/if\S*\}(var|let)message=('|"|`)Победил\2/)},{message:`После переменной напишите цикл <code class='keyword'>for</code>, который увеличивает счётчик <code class='keyvalue'>i</code> с <code class='keytext'>0</code> до длины массива <code class='keyvalue'>winners</code> (не включая это значение) на <code class='keytext'>единицу</code> на каждой итерации.`,check:(o)=>o&&~getF(o.printWinners).search(/(var|let)message=\S*for\((var|let)i=0;i<winners\.length;i(\+\+|\+=1|=i\+1)\)\{\S*\}/)},{message:"В теле <code class='keytext'>цикла</code> добавляйте в сообщение имена победителей <code class='keyvalue'>message</code> <code class='keyword'>+=</code> <code class='keyvalue'>winners[<code class='keytext'>i</code>]</code><code class='keytext'>.name</code>.",check:(o)=>o&&~getF(o.printWinners).search(/(var|let)message=\S*for\S*\{\S*message\+=winners\[i\]\.name\S*\}/)},{message:`После цикла с помощью <code class='keyword'>+=</code> добавьте в сообщение <code class='keyvalue'>message</code> строку <code class='keytext'>' с количеством очков: '</code> + очки первого игрока в массиве <code class='keyvalue'>winners</code>.`,check:(o)=>o&&~getF(o.printWinners).search(/message=\S*for\S*\{\S*\}\S*message\+=('|"|`)сколичествомочков:\1\+winners\[0\]\.points/)},{message:"Выведите <code class='keyvalue'>message</code> в <code class='keyword'>консоль</code>.",check:(o)=>o&&~getF(o.printWinners).search(/message\+=('|"|`)сколичествомочков:\1\S*console\.log\(message\)/)}],blocked:"4",editorOff:"8"},
"lesson1153":{theory:`<div><h1>Бросайте кости, господа коты!</h1><p>Наша игра полностью написана! Коты бросают кости, победитель определяется программно, его имя и победные очки выводятся в консоль.</p><p>Мы переживали, что же случится, если участников станет больше. Давайте проверим! Введём ещё одного кота в игру, вдвоём скучно бросать кости, а втроём уже интересней.</p><p>А потом попробуем поменять правила игры, чтобы проверить, как программа работает в разных ситуациях.</p></div>`,html:``,css:``,hidden:``,js:tj1+`\nvar getWinners = function (players) {\n    var winners = [];\n    var max = players[0];\n\n    for (var i = 0; i < players.length; i++) {\n        var currentPlayer = players[i];\n        if (currentPlayer.points > max.points) {\n            max = currentPlayer;\n            winners = [max];\n        } else if (currentPlayer.points === max.points) {\n            winners.push(currentPlayer);\n        }\n    }\n\n    return winners;\n};\n\nvar printWinners = function (players, winners) {\n    if (players.length === winners.length) {\n        console.log('Все коты как на подбор!');\n        return;\n    }\n\n    var message = 'Победил ';\n\n    for (var i = 0; i < winners.length; i++) {\n        message += winners[i].name;\n    }\n    message += ' с количеством очков: ' + winners[0].points;\n\n    console.log(message);\n};\n\ncats = runGame(gameRules, cats);\nconsole.log(cats);\nvar tops = getWinners(cats);\nconsole.log(tops);\nprintWinners(cats, tops);\n`,tasks:[{message:`В коде программы, после объекта <code class='keyvalue'>secondCat</code>, добавьте объект нового кота <code class='keyvalue'>thirdCat</code> с именем <code class='keytext'>'Рокки'</code> и очками равными <code class='keytext'>нулю</code>.`,check:(o)=>o&&o.thirdCat&&o.thirdCat.name==='Рокки'&&(o.thirdCat.points===0||o.thirdCat.points>0)},{message:"Добавьте нового игрока в массив <code class='keyvalue'>cats</code>.",check:(o)=>o&&o.thirdCat&&o.cats&&~o.cats.indexOf(o.thirdCat)},{message:`Измените максимальное количество попыток в игре на <code class='keytext'>10</code>, а количество костей на <code class='keytext'>5</code>.`,check:(o)=>{if(o&&o.gameRules&&o.gameRules.diceNumber===5&&o.gameRules.maxAttempts===10)Academy.vars.hA=true;return o.hA}},{message:"Измените количество попыток и игральных костей на <code class='keytext'>1</code>.",check:(o)=>o&&o.gameRules&&o.gameRules.diceNumber===1&&o.gameRules.maxAttempts===1}],blocked:"4",editorOff:"8"},
"lesson1154":{theory:`<div><h1>Внесём корректировки</h1><p>Кажется, программа работает как надо. Почти.</p><p>Если побеждает один игрок, то мы получаем отличное сообщение вида <q>Победил <i>Игрок</i> с количеством очков: <i>число</i></q>.</p><p>Если победителей несколько (и есть проигравшие), то сообщение выглядит хуже: <q>Победил <i>ИгрокИгрокИгрок</i> с количеством очков: <i>число</i></q>. Кажется, что-то пошло не так.</p><p>Имена игроков в этом сообщении нужно отделить запятыми и пробелами. И, конечно, если победителей несколько, они не «победи<b>л</b>», а «победил<b>и</b>». Программы программами, но грамотный русский язык никто не отменял.</p><p>Чтобы привести сообщение с победителями в приемлемый вид, придётся добавить пару небольших проверок в функцию <code>printWinners</code>.</p></div>`,html:``,css:``,hidden:``,js:`var gameRules = {\n    diceNumber: 1,\n    maxAttempts: 1\n};\n\nvar firstCat = {\n    name: 'Кекс',\n    points: 0\n};\n\nvar secondCat = {\n    name: 'Рудольф',\n    points: 0\n};\n\nvar thirdCat = {\n    name: 'Рокки',\n    points: 0\n};\n\nvar cats = [firstCat, secondCat, thirdCat];\n\nvar runGame = function (rules, players) {\n    for (var currentAttempt = 1; currentAttempt <= rules.maxAttempts; currentAttempt++) {\n        for (var i = 0; i < players.length; i++) {\n            var throwResult = keks.throwDice(rules.diceNumber, rules.diceNumber * 6);\n            players[i].points += throwResult;\n            console.log(players[i].name + ' выбросил ' + players[i].points);\n        }\n    }\n    return players;\n};\n\nvar getWinners = function (players) {\n    var winners = [];\n    var max = players[0];\n\n    for (var i = 0; i < players.length; i++) {\n        var currentPlayer = players[i];\n        if (currentPlayer.points > max.points) {\n            max = currentPlayer;\n            winners = [max];\n        } else if (currentPlayer.points === max.points) {\n            winners.push(currentPlayer);\n        }\n    }\n\n    return winners;\n};\n\nvar printWinners = function (players, winners) {\n    if (players.length === winners.length) {\n        console.log('Все коты как на подбор!');\n        return;\n    }\n\n    var message = 'Победил ';\n\n    for (var i = 0; i < winners.length; i++) {\n        message += winners[i].name;\n    }\n\n    message += ' с количеством очков: ' + winners[0].points;\n\n    console.log(message);\n};\n\ncats = runGame(gameRules, cats);\nconsole.log(cats);\nvar tops = getWinners(cats);\nconsole.log(tops);\nprintWinners(cats, tops);\n`,tasks:[{message:`В теле функции <code>printWinners</code>: После объявления переменной <code class='keyvalue'>message</code>, добавьте проверку, что количество победителей больше <code class='keytext'>1</code>.`,check:(o)=>o&&~getF(o.printWinners).search(/(var|let)message\S*if\((winners\.length>1|1<winners\.length)\)\{\S*\}/)},{message:"Если условие верно, переопределите значение переменной <code class='keyvalue'>message</code> на <code class='keytext'>'Победили '</code>.",check:(o)=>o&&~getF(o.printWinners).search(/(var|let)message\S*if\((winners\.length>1|1<winners\.length)\)\{\S*message=('|"|`)Победили\3\S*\}/)},{message:"В начале тела <code class='keytext'>цикла</code> добавьте проверку, что <code class='keyvalue'>i</code> больше или равно <code class='keytext'>1</code>.",check:(o)=>o&&~getF(o.printWinners).search(/for\S*\{\S*if\((i>=1|1<=i)\)\{\S*\}\S*\}/)},{message:`Если условие выполняется, добавьте к <code class='keyvalue'>message</code> строку <code class='keytext'>', '</code> (так запятая будет добавляться между всеми именами, если их <code class='keytext'>больше одного</code>).`,check:(o)=>o&&~getF(o.printWinners).search(/for\S*\{\S*if\((i>=1|1<=i)\)\{\S*message\+=('|"|`),\2\S*\}\S*\}/)},{message:"Удалите вывод в <code class='keytext'>консоль</code> массивов <code class='keyvalue'>cats</code> и <code class='keyvalue'>tops</code> в конце программы.",check:()=>!~getJ().search(/cats=runGame\(gameRules,cats\)\S*console\.log/)}],blocked:"4",editorOff:"8"},
"lesson1155":{theory:`<section><h1>Конспект «Объекты». 1 часть</h1><p>Объект — тип данных, который хранит в себе информацию в виде пар «ключ-значение». Каждый элемент сопоставлен со своим ключом и порядок элементов совсем неважен.</p><pre>var cat = {\n  name: 'Кекс',\n  age: 5\n};\n\nconsole.log(cat.name); // Выведет в консоль 'Кекс'\nconsole.log(cat.age); // Выведет в консоль 5\nconsole.log(cat.color); // Выведет undefined, такого ключа в объекте нет\n\ncat.age++; // Увеличили возраст кота на 1\nconsole.log(cat.age) // Выведет в консоль 6\n\ncat.name = 'Рокки'; // Заменили снаружи значение свойства name\nconsole.log(cat.name); // Выведет в консоль 'Рокки'\n</pre><h3>Передача по ссылке</h3><p>Объект всегда один, в памяти не создаётся новое место под копию объекта. Каждая переменная содержит не новую отдельную сущность, а ссылку на один-единственный объект. Поэтому когда мы меняем что-то в объекте через одну из переменных, в которой содержится ссылка на него, изменения видны во всех других переменных, будь их хоть двадцать или сорок. Это важная особенность объектов, которую надо запомнить. Она так и называется — <i>передача объектов по ссылке</i>.</p><pre>var firstCat = {\n  name: 'Кекс',\n  age: 5\n};\n\nvar secondCat = firstCat;\nconsole.log(secondCat);\n// Выведет {"name":"Кекс","age":5}\n\nfirstCat.name = 'Снежок';\nconsole.log(secondCat);\n// Выведет {"name":"Снежок","age":5}\n</pre><br></section>`,html:``,css:``,hidden:``,js:``,tasks:[{message:"Создайте объект <code class='keyvalue'>lesson</code> с ключами <code class='keytext'>html</code> и <code class='keytext'>css</code>. Запишите что-нибудь в каждый ключ!",check:(o)=>{if(o&&o.lesson&&o.lesson.html&&o.lesson.css){Academy.CSS.setValue(o.lesson.css);Academy.HTML.setValue(o.lesson.html);return true}}}],blocked:"4",editorOff:"9"},
"lesson1156":{theory:`<div><h1>Десятая программа: «Золотой мяч»</h1><p>Кекс уважает футбол, но смотреть игры ему <strike>лень</strike> некогда. Но это не страшно, ведь коту достаточно знать имена лучших бомбардиров и их результативность, чтобы <strike>поставить на игрока</strike> поддержать беседу в нужный момент.</p><p>Пока вы писали игру, на почту пришло письмо от Кекса с пометкой «Надо было ещё вчера».</p><blockquote><p>Мяу! Мне нужна программа, которая подсчитает полезность и результативность игроков на основе их статистики. Оформи код в виде функции <code>getStatistics</code> с одним параметром — массивом игроков.</p><p>Каждый футболист в этом массиве описывается объектом с тремя полями: имя (свойство <code>name</code>), забитые голы (свойство <code>goals</code>) и голевые пасы (свойство <code>passes</code>).</p><p>Функция должна возвращать этот же массив, в котором каждому игроку добавлены ещё два поля: коэффициент полезности по Кексу<sup>®</sup> (свойство <code>coefficient</code>) и результативность (свойство <code>percent</code>).</p><ul><li>Коэффициент полезности считается так: умножаем голы игрока на <code>2</code> (потому что я считаю, что голы важнее всего) и прибавляем к этому значению все голевые пасы футболиста.</li><li>Результативность (процент забитых мячей футболиста от результата всей команды) считаем так: находим сумму голов всех игроков и выясняем, сколько процентов от этого числа забил каждый футболист. Округляй значение с помощью <code>Math.round()</code>.</li></ul></blockquote><div><p>Рассчитываем, какой процент составляет число:</p><pre>// Общее значение, то есть 100%\n1200\n// Сколько процентов составляет 225 от 1200\n(225 * 100) / 1200 = 18.75\n// После округления с помощью Math.round()\n19\n</pre></div></div>`,html:``,css:``,hidden:``,js:`var getStatistics = function (players) {\n\n};`,tasks:[{message:`<button onclick="fH1()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p><code class='keyword'>Мяу!</code> Мне нужна программа, которая подсчитает полезность и результативность игроков на основе их статистики.</p><p>Оформи код в виде функции <code>getStatistics</code> с одним параметром — массивом игроков.</p><p>Каждый футболист в этом массиве описывается объектом с тремя полями:</p><ul><li>имя (свойство <code class='keyvalue'>name</code>);</li><li>забитые голы (свойство <code class='keyvalue'>goals</code>);</li><li>и голевые пасы (свойство <code class='keyvalue'>passes</code>);</li></ul><p><code class='keytext'>Функция</code> должна возвращать этот же массив, в котором каждому игроку добавлены ещё два поля:</p><ul><li>коэффициент полезности по Кексу® (свойство <code class='keyvalue'>coefficient</code>);</li><li>и результативность (свойство <code class='keyvalue'>percent</code>);</li></ul><p><code class='keytext'>Коэффициент</code> полезности считается так: <code class='keytext'>умножаем голы</code> игрока на <code class='keytext'>2</code> (потому что я считаю, что голы важнее всего) и <code class='keytext'>прибавляем</code> к этому значению все голевые пасы футболиста.</p><p><code class='keytext'>Результативность</code> (процент забитых мячей футболиста от результата всей команды) считаем так: <code class='keytext'>находим сумму</code> голов всех игроков и выясняем, сколько <code class='keytext'>процентов</code> от этого числа забил каждый футболист. Округляй значение с помощью <code>Math.round()</code>.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1157":{theory:`<div><h1>Собери сам!</h1><blockquote><p>Мяу!</p><p>Хватит бездельничать, пора за работу!</p><p>У нас новый проект, надо написать компьютерный магазин. Заказчик серьёзный, поэтому всё должно быть по уму. Вот небольшое ТЗ:</p><ul><li>Пользователь выбирает компьютер, а программа выводит результат заказа.</li><li>В сообщении должны быть технические характеристики и итоговая цена товара.</li><li>Есть базовая цена любого компьютера, а конечная сумма зависит от каждого технического показателя устройства.</li></ul><p>Жду результата! Не подведи!</p></blockquote><p>Как и прежде, разберём задачу, чтобы понять, из чего будет состоять программа.</p><p>Очевидно, что без функции тут не обойдётся. Будем передавать ей выбранный компьютер и получать итоговую сумму. При расчётах необходимо учесть базовую цену устройства и стоимость каждой характеристики. Например, цены компьютеров с экраном 13 и 15 дюймов будут отличаться. Получается, у каждого устройства есть показатели: базовая цена и технические характеристики (оперативная память, процессор и размер дисплея). Иными словами, несколько свойств, относящихся к одной сущности, компьютеру. Вы уже догадались, где мы будем это хранить? Правильно, в объекте.</p><p>В итоге у нас получится конфигуратор компьютера. В объекте будем хранить компьютер и его характеристики, а сам объект будем хранить в теле функции. Выбирая какое-то устройство, будем вызывать функцию-конфигуратор, которая будет записывать в объект компьютера его характеристики, считать цену и возвращать её наружу.</p><p>Для начала создадим функцию <code>buildComputer</code>, заведём внутри объект <code>computer</code> и проверим, что функция его возвращает.</p></div>`,html:``,css:``,hidden:``,js:``,tasks:[{message:"Объявите функцию <code>buildComputer</code> с параметрами <code class='keytext'>memory</code>, <code class='keytext'>display</code>, <code class='keytext'>processor</code>.",check:()=>~getJ().search(/(buildComputer=function|functionbuildComputer)\(memory,display,processor\)\{\S*\}/)},{message:`Внутри функции создайте объект <code class='keyvalue'>computer</code> со свойствами <code class='keytext'>basicPrice: 5000</code>, <code class='keytext'>processor: processor</code>, <code class='keytext'>display: display</code>, <code class='keytext'>memory: memory</code>.`,check:()=>{var s=getJ();if(!~s.search(/(buildComputer=function|functionbuildComputer)\(memory,display,processor\)\{\S*(var|let)computer=\{\S*\}\S*\}/))return false;var i=s.indexOf('computer={')+10;s=s.slice(i,s.indexOf('}',i));return ~s.indexOf('basicPrice:5000')&&~s.indexOf('processor:processor')&&~s.indexOf('display:display')&&~s.indexOf('memory:memory')}},{message:"Возвращайте из функции объект <code class='keyvalue'>computer</code>.",check:()=>~getJ().search(/(buildComputer=function|functionbuildComputer)\(memory,display,processor\)\{\S*returncomputer;?\}/)},{message:`Вызовите функцию с аргументами <code class='keytext'>8</code>, <code class='keytext'>13</code>, <code class='keytext'>'i7'</code> и запишите результат вызова в переменную <code class='keyvalue'>myComputer</code>.`,check:()=>~getJ().search(/(var|let)myComputer=buildComputer\(8,13,('|"|`)i7\2\)/)},{message:"Выведите переменную <code class='keyvalue'>myComputer</code> в <code class='keyword'>консоль</code>.",check:()=>~getJ().search(/(var|let)myComputer=buildComputer\S*console\.log\(myComputer\)/)}],blocked:"4",editorOff:"8"},
"lesson1158":{theory:`<div><h1>Мой первый метод</h1><p>Функция и объект созданы. Идём дальше.</p><p>Нам надо посчитать цену компьютера и вывести итоговое сообщение. Для этого нужно написать функции, и запишем мы их прямо в объект! Так можно делать!</p><p>В объектах могут храниться любые типы данных, в том числе и функции. Такие свойства-функции называются <em>методами</em> объектов. Они вызываются так же, как и любые другие функции, через круглые скобки, а обращаемся мы к методам, как и к свойствам объекта. В итоге вызов метода записывается так: <code>объект.метод()</code>.</p><p>Главное в создании метода — придумать подходящее название, описывающее, что делает этот метод. В мире программирования есть устоявшиеся традиции именования. Например, функции, которые что-то возвращают, называются геттерами и начинаются со слова <code>get</code>. Это выглядит так:</p><pre>var cat = {\n  name: 'Кекс',\n  color: 'рыжий',\n  age: 5,\n\n  getGreeting: function() {\n    return 'Мяу, привет!';\n  }\n};\n\nconsole.log(cat.getGreeting()); // Выведет 'Мяу, привет!'\n</pre><p>Раз методы это те же функции, почему мы вообще записываем их в объект, а не используем привычные внешние функции?</p><p>Методы используются для работы с объектами. Они читают свойства, переписывают их и возвращают. Да, можно создать внешнюю функцию, передавать ей объект и обрабатывать внутри этой функции. Но намного удобней держать в объекте всё, что относится именно к этому объекту. Например, мы храним технические характеристики внутри объекта компьютера, нам нужно возвращать строку с данными и высчитывать цену. Эти две задачи связаны именно с объектом компьютера, поэтому мы будем записывать эти функции в объект.</p><p>Создадим простой геттер для объекта компьютера и проверим, всё ли работает, как надо.</p></div>`,html:``,css:``,hidden:``,js:`var buildComputer = function (memory, display, processor) {\n    var computer = {\n        basicPrice: 5000,\n        processor: processor,\n        display: display,\n        memory: memory\n    };\n\n    return computer;\n};\n\nvar myComputer = buildComputer(8, 13, 'i7');\nconsole.log(myComputer);\n`,tasks:[{message:`Добавьте в объект <code class='keyvalue'>computer</code> метод <code>getDescription</code>, который возвращает строку <code class='keytext'>'компьютер'</code>.`,check:(o)=>{if(o&&o.buildComputer&&typeof o.buildComputer==='function'){var e=o.buildComputer();if(e.getDescription&&typeof e.getDescription==='function'){e=e.getDescription();return e==='компьютер'}}}},{message:`Вместо вывода переменной <code class='keyvalue'>myComputer</code> в <code class='keyword'>консоль</code> выведите сообщение <code class='keytext'>'В корзине '</code> <code class='keyword'>+</code> <code class='keyvalue'>myComputer</code>.<code>getDescription()</code>.`,check:()=>~getJ().search(/myComputer=buildComputer\S*console\.log\(('|"|`)Вкорзине\1\+myComputer\.getDescription\(\)\)/)}],blocked:"4",editorOff:"8"},
"lesson1159":{theory:`<div><h1>Реализуем методы</h1><p>Мы убедились, что метод работает в объекте компьютера. Что дальше?</p><p>Сейчас мы возвращаем просто слово «компьютер». Но метод <code>getDescription</code> должен возвращать описание устройства со всеми его характеристиками, которые хранятся в свойствах объекта <code>computer</code>. Как это сделать? Можно ли изнутри методов объекта обращаться к его свойствам? Можно! Здесь нет никаких сложностей синтаксиса, пишем, как всегда <code>объект.свойство</code>.</p><p>Переопределим метод <code>getDescription</code>. Пусть он возвращает строку с описанием выбранного компьютера. К свойствам, которые хранят технические характеристики устройства будем обращаться через точку изнутри метода.</p><p>Кстати, в объекте может быть много методов, а не один. Поэтому мы заведём еще один и назовём его <code>getPrice</code>. Как понятно из названия, он будет возвращать цену компьютера.</p></div>`,html:``,css:``,hidden:``,js:`var buildComputer = function (memory, display, processor) {\n    var computer = {\n        basicPrice: 5000,\n        processor: processor,\n        display: display,\n        memory: memory,\n\n        getDescription: function () {\n            return 'компьютер';\n        }\n    };\n\n    return computer;\n};\n\nvar myComputer = buildComputer(8, 13, 'i7');\nconsole.log('В корзине ' + myComputer.getDescription());\n`,tasks:[{message:`Замените строку, которую возвращает метод <code>getDescription</code> на <code class='keytext'>'компьютер с процессором '</code> <code class='keyword'>+</code> <code class='keyvalue'>computer</code>.<code class='keytext'>processor</code> <code class='keyword'>+</code> <code class='keytext'>', диагональю '</code> <code class='keyword'>+</code> <code class='keyvalue'>computer</code>.<code class='keytext'>display</code> <code class='keyword'>+</code> <code class='keytext'>', оперативной памятью '</code> <code class='keyword'>+</code> <code class='keyvalue'>computer</code>.<code class='keytext'>memory</code>.`,check:(o)=>{if(o&&o.buildComputer&&typeof o.buildComputer==='function'){var e=o.buildComputer(1,2,'a');if(e.getDescription&&typeof e.getDescription==='function')return e.getDescription()==='компьютер с процессором a, диагональю 2, оперативной памятью 1'}}},{message:"Добавьте в объект <code class='keyvalue'>computer</code> ещё один метод <code>getPrice</code>, который возвращает <code class='keyvalue'>computer</code>.<code class='keytext'>basicPrice</code>.",check:(o)=>{if(o&&o.buildComputer&&typeof o.buildComputer==='function'){var e=o.buildComputer(1,2,'a');if(e.getPrice&&typeof e.getPrice==='function'){e.basicPrice=5000;if(e.getPrice()!==5000)return false;e.basicPrice=12345;return e.getPrice()===12345}}}},{message:`Замените сообщение для вывода в <code class='keyword'>консоль</code> на <code class='keytext'>'В корзине '</code> <code class='keyword'>+</code> <code class='keyvalue'>myComputer</code>.<code>getDescription()</code> <code class='keyword'>+</code> <code class='keytext'>' стоймостью '</code> <code class='keyword'>+</code> <code class='keyvalue'>myComputer</code>.<code>getPrice()</code>.`,check:()=>~getJ().search(/myComputer=buildComputer\S*console\.log\(('|"|`)Вкорзине\1\+myComputer\.getDescription\(\)\+('|"|`)стоймостью\2\+myComputer\.getPrice\(\)\)/)}],blocked:"4",editorOff:"8"},
"lesson1160":{theory:`<div><h1>Объект как словарь</h1><p>Теперь посчитаем цену компьютера. Она состоит из нескольких слагаемых: стартовой цены и стоимости каждой технической характеристики. Расценки:</p><table><tbody><tr><td>Процессор 'i5'</td><td>5000</td></tr><tr><td>Процессор 'i7'</td><td>10000</td></tr><tr><td>Дисплей 13 дюймов</td><td>5000</td></tr><tr><td>Дисплей 15 дюймов</td><td>10000</td></tr><tr><td>Оперативная память 8 Гб</td><td>3000</td></tr><tr><td>Оперативная память 16 Гб</td><td>7000</td></tr></tbody></table><p>Выходит, нам нужно проверять значения свойств в объекте компьютера и, в зависимости от результата, прибавлять к базовой цене ту или иную сумму. В итоге мы получим цену устройства. Для проверки каждой характеристики отдельно можно использовать конструкцию <code>else if</code>. Тогда код будет выглядеть примерно так:</p><pre>var price = computer.basicPrice;\n\nif (computer.processor === 'i5') {\n  price += 5000;\n} else if (computer.processor === 'i7') {\n  price += 10000;\n}\n\n// И так далее суммируем стоимость остальных компонентов\n</pre><p>Код рабочий, но не кажется ли он слишком большим? Сейчас у нас только три характеристики, из которых складывается цена устройства, а что, если их станет больше?</p><p>В некоторых ситуациях блоки с условиями можно сократить с помощью объектов. Давайте разбираться, как это сделать. Рассмотрим на примере.</p><pre>var printFavoriteFood = function (name) {\n  var message = 'Моя любимая еда — ';\n\n  if (name === 'Кекс') {\n    message += 'рыба';\n  } else if (name === 'Рудольф') {\n    message += 'котлета';\n  } else if (name === 'Снежок') {\n    message += 'сметана';\n  }\n\n  return message;\n};\n\nconsole.log(printFavoriteFood('Снежок')); // Выведет 'Моя любимая еда — сметана'\n</pre><p>Обратите внимание, что каждому коту, а точнее его имени, соответствует определённая еда. При этом порядок котов совсем неважен. Можно ли записать вкусовые предпочтения котов в объект? Давайте попробуем.</p><pre>var catsFavoriteFood = {\n  Кекс: 'рыба',\n  Рудольф: 'котлета',\n  Снежок: 'сметана'\n};\n</pre><p>Можно ли теперь использовать данные в объекте <code>catsFavoriteFood</code> так, чтобы совсем избавиться от условий в теле функции <code>printFavoriteFood</code>? Можно! Перед нами обычный объект со свойствами и их значениями. Значит, мы можем обратиться к свойству объекта и подставить в выражение строку, которая в нём содержится.</p><pre>var catsFavoriteFood = {\n  Кекс: 'рыба',\n  Рудольф: 'котлета',\n  Снежок: 'сметана'\n};\n\nvar printFavoriteFood = function (name) {\n  return 'Моя любимая еда — ' + <mark>catsFavoriteFood[name]</mark>;\n};\n\nconsole.log(printFavoriteFood('Снежок')); // Выведет 'Моя любимая еда — сметана'\n</pre><p>Код работает, как и прежде, зато насколько сократилась наша программа!</p><p>Мы записали в объект не характеристику вида <code>name: 'Кекс'</code>, а соотношение имени кота и лакомства, которое по вкусу именно ему. Такие объекты называют <em>словарями</em>, <em>мапами</em> или <em>ассоциативными массивами</em>. Они очень удобны в использовании и позволяют писать код чище и проще.</p><p>В нашей программе для каждого показателя подходит своя цена, например, для процессора 'i7' это <code>10000</code>, для дисплея 13 дюймов это <code>5000</code>. Значит, мы можем сделать словари, которые будут хранить стоимость каждой характеристики, а затем обращаться к свойствам этих объектов, чтобы получить цену.</p></div>`,html:``,css:``,hidden:``,js:`var buildComputer = function (memory, display, processor) {\n    var computer = {\n        basicPrice: 5000,\n        processor: processor,\n        display: display,\n        memory: memory,\n\n        getDescription: function () {\n            return 'компьютер с процессором ' + computer.processor + ', диагональю ' + computer.display + ', оперативной памятью ' + computer.memory;\n        },\n\n        getPrice: function () {\n            return computer.basicPrice;\n        }\n    };\n\n    return computer;\n};\n\nvar myComputer = buildComputer(8, 13, 'i7');\nconsole.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());\n`,tasks:[{message:`Перед функцией <code>buildComputer</code> создайте объект <code class='keyvalue'>processorPrice</code> со свойствами<code class='keytext'>'i5': 5000</code>, <code class='keytext'>'i7': 10000</code>.`,check:(o)=>o&&o.processorPrice&&o.processorPrice['i5']===5000&&o.processorPrice['i7']===10000},{message:"После него создайте объект <code class='keyvalue'>displayPrice</code> со свойствами <code class='keytext'>13: 5000</code>, <code class='keytext'>15: 10000</code>.",check:(o)=>o&&o.displayPrice&&o.displayPrice['13']===5000&&o.displayPrice['15']===10000},{message:"Добавьте объект <code class='keyvalue'>memoryPrice</code> со свойствами <code class='keytext'>8: 3000</code>, <code class='keytext'>16: 4000</code>",check:(o)=>o&&o.memoryPrice&&o.memoryPrice['8']===3000&&o.memoryPrice['16']===4000}],blocked:"4",editorOff:"8"},
"lesson1161":{theory:`<div><h1>Скобочная нотация</h1><p>Заметили что-то необычное в примере работы со словарём?</p><pre>var catsFavoriteFood = {\n  'Кекс': 'рыба',\n  'Рудольф': 'котлета',\n  'Снежок': 'сметана'\n};\n\nvar printFavoriteFood = function (name) {\n  return 'Моя любимая еда — ' + catsFavoriteFood<mark>[name]</mark>;\n};\n\nconsole.log(printFavoriteFood('Снежок'));\n// Выведет 'Моя любимая еда — сметана'\n</pre><p>Раньше мы обращались к свойствам объекта с помощью точки, а в этом примере работаем с объектом как с массивом — читаем свойство с помощью квадратных скобок: <code>catsFavoriteFood[name]</code>. Да, так тоже можно. Способ со скобками называется <i>скобочной</i> нотацией, способ с точкой — <i>точечной</i> нотацией. <em>Программисты такие оригиналы, не правда ли?</em></p><p>Скобочная нотация намного гибче точечной. Например, вы можете прочитать из объекта свойство, название которого записано в переменную:</p><pre>var name = 'Кекс';\nvar catsFavoriteFood = { Кекс: 'рыба' };\n\nconsole.log(catsFavoriteFood.name);\n// Выведет в консоль undefined\n\nconsole.log(catsFavoriteFood[name]);\n// Выведет в консоль 'рыба'\n</pre><p>Первое сообщение содержит <code>undefined</code>, потому что у объекта нет свойства <code>name</code>. Второе сообщение содержит искомое значение, потому что программа понимает, что в квадратных скобках переменная. Значение переменной подставится в скобки, а затем будет найдено нужное свойство объекта.</p><pre>console.log(catsFavoriteFood[name]);\n// Незаметно внутри программы превращается в:\nconsole.log(catsFavoriteFood['Кекс']);\n</pre><p>И ещё один сюрприз. В качестве ключей в объекте можно использовать любые строки, даже строки с пробелами. С точечной нотацией такие свойства прочитать не получится, а со скобочной — без проблем.</p><pre>var cat = { 'favorite food': 'Сметана' };\n\nconsole.log(cat.favorite food);\n// Вызовет ошибку\n\nconsole.log(cat['favorite food']);\n// Отработает нормально\n</pre><p>Кстати, почему мы вынесли словари из функции в самое начало программы? Значения, которые хранятся в этих объектах, не зависят от параметров функции или объекта компьютера. Это правила, относящиеся ко всей программе. Их можно использовать в других функциях и операциях, если это понадобится. Если бы словари находились в теле функции, они бы создавались только в момент вызова этой функции.</p><p>Почему это вообще работает? Объект внутри функции видит объекты, которые объявлены в самом начале программы. Так работают области видимости. Мы разберём эту особенность языка позже, в других курсах.</p><p>Теперь, когда словари созданы, и мы научились с ними работать, можно посчитать цену компьютера одной строкой. Будем использовать метод <code>getPrice</code>. Переопределим его, добавив новые вычисления.</p></div>`,html:``,css:``,hidden:``,js:`var processorPrice = {\n    'i5': 5000,\n    'i7': 10000\n};\n\nvar displayPrice = {\n    13: 5000,\n    15: 10000\n};\n\nvar memoryPrice = {\n    8: 3000,\n    16: 4000\n};\n\nvar buildComputer = function (memory, display, processor) {\n    var computer = {\n        basicPrice: 5000,\n        processor: processor,\n        display: display,\n        memory: memory,\n\n        getDescription: function () {\n            return 'компьютер с процессором ' + computer.processor + ', диагональю ' + computer.display + ', оперативной памятью ' + computer.memory;\n        },\n\n        getPrice: function () {\n            return computer.basicPrice;\n        }\n    };\n\n    return computer;\n};\n\nvar myComputer = buildComputer(8, 13, 'i7');\nconsole.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());\n`,tasks:[{message:`Возвращайте из метода <code>getPrice</code> вместо <code class='keyvalue'>computer</code>.<code class='keytext'>basicPrice</code> выражение <code class='keyvalue'>computer</code>.<code class='keytext'>basicPrice</code> <code class='keyword'>+</code> <code class='keyvalue'>processorPrice[computer.<code class='keytext'>processor</code>]</code> <code class='keyword'>+</code> <code class='keyvalue'>displayPrice[computer.<code class='keytext'>display</code>]</code> <code class='keyword'>+</code> <code class='keyvalue'>memoryPrice[computer.<code class='keytext'>memory</code>]</code>.`,check:(o)=>{if(o&&o.buildComputer&&typeof o.buildComputer==='function'){var e=o.buildComputer(8,13,'i7');if(e.getPrice&&typeof e.getPrice==='function'){if(e.getPrice()!==23000)return false;return o.buildComputer(16,15,'i5').getPrice()===24000}}}}],blocked:"4",editorOff:"8"},
"lesson1162":{theory:`<div><h1>Не будем вырывать из контекста</h1><p>Наша программа готова! Вся необходимая функциональность написана! Осталось обсудить ещё один вопрос.</p><p>Внутри методов мы обращаемся к свойствам объекта компьютера <code>computer.свойство</code>. А что, если в будущем название объекта изменится и количество свойств увеличится? Придётся везде исправлять <code>computer</code> на что-то новое. Лень — одно из главных качеств разработчика, переписывать названия совсем не хочется. Хорошо, что есть ключевое слово <b>this</b>. Им-то мы и воспользуемся.</p><p><code>this</code> недаром называется именно так. Если в речи такое местоимение указывает на определённый предмет, то в JavaScript ключевое слово <code>this</code> указывает на конкретный объект, а именно на тот объект, на котором была вызвана функция (метод).</p><p>Использовать <code>this</code> просто, достаточно заменить название объекта на ключевое слово в обращении к свойству. Вместо <code>объект.свойство</code> используем <code>this.свойство</code>.</p><pre>var cat = {\n  name: 'Рудольф',\n\n  introduce: function () {\n    console.log('Мяу! Я кот ' + <mark>this.name</mark> + '!');\n  }\n};\n\ncat.introduce(); // Выведет 'Мяу! Я кот Рудольф!'\n</pre><p>Объект, на который указывает <code>this</code> называется <em>контекстом вызова</em>.</p><p>Важная деталь: пока функция не вызвана, <code>this</code> не содержит никакого значения, контекст появляется только в момент вызова функции.</p><p>Ключевое слово <code>this</code> приносит много пользы разработчикам. О других преимуществах и особенностях <code>this</code> вы узнаете позже, в дальнейших курсах, а пока заменим обращение к свойствам внутри объекта <code>computer</code>.</p></div>`,html:``,css:``,hidden:``,js:`var processorPrice = {\n    'i5': 5000,\n    'i7': 10000\n};\n\nvar displayPrice = {\n    13: 5000,\n    15: 10000\n};\n\nvar memoryPrice = {\n    8: 3000,\n    16: 4000\n};\nvar buildComputer = function (memory, display, processor) {\n    var computer = {\n        basicPrice: 5000,\n        processor: processor,\n        display: display,\n        memory: memory,\n\n        getDescription: function () {\n            return 'компьютер с процессором ' + computer.processor + ', диагональю ' + computer.display + ', оперативной памятью ' + computer.memory;\n        },\n\n        getPrice: function () {\n            return computer.basicPrice + processorPrice[computer.processor] + displayPrice[computer.display] + memoryPrice[computer.memory];\n        }\n    };\n\n    return computer;\n};\n\nvar myComputer = buildComputer(8, 13, 'i7');\nconsole.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());\n`,tasks:[{message:"Во всех методах замените обращения к свойствам и методам <code class='keyvalue'>computer</code> на обращения через <code class='keyword'>this</code>.",check:(o)=>{if(o&&o.buildComputer){var f=getF(o.buildComputer);return !~f.search(/(computer\.processor|computer\.display|computer\.memory|computer\.basicPrice)/)&&~f.indexOf('this.processor')&&~f.indexOf('this.display')&&~f.indexOf('this.memory')&&~f.indexOf('this.basicPrice')&&o.buildComputer(8,13,'i7').getPrice()===23000}}},{message:`Внутри функции <code>buildComputer</code> измените название объекта с <code class='keyvalue'>computer</code> на <code class='keyvalue'>customComputer</code> и не забудьте возвратить <code class='keytext'>объект</code> с новым названием.`,check:(o)=>~getF(o.buildComputer).search(/customComputer=\{\S*returncustomComputer/)&&o.buildComputer(8,13,'i7').getPrice()===23000}],blocked:"4",editorOff:"8"},
"lesson1163":{theory:`<div><h1>Проверка магазина</h1><p>Интернет-магазин готов! Осталось проверить, как будет работать программа с другим компьютером. Надо убедиться, что независимо от показателей устройства, сообщение с техническими характеристиками будет выводиться корректно, а цена будет высчитываться верно.</p><p>Создадим ещё один компьютер с оперативной памятью 16 Гб, диагональю 15 дюймов и процессором 'i5', узнаем его цену и выведем список характеристик.</p></div>`,html:``,css:``,hidden:``,js:`var processorPrice = {\n    'i5': 5000,\n    'i7': 10000\n};\n\nvar displayPrice = {\n    13: 5000,\n    15: 10000\n};\n\nvar memoryPrice = {\n    8: 3000,\n    16: 4000\n};\n\nvar buildComputer = function (memory, display, processor) {\n    var customComputer = {\n        basicPrice: 5000,\n        processor: processor,\n        display: display,\n        memory: memory,\n\n        getDescription: function () {\n            return 'компьютер с процессором ' + this.processor + ', диагональю ' + this.display + ', оперативной памятью ' + this.memory;\n        },\n\n        getPrice: function () {\n            return this.basicPrice + processorPrice[this.processor] + displayPrice[this.display] + memoryPrice[this.memory];\n        }\n    };\n\n    return customComputer;\n};\n\nvar myComputer = buildComputer(8, 13, 'i7');\nconsole.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());\n`,tasks:[{message:`После вывода сообщения в консоль создайте переменную <code class='keyvalue'>anotherComputer</code>, которая равна результату работы функции <code>buildComputer</code> с аргументами <code class='keytext'>16</code>, <code class='keytext'>15</code>, <code class='keytext'>'i5'</code>.`,check:()=>~getJ().search(/console\.log\S*(var|let)anotherComputer=buildComputer\(16,15,('|"|`)i5\2\)/)},{message:`После объявления переменной <code class='keyvalue'>anotherComputer</code> выведите в <code class='keyword'>консоль</code> <code class='keytext'>'В корзине '</code> <code class='keyword'>+</code> <code class='keyvalue'>anotherComputer</code>.<code>getDescription()</code> <code class='keyword'>+</code> <code class='keytext'>' стоймостью '</code> <code class='keyword'>+</code> <code class='keyvalue'>anotherComputer</code>.<code>getPrice()</code>.`,check:()=>~getJ().search(/(var|let)anotherComputer=buildComputer\S*console\.log\(('|"|`)Вкорзине\2\+anotherComputer\.getDescription\(\)\+('|"|`)стоймостью\3\+anotherComputer\.getPrice\(\)\)/)}],blocked:"4",editorOff:"8"},
"lesson1164":{theory:`<section><h1>Конспект «Объекты». 2 часть</h1><p>В объектах могут храниться любые типы данных, в том числе и функции. Такие свойства-функции называются методами объектов. Вызов метода записывается так: объект.метод().</p><p>Изнутри методов можно обращаться к свойствам и другим методам объекта с помощью ключевого слова <code>this</code>.Оно указывает на текущий объект и называется <i>контекстом вызова</i>.</p><p>Важная деталь: пока функция не вызвана, <code>this</code> не содержит никакого значения, контекст появляется только в момент вызова функции.</p><pre>var cat = {\n  name: 'Кекс',\n  color: 'рыжий',\n  age: 5,\n\n  getGreeting: function() {\n    return 'Мяу, привет! Меня зовут ' + и <mark>this.name</mark>;\n  }\n};\n\nconsole.log(<mark>cat.getGreeting()</mark>); // Выведет 'Мяу, привет! Меня зовут Кекс'\n</pre><p>Мапы или словари очень удобны в использовании. В нашем примере они хранят соотношение имени кота и лакомства, которое по вкусу именно ему.</p><pre>var catsFavoriteFood = {\n  Кекс: 'рыба',\n  Рудольф: 'котлета',\n  Снежок: 'сметана'\n};\n\nvar printFavoriteFood = function (name) {\n  // Используем скобочную нотацию\n  return 'Моя любимая еда — ' + <b>catsFavoriteFood<mark>[name]</mark></b>;\n};\n\nconsole.log(printFavoriteFood('Снежок')); // Выведет 'Моя любимая еда — сметана'\n</pre><br></section>`,html:``,css:``,hidden:``,js:``,tasks:[{message:`Создайте объект <code class='keyvalue'>kitten</code>, у которого есть свойство <code class='keytext'>favoriteFood</code> и метод <code>eatFood</code>, который выводит в <code class='keyword'>консоль</code> строку <code class='keytext'>favoriteFood</code> <code class='keyword'>+</code> <code class='keytext'>', какая вкуснятина!'</code>`,check:(o)=>{if(o.hA)return true;if(o&&o.kitten&&typeof o.kitten.eatFood==='function'){var e=o.kitten;e.favoriteFood='рыба';e.eatFood();Academy.vars.hA=~o.log.indexOf('рыба, какая вкуснятина!')}}}],blocked:"4",editorOff:"9"},
"lesson1165":{theory:`<div><h1>Одиннадцатая программа: «Дом, который построил Кекс»</h1><p>Пока вы работали над интернет-магазином, Кекс решил построить дом. Он начал писать конфигуратор для расчёта площади и стоимости строительства, но утомился. И правда, зачем писать код самому, если есть разработчики?</p><blockquote><p>Мяу! Допиши за меня конфигуратор. Я создал объект <code>house</code> и задал ему несколько свойств: <code>rooms</code> (количество комнат), <code>floors</code> (этажи), <code>material</code> (материал для стен), <code>coefficient</code> (средняя площадь каждой комнаты).</p><p>Ещё я завёл мапу <code>materialPrice</code>, в которой записал стоимость каждого возможного материала для строительства.</p><p>Добавь в объект два метода: <code>calculateSquare</code>, который будет возвращать площадь дома, и <code>calculatePrice</code>, который будет возвращать стоимость строительства.</p><p>Площадь считай так: умножь количество комнат на коэффициент и число этажей в доме.</p><p>Цена строительства — произведение площади и стоимости материала дома.</p><p>Жду результата! Может, приглашу тебя на новоселье.</p></blockquote><p>Удачи!</p></div>`,html:``,css:``,hidden:``,js:`var materialPrice = {\n    'wood': 1000,\n    'stone': 1500,\n    'brick': 2000\n};\n\nvar house = {\n    rooms: 10,\n    floors: 5,\n    material: 'wood',\n    coefficient: 10.5\n};\n`,tasks:[{message:`<button onclick="fH2()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p>Мяу! Допиши за меня конфигуратор. Я создал объект <code class='keyvalue'>house</code> и задал ему несколько свойств:</p><ul><li><code class='keytext'>rooms</code> (количество комнат);</li><li><code class='keytext'>floors</code> (этажи);</li><li><code class='keytext'>material</code> (материал для стен);</li><li><code class='keytext'>coefficient</code> (средняя площадь каждой комнаты).</li></ul><p>Ещё я завёл мапу <code class='keyvalue'>materialPrice</code>, в которой записал стоимость каждого возможного материала для строительства.</p><p>Добавь в объект два метода:</p><ul><li><code>calculateSquare</code>, который будет возвращать <code class='keytext'>площадь дома</code>,</li><li>и <code>calculatePrice</code>, который будет возвращать <code class='keytext'>стоимость строительства</code>.</li></ul><p>Площадь считай так: <code class='keytext'>умножь количество комнат на коэффициент и число этажей</code> в доме.</p><p>Цена строительства — <code class='keytext'>произведение площади и стоимости материала</code> дома.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
};
hL();