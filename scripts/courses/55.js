fH1=()=>{var l=Academy.vars.log;var f=Academy.vars.calculateSalary;var p=printLog;var g=getR;if(f){if(typeof f!=='function'){l.push("error: calculateSalary не является функцией!");p('Проверка задания');g(false);return};var r=f(40000);l.push("Грязная зарплата 40000 рублей, ожидаю чистую зарплату 26000 рублей.");if(!r){l.push("error: calculateSalary ничего не вернуло!");p('Проверка задания');g(false);return};l.push("Полученная зарплата: "+ r+" рублей.");if(r!==26000){l.push("error: полученная зарплата не совпадает с ожидаемой!");p('Проверка задания');g(false);return};r=f(120000);l.push("Грязная зарплата 120000 рублей, ожидаю чистую зарплату 66000 рублей.");l.push("Полученная зарплата: "+r+" рублей.");if(r!==66000){l.push("error: полученная зарплата не совпадает с ожидаемой!");p('Проверка задания');g(false);return};l.push("Все тесты пройдены!");p('Проверка задания');g(true);return};l.push("error: у calculateSalary нет значения");p('Проверка задания');g(false)};
fH2=()=>{var l=Academy.vars.log;var f=Academy.vars.calculateDeposit;var p=printLog;var g=getR;if(!f||!(typeof f==='function')){l.push("error: calculateDeposit не является фунецией!");p('Проверка задания');g(false);return};var m=(a)=>"Начальная сумма: "+a[0]+" рублей, годовой процент: "+a[1]+"%, вклад на "+a[2]+" мес., "+(a[3]?"с капитализацией":"без капитализации")+", ожидаемый результат: "+a[4]+" рублей.";var d=[[100000,12,1,false,101000],[100000,12,1,true,101000],[100000,10,2,false,101667],[100000,10,2,true,101674],[200000,6.8,6,false,206800],[200000,0,6,true,200000]];for(var i=0;i<d.length;i++){var r=f(d[i][0],d[i][1],d[i][2],d[i][3]);l.push(m(d[i]));if(!r){l.push("error: функция calculateDeposit ничего не вернула!");p('Проверка задания');g(false);return};l.push("Полученный результат: "+r);if(r===d[i][4])l.push("Результаты совпадают.");else{l.push("error: результаты не совпадают.");p('Проверка задания');g(false);return}};l.push("Все результаты совпадают!");p('Проверка задания');g(true)};
fH3=()=>{var l=Academy.vars.log;var f=Academy.vars.compareDeposits;var p=printLog;var g=getR;if(!f||typeof f!=='function'){l.push("error: compareDeposits не является фунецией!");p('Проверка задания');g(false);return};var m=(a)=>"Исходный размер депозита: "+a[0]+" рублей, срок вклада: "+a[1]+" мес., простой процент "+a[2]+" %, сложный процент: "+a[3]+"%. Ожидаю рекомендацию: "+a[4]+", конечную сумму: "+a[5]+" рублей.";var d=[[10000,9,7,6.8,"simple",10525],[300000,18,7.2,6,"simple",332400],[250000,14,7,6.8,"complex",270581]];for(var i=0;i<d.length;i++){var r=f(d[i][0],d[i][1],d[i][2],d[i][3]);l.push(m(d[i]));if(!r){l.push("error: функция compareDeposits ничего не вернула!");p('Проверка задания');g(false);return};l.push("Полученная рекомендация: "+r[0]+", конечная сумма: "+r[1]);if(r[0]===d[i][4]&&r[1]==d[i][5])l.push("Результаты совпадают.");else{l.push("error: результаты не совпадают.");p('Проверка задания');g(false);return}};l.push("Все результаты совпадают!");p('Проверка задания');g(true)};
fH4=()=>{var l=Academy.vars.log;var f=Academy.vars.calculate;var p=printLog;var g=getR;if(typeof f==='function'){var m=(a)=>"Первое число: "+a[0]+", второе число: "+a[1]+", оператор: "+a[2]+", ожидаю результат: "+a[3];var d=[[15,20,"+",35],[110,22,"/",5],[12,9,"*",108],[356,213,"-",143]];for(var i=0;i<d.length;i++){var r=f(d[i][0],d[i][1],d[i][2]);l.push(m(d[i]));if(!r){l.push("error: функция calculate ничего не вернула!");p('Проверка задания');g(false);return};l.push("Полученный результат: "+r);if(r===d[i][3])l.push("Результаты совпадают.");else{l.push("error: результаты не совпадают.");p('Проверка задания');g(false);return;}};l.push("Все результаты совпадают!");p('Проверка задания');g(true)}else{l.push("error: calculate не является фунецией!");p('Проверка задания');g(false)}};
fH5=()=>{var l=Academy.vars.log;var f=Academy.vars.calculateExpenses;var p=printLog;var g=getR;if(typeof f==='function'){var m=(a)=>"Чистая зарплата: "+a[0]+", ожидаю грязную зарплату: "+a[1];var d=[[70000,104598],[115000,171839],[95700,143000]];for(var i=0;i<d.length;i++){var r=f(d[i][0]);l.push(m(d[i]));if(!r){l.push("error: функция calculateExpenses ничего не вернула!");p('Проверка задания');g(false);return};l.push("Полученный результат: "+r);if(r===d[i][1])l.push("Результаты совпадают.");else{l.push("error: результаты не совпадают.");p('Проверка задания');g(false);return}};l.push("Все результаты совпадают!");p('Проверка задания');g(true)}else{l.push("error: calculateExpenses не является фунецией!");p('Проверка задания');g(false)}};

LessonsData={
"lesson1110":{theory:`<div><h1>Пристегните ремни</h1><p>Вы только успели зайти в офис, как получили письмо от Кекса с пометкой «срочно».</p><blockquote><p>Мяу! Я хочу поехать в отпуск. Говорят, в Иркутске водится вкусный омуль, питерская корюшка мне совсем приелась.</p><p>Посчитай сколько бонусных воздушных миль я смогу получить с перелёта компанией «Кекс7». Моё чутье охотника за скидками подсказывает, что тут есть, чем поживиться.</p><p>Расстояние до Иркутска 4125 км. Количество миль равно 25% от этого расстояния.</p><p>Жду результата!</p></blockquote><p>Для начала проясним, что такое «воздушные мили». Это такие бонусы от авиакомпаний, которые можно накапливать после каждого перелёта, а затем своими милями «оплатить» перелёт в какой-нибудь город. Бонусные мили начисляются по-разному. В «Кекс7», как мы уже узнали, бонусы — процент от расстояния перелёта.</p><p>В нашем коде расстояние хранится в переменной <code>distance</code>, а процент уже переведён в дробное число и хранится в переменной <code>percent</code>.</p><p>Этих значений достаточно, чтобы получить нужное количество миль: умножим расстояние на процент.</p></div>`,html:``,css:``,hidden:``,js:`var percent = 0.25;\nvar distance = 4125;\n`,tasks:[{message:"Посчитайте количество миль по формуле <code class=keyvalue>distance <code class='keyword'>*</code> percent</code> и запишите результат в переменную <code class='keyvalue'>miles</code>",check:(o)=>o&&o.miles&&~getJ().search(/(var|let)miles=(distance\*percent|percent\*distance)/)},{message:"Выведите результат в консоль: <code>console.log(<code class='keytext'>'За полёт в Иркутск получим '</code> <code class='keyword'>+</code> miles <code class='keyword'>+</code> <code class='keytext'>' миль'</code>)</code>;",check:()=>~getJ().search(/(var|let)miles=\S*console\.log\(('|"|`)ЗаполётвИркутскполучим\2\+miles\+('|"|`)миль\3\)/)}],blocked:"4",editorOff:"8"},
"lesson1111":{theory:`<div><h1>Дальний перелёт</h1><p>Вы не первый день работаете с Кексом и знаете его шальной характер. Сегодня он летит в Иркутск, а завтра захочет куда-нибудь ещё.</p><p>Давайте подстрахуемся и улучшим нашу программу, чтобы она учитывала условие для дальних перелётов.</p><p>Если расстояние больше <code>10500</code> км, то количество начисленных миль составляет <code>35%</code> от дальности полёта, а не <code>25%</code>, как было изначально.</p></div>`,html:``,css:``,hidden:``,js:`var percent = 0.25;\nvar distance = 4125;\n\nvar miles = distance * percent;\n\nconsole.log('За полёт в Иркутск получим ' + miles + ' миль');`,tasks:[{message:"После объявления переменной <code class='keyvalue'>distance</code> добавьте проверку, что эта переменная больше <code class='keytext'>10500</code>",check:()=>~getJ().search(/distance=\S*if\((distance>10500|10500<distance)\)\{\S*\}/)},{message:"Если проверка выполняется, измените значение переменной <code class='keyvalue'>percent</code> на <code class='keytext'>0.35</code>",check:()=>~getJ().search(/distance=\S*if\((distance>10500|10500<distance)\)\{\S*percent=(0\.35|\.35)\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1112":{theory:`<div><h1>Идём на второй круг</h1><blockquote><p>Мяу! Спасибо за расчёт!</p><p>Когда вернусь, хочу ещё слетать на Камчатку, поесть микижи да на вулканы посмотреть.</p><p>Сколько я накоплю миль? Лететь аж 9 часов, мои страдания должны быть вознаграждены!</p></blockquote><p>Ваше чутьё вас не подвело! Кекс задумал ещё одно путешествие, а у вас всё готово: формула есть, условие для дальних перелётов учтено.</p><p>Добавим расчёт миль для полёта на Камчатку.</p><p>Для этого нам придётся повторить все шаги вычислений для первого путешествия. Алгоритм тот же, только расстояние другое, а может и проценты. Проверим!</p></div>`,html:``,css:``,hidden:``,js:`var percent = 0.25;\nvar distance = 4125;\n\nif (distance > 10500) {\n    percent = 0.35;\n}\n\nvar miles = distance * percent;\n\nconsole.log('За полёт в Иркутск получим ' + miles + ' миль');\n`,tasks:[{message:"Скопируйте весь написанный ранее код и вставьте в редактор после существующего кода.",check:()=>~getJ().search(/varpercent=\S*vardistance=\S*if\S*percent=\S*varmiles=\S*console\.log\S*distance=\S*if\S*miles=\S*console\.log/)},{message:"Второе сообщение в консоли измените на <code class='keytext'>'За полёт на Камчатку получим ' <code class='keyword'>+</code> <code class='keyvalue'>miles</code> <code class='keyword'>+</code> ' миль'</code>",check:()=>~getJ().search(/console\.log\(('|"|`)ЗаполётвИркутскполучим\1\+miles\+('|"|`)миль\2\)\S*console\.log\(('|"|`)ЗаполётнаКамчаткуполучим\3\+miles\+('|"|`)миль\4\)/)},{message:"Второй переменной <code class='keyvalue'>distance</code> задайте значение <code class='keytext'>11000</code>",check:()=>~getJ().search(/distance=\S*distance=11000/)}],blocked:"4",editorOff:"8"},
"lesson1113":{theory:`<div><h1>Функция-помощник</h1><p>Вы уже заметили проблему?</p><p>Программа работает, мили считаются, но что будет, если Кекс пойдёт вразнос и решит слетать ещё в десяток городов? Нам постоянно придётся копировать одну часть кода, менять расстояние, считать, а ещё каждый раз заново объявлять одни и те же переменные, что нарушает правила языка. Мы, конечно, справимся с поставленной задачей, но потратим много времени да и код разрастётся до сотни строк.</p><p>Есть ли более удобный и грамотный способ сделать вычисления без копирования? Есть! Написать <strong>функцию</strong>.</p><p>Функция — кусок кода, который можно написать один раз, а затем многократно использовать. Функция не просто содержит в себе значение, как переменная, а выполняет какое-то действие и решает какую-то задачу: считает, сравнивает, ищет. Например, наша функция будет вычислять накопленные мили с перелёта.</p><p>Но сначала посмотрим, из чего состоят функции и как они объявляются (создаются) в коде.</p><pre>var functionName = function () {\n  // Действия, которые выполняет функция или «тело функции»\n};\n</pre><p><code>functionName</code> — имя переменной, которая содержит в себе функцию. По этому имени мы сможем обращаться к функции и использовать её много раз. Давайте считать, что название переменной это и есть название функции.</p><p>Есть и другие способы создания функций, о них мы поговорим позже, в других курсах.</p><p>Функции создаются не сложнее условий или циклов. Используем ключевое слово <code>function</code>, дальше добавляем круглые скобки. В фигурных скобках находятся действия, которые функция будет делать, каждый раз, как мы к ней обратимся. Помните, как в циклах? Там код внутри <code>{ }</code> называется «телом цикла», а здесь «телом функции».</p><p>Напишем функцию <code>calculateMiles</code> для расчёта миль.</p><p><span>Кстати,</span> обратите внимание на название <code>calculateMiles</code>. Функция буквально <i>вычисляет мили</i>, то есть <i>что-то делает</i>. Это общепринятое правило именования — название функции должно содержать глагол. Так разработчикам удобней ориентироваться в своём и даже чужом коде. Может быть функцию написал ваш коллега и вы понятия не имеете, что там внутри. Вам достаточно будет посмотреть на имя функции, чтобы примерно представить, для чего она предназначена.</p></div>`,html:``,css:``,hidden:``,js:`var percent = 0.25;\nvar distance = 4125;\n\nif (distance > 10500) {\n    percent = 0.35;\n}\n\nvar miles = distance * percent;\nconsole.log('За полёт в Иркутск получим ' + miles + ' миль');\n\n\nvar percent = 0.25;\nvar distance = 11000;\n\nif (distance > 10500) {\n    percent = 0.35;\n}\n\nvar miles = distance * percent;\n\nconsole.log('За полёт на Камчатку получим ' + miles + ' миль');\n`,tasks:[{message:"Удалите весь код расчёта миль второго перелёта <code class='keytext'>(переменные, условие и вывод в консоль)</code>.",check:()=>!~getJ().search(/console\.log\S*(distance|percent|if|console\.log)/)},{message:"В конец программы добавьте объявление функции для подсчёта миль: <code>var calculateMiles = function () { };</code>",check:(o)=>o&&typeof o.calculateMiles==='function'},{message:"Перенесите весь оставшийся код с расчётом миль в тело функции <code>calculateMiles</code>",check:(o)=>~getF(o.calculateMiles).search(/(var|let)distance\S*if\S*miles=\S*console\.log/)}],blocked:"4",editorOff:"8"},
"lesson1114":{theory:`<div><h1>Функция, я вызываю тебя!</h1><p>Функция готова, а дальше-то что? Как вычислить количество миль?</p><p>Чтобы функция начала свою работу, её надо вызвать. Для этого нам и пригодится имя функции. Именно по нему мы обратимся к нашей функции и попросим её выполнить свой код.</p><p>Если мы просто выведем функцию <code>console.log(functionName)</code>, то увидим в консоли весь код этой функции примерно в таком же виде, как его и написали, но никаких вычислений не произойдёт.</p><p>Как же тогда запустить код из тела функции?</p><p>Нужно обратиться к функции по её имени, а затем указать круглые скобки.</p><pre>functionName();</pre><p>Обратите внимание, что вызов функции должен идти в коде после её определения.</p><p>Давайте проверим, как работает вызов функции, и вызовем нашу функцию <code>calculateMiles</code>.</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function () {\n    var distance = 4125;\n    var percent = 0.25;\n    if (distance > 10500) {\n        percent = 0.35;\n    }\n    var miles = distance * percent;\n    console.log('За полёт в Иркутск получим ' + miles + ' миль');\n};\n`,tasks:[{message:"Ниже, после объявления функции, выведите её в консоль: <code>console.log(calculateMiles())</code>;",check:(o)=>{if(o.hA)return true;if(~getJ().search(/calculateMiles=function\S*console\.log\(calculateMiles\(\)\)/))o.hA=true;}},{message:"Замените вывод функции в консоль на вызов <code>calculateMiles</code>",check:()=>{var j=getJ();return ~j.search(/calculateMiles=function\S*calculateMiles\(\)/)&&!~j.indexOf('console.log(calculateMiles')}}],blocked:"4",editorOff:"8"},
"lesson1115":{theory:`<div><h1>У меня для тебя параметр</h1><p>Мы написали функцию, вызвали её и посчитали мили, накопленные полётом в Иркутск. А что с полётом на Камчатку? Как посчитать результат второго путешествия?</p><p>Тут пригодится очередная фишка функций.</p><p>Мы можем записать хоть десять вызовов функции <code>calculateMiles()</code>, результат будет одинаковым, потому что внутри функции находятся переменные с фиксированными значениями, подходящими только для полёта в Иркутск, то есть <i>только для одного случая</i>. Чтобы сделать функцию действительно универсальной, надо использовать <b>параметры</b>.</p><p>Параметры — значения, которые получает функция. С их помощью мы можем узнать результат её работы для конкретных случаев. Чтобы функция работала с параметрами, их надо как-то передать и дать им названия.</p><p><b>Задаём параметры.</b> В момент объявления функции, в круглых скобках самой функции, параметру задаётся имя. Этот параметр начинает вести себя, как переменная и его можно использовать в коде функции. Если их несколько, параметры записываются через запятую.</p><pre>var functionName = function (parameterFirstName, parameterSecondName) {\n  ...\n};\n</pre><p><b>Передаём аргументы.</b> Аргументы передаются в круглых скобках при вызове функции.</p><pre>functionName(parameterFirst, parameterSecond);\n</pre><p class="info info--gray"><span class="info__heading">Кстати,</span> почему мы заговорили о каких-то аргументах? Речь же шла о параметрах. Дело в том, что параметрами называются значения, которые мы задаём <i>в момент объявления функции</i>. Их же мы используем и в теле функции. А аргументами называют значения, которые мы передаём в функцию <i>при её вызове</i>.</p><p>Разберём параметры на примере. Объявим функцию показа времени в консоли.</p><pre>var showTime = function (time) {\n  console.log('Текущее время: ' + time);\n};\n\nshowTime(3);\nshowTime(16);\n</pre><p>1. Задаём функции параметр с именем <code>time</code>.</p><pre>var showTime = function (<b>time</b>) {\n  ...\n};\n</pre><p>2. Используем параметр внутри функции, как обычную переменную.</p><pre>var showTime = function (time) {\n  console.log('Текущее время: ' + <b>time</b>);\n};\n</pre><p>3. Передаём в функцию значение аргумента <code>time</code> и получаем разный результат в зависимости от этого.</p><pre>showTime(<b>3</b>);  // Результат: 'Текущее время: <b>3</b>'\n\nshowTime(<b>16</b>); // Результат: 'Текущее время: <b>16</b>'\n</pre><p>Давайте улучшим наш код, наконец, сделаем функцию <code>calculateMiles</code> универсальной и посчитаем накопленные мили за второй полёт.</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function () {\n    var distance = 4125;\n    var percent = 0.25;\n    if (distance > 10500) {\n        percent = 0.35;\n    }\n    var miles = distance * percent;\n    console.log('За полёт в Иркутск получим ' + miles + ' миль');\n};\n\ncalculateMiles();\n`,tasks:[{message:`Измените сообщение <code class='keytext'>'За полёт в Иркутск получим '</code> на более универсальное: <code class='keytext'>'За полёт получим '</code>`,check:(o)=>~getF(o.calculateMiles).search(/console\.log\(('|"|`)Заполётполучим\1\S*\)/)},{message:"Добавьте функции параметр <code class='keytext'>distance</code>",check:(o)=>o&&~getF(o.calculateMiles).search(/function\(distance\)/)},{message:"В вызове функции задайте аргумент <code class='keytext'>4125</code>",check:()=>~getJ().search(/calculateMiles\(4125\)/)},{message:"Внутри тела функции удалите переменную <code class='keyvalue'>distance</code>",check:(o)=>o&&!~getF(o.calculateMiles).search(/(var|let)distance/)},{message:"В конце программы добавьте ещё один вызов <code>calculateMiles</code> с аргументом <code class='keytext'>11000</code>",check:()=>~getJ().search(/calculateMiles\(11000\)/)}],blocked:"4",editorOff:"8"},
"lesson1116":{theory:`<div><h1>Порядок параметров</h1><p>Отвлечёмся ненадолго от подсчёта миль. С использованием аргументов есть один нюанс — передавать их надо в том же порядке, в котором объявлены параметры функции.</p><p>Рассмотрим на примере. У нас есть функция <code>getFavoriteBook</code>, которая выводит в консоль сообщение о любимой книге пользователя. У неё два параметра: <code>userName</code> (имя пользователя) и <code>bookName</code> (название книги).</p><pre>var getFavoriteBook = function (userName, bookName) {\n  console.log('Меня зовут ' + userName + '. Моя любимая книга: ' + bookName);\n}\n</pre><p>Допустим нашего пользователя зовут Семён, а его любимая книга «Ёжик в тумане». Передадим эти аргументы в функцию:</p><pre>getFavoriteBook('Ёжик в тумане', 'Семён');\n\n// В консоль выведется\n// 'Меня зовут Ёжик в тумане. Моя любимая книга: Семён'\n</pre><p>Кажется что-то пошло не так. Почему мы получили такой результат? Мы ведь передали имя пользователя и название книги — всё, как положено.</p><p>Всё дело в порядке аргументов. Параметры работают, как переменные — значение из аргумента записывается в параметр, а потом используется внутри функции по имени. В нашем случае всё так и произошло. Первый параметр функции — <code>userName</code>, первый аргумент — <code>'Ёжик в тумане'</code>. Этот аргумент и записался в параметр <code>userName</code>, а аргумент <code>'Семён'</code> стал параметром <code>bookName</code>. Вы, конечно, знаете, где тут имя, а где название книги, а вот JavaScript нет. Он всё понимает буквально: что первым передали, то и стало первым параметром. Потому что порядок аргументов соответствует порядку параметров в функции. У нас параметры записаны в таком порядке: <code>userName, bookName</code>. Значит, первым должно быть передано имя пользователя, а затем название книги. И никак иначе.</p><pre>getFavoriteBook('Семён', 'Ёжик в тумане');\n\n// В консоль выведется\n// 'Меня зовут Семён. Моя любимая книга: Ёжик в тумане'\n</pre><p>Видите, мы передали аргументы в правильном порядке и сообщение стало правильным.</p><p>Сейчас мы работали со строками, ещё веселей обстоит ситуация с числами. Если в функции есть параметры разных типов, например, числа и строки, и аргументы переданы в неправильном порядке, могут получиться неожиданные результаты. Например, может произойти конкатенация и число сложится со строкой, результатом будет строка. Или вы можете получить значение <code>NaN</code>, что означает «not a number». Оно говорит о том, что невозможно найти результат математической операции.</p><p>Кстати, если совсем не передать параметр, его значение будет <code>undefined</code> — то есть ничего. Здесь результат тоже может быть неожиданным. Будьте внимательны.</p><p>Потренируемся вызывать функцию с разным порядком аргументов.</p></div>`,html:``,css:``,hidden:``,js:`var showGreeting = function (name, age) {\n    console.log('Привет! Меня зовут ' + name + '. Мне ' + age + ' лет.');\n};\n`,tasks:[{message:`Вызовите функцию <code>showGreeting</code> разными способами. Каждый вызов записывайте на новой строке. Вызовите функцию <code class='keytext'>без аргументов</code>.`,check:()=>~getJ().indexOf('showGreeting()')},{message:"Вызовите функцию c аргументом <code class='keytext'>5</code>",check:()=>~getJ().indexOf('showGreeting(5)')},{message:"Вызовите функцию c аргументами <code class='keytext'>5</code> и <code class='keytext'>'Кекс'</code>",check:()=>~getJ().search(/showGreeting\(5,('|"|`)Кекс\1\)/)},{message:"Вызовите функцию c аргументами <code class='keytext'>'Кекс'</code> и <code class='keytext'>5</code>",check:()=>~getJ().search(/showGreeting\(('|"|`)Кекс\1,5\)/)}],blocked:"4",editorOff:"8"},
"lesson1117":{theory:`<div><h1>Возвращение из функции</h1><p>А что, если нам нужно получить значение из функции и как-то дальше его использовать?</p><p>Функции умеют возвращать результат своей работы.</p><p>Что значит <b>возвращать</b>? Функция может выполнить код и отдать результат своих действий. Этот результат подставится в то место, где мы вызвали функцию.</p><p>Для этого используется оператор <code>return</code>. После оператора надо указать возвращаемое значение. Тогда функция дойдёт до строки с <code>return</code>, вернёт результат своей работы и закончит выполнение кода, иными словами произойдёт выход из функции.</p><p>Объявим функцию, которая будет возвращать сумму числа 2 и ещё какого-то числа.</p><pre>var increaseByTwo = function (number) {\n  var sum = 2 + number;\n  return sum;\n};\n\nincreaseByTwo(1); // Функция вернёт 3\nincreaseByTwo(2); // Функция вернёт 4\nincreaseByTwo(4); // Функция вернёт 6\n</pre><p><code>increaseByTwo</code> сложит значения и вернёт полученный результат.</p><p>Несколько вещей, которые нужно знать:</p><ul><li>Код, написанный на новой строке после <code>return</code>, не выполняется.</li><li>Функция не может вернуть сразу много значений, она возвращает только один результат.</li><li>Если внутри функции нет <code>return</code> или после <code>return</code> не указано возвращаемое значение, функция вернёт <code>undefined</code>, иными словами, ничего.</li></ul><p>В JavaScript есть встроенные функции языка, которые возвращают результат своей работы. Таких функций очень много, вот несколько из них:</p><ul><li><code>Math.ceil(number)</code> — принимает на вход число и округляет его до целого в большую сторону.</li><li><code>Math.floor(number)</code> — делает то же самое, только округляет в меньшую сторону.</li><li><code>Math.round(number)</code> — округляет число до ближайшего целого значения.</li></ul><p>Округлим количество миль в нашей функции <code>calculateMiles</code>. Где вы видели, чтобы начислялось дробное число миль?</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance) {\n    var percent = 0.25;\n    if (distance > 10500) {\n        percent = 0.35;\n    }\n    var miles = distance * percent;\n    console.log('За полёт получим ' + miles + ' миль');\n};\n\ncalculateMiles(4125);\ncalculateMiles(11000);\n`,tasks:[{message:`Отредактируйте значение переменной <code class='keyvalue'>miles</code>, округлив результат вычислений <code>Math.floor(<code class='keytext'>distance <code class='keyword'>*</code> percent</code>)</code>;`,check:(o)=>o&&~getF(o.calculateMiles).indexOf('miles=Math.floor(distance*percent')},{message:"Внутри функции замените вывод сообщения в консоль на <code class='keyword'>return <code class='keyvalue'>miles</code>;</code>",check:(o)=>{var f=getF(o.calculateMiles);return !~f.indexOf('console.log')&&~f.indexOf('returnmiles')}},{message:`Замените первый вызов функции на сообщение в консоль <code class='keytext'>'За перелёт в Иркутск получим ' <code class='keyword'>+</code> <code>calculateMiles(<code class='keytext'>4125</code>)</code> <code class='keyword'>+</code> ' миль'</code>`,check:()=>~getJ().search(/console\.log\(('|"|`)ЗаперелётвИркутскполучим\1\+calculateMiles\(4125\)\+('|"|`)миль\2\)/)},{message:`Второй вызов функции замените на сообщение в консоль <code class='keytext'>'За перелёт на Камчатку получим ' <code class='keyword'>+</code> <code>calculateMiles(<code class='keytext'>11000</code>)</code> <code class='keyword'>+</code> ' миль'</code>`,check:()=>~getJ().search(/console\.log\(('|"|`)ЗаперелётнаКамчаткуполучим\1\+calculateMiles\(11000\)\+('|"|`)миль\2\)/)}],blocked:"4",editorOff:"8"},
"lesson1118":{theory:`<section><h1>Конспект «Функции». 1 часть</h1><p>Пример функции.</p><pre>var calculateSum = function (numberFirst, numberSecond) {\n    var sum = numberFirst + numberSecond;\n    return sum;\n};\n\ncalculateSum(); // Вернёт NaN\ncalculateSum(2); // Вернёт NaN\ncalculateSum(2, 5); // Вернёт 7\ncalculateSum(9, 5); // Вернёт 14\n</pre><p>В этом примере:</p><ul><li><code>calculateSum</code> — имя, по которому можно обратиться к функции.</li><li><code>numberFirst</code>, <code>numberSecond</code> — параметры функции.</li><li><code>return sum;</code> — место кода, где происходит возвращение <code>sum</code> и выход из функции.</li><li><code>calculateSum(<b>2</b>, <b>5</b>);</code> — аргументы, которые передаются в функции при вызове. Порядок аргументов такой же, как у параметров функции. Первый аргумент <code>2</code> записывается в первый параметр <code>numberFirst</code>, аргумент <code>5</code> записывается в параметр <code>numberSecond</code>. Важно соблюдать порядок параметров при вызове функции, чтобы избежать неочевидных ошибок.</li></ul><br></section>`,html:``,css:``,hidden:``,js:``,tasks:[{message:`Создайте функцию <code>getCirclePerimeter</code>, которая принимает параметром <code class='keytext'>радиус</code> круга и возвращает его <code class='keytext'>периметр</code>. Возвращать округлённое с помощью <code>Math.round()</code> значение.`,check:(o)=>{var f=o.getCirclePerimeter;if(typeof f==='function'){var d=[{r:3,p:19},{r:5,p:31},{r:10,p:63}];for(var i=0;i<d.length;i++){if(f(d[i].r)!=d[i].p)return false};if(!o.hA){Academy.vars.hA=true;var l=Academy.vars.log;for(var i=0;i<d.length;i++){l.push('Радиус: '+d[i].r+', ожидаю периметр: '+d[i].p);l.push('Успех!');};l.push('Все проверки успешны!');printLog('Проверка задания');};return true}}}],blocked:"4",editorOff:"9"},
"lesson1119":{theory:`<div><h1>Седьмая программа: «От зарплаты до зарплаты»</h1><p>Босс полюбил калькулятор миль и только поэтому доверил вам автоматизировать самое сокровенное — бухгалтерские расчёты!</p><p>Ему понадобилось нанять несколько новых сотрудников, так как местных бездельников уже не хватает. Бухгалтерия выделила бюджет на зарплаты, но он включает налоги, а в вакансии зарплату нужно указать без налогов. Впрочем, вот техническое задание:</p><blockquote><p>Мяу! Мне нужна программа, которая от «грязной» зарплаты (зарплата до вычета налогов) посчитает примерную «чистую» зарплату (которая выдаётся на лапы).</p><p>Оформи программу в виде функции <code>calculateSalary</code> c одним параметром — величиной грязной зарплаты. Функция должна возвращать чистую зарплату.</p><p>Большая точность мне не нужна, просто считаем, что 35% величины грязной зарплаты составляют налоги, а если грязная зарплата больше или равна 100 тысячам, то налоги составляют уже 45%.</p></blockquote><p>Эту программу будет тестировать сам Кекс. Он будет вызывать вашу функцию (<i>вы же напишете функцию?</i>) с разными аргументами и проверять результат.</p></div>`,html:``,css:``,hidden:``,js:`var calculateSalary = function () {\n\n};`,tasks:[{message:`<button onclick="fH1()">Проверить!</button><h3 class='test-header'>Техническое задание</h3><div class='test-container'><p><code class='keyword'>Мяу!</code> Мне нужна программа, которая от «грязной» зарплаты (зарплата до вычета налогов) посчитает примерную «чистую» зарплату (которая выдаётся на лапы).</p><p>Оформи программу в виде функции <code>calculateSalary</code> c одним параметром — величиной грязной зарплаты. Функция должна возвращать чистую зарплату.</p><p>Большая точность мне не нужна, просто считаем, что <code class='keyvalue'>35%</code> величины грязной зарплаты составляют налоги, а если грязная зарплата <code class='keytext'>больше или равна 100</code> тысячам, то налоги составляют уже <code class='keyvalue'>45%</code>.</p></div><p class='task-press-button'>Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1120":{theory:`<div><h1>Деловая поездка</h1><p>От Кекса пришла новая задача. Босс вошёл во вкус и хочет копить мили и на рабочих поездках.</p><p>В командировки Кекс летает другим перевозчиком — «Кексофлотом». У компании хитрая система накопления миль. Пассажиры бизнес-класса получают <code>22%</code> от всего пути, а пассажиры эконома только <code>18%</code>. При этом, если расстояние превышает <code>3500 км</code>, то процент увеличивается ещё на <code>15%</code>.</p><p>Для новой задачи создадим новую функцию и закрепим уже полученные знания.</p><p>Название прошлой функции для расчёта миль <code>calculateMiles</code> точно описывает цель этой функции и подходит для новой задачи. Оставим его.</p><p>Новая функция будет принимать на вход два параметра: расстояние и какой-то знак, который укажет программе класс перелёта. С расстоянием всё просто — назовём параметр <code>distance</code>.</p><p>А что делать со вторым параметром?</p><p>В нашем случае для второго параметра достаточно только два варианта — бизнес-класс или нет. Потому что процент возрастает только для бизнес-класса, и нам важно не упустить именно этот момент и начислить дополнительные проценты. В таком случае подойдёт параметр, который будет содержать только булевы значения (<code>true</code> и <code>false</code>). Пускай <code>true</code> обозначает бизнес-класс, а <code>false</code> всё остальное.</p><p>Осталось определиться с названием второго параметра. Подобные значения называют флагами, и называют их особым образом. Например, в нашем случае, подойдёт название <code>isBusinessClass</code>. То есть переменная как бы задаёт вопрос своему содержимому «Сейчас у нас бизнес-класс?», а содержимое отвечает на этот вопрос «да» (<code>true</code>) или «нет» (<code>false</code>).</p><p>Начнём создавать функцию для новой задачи от Босса.</p></div>`,html:``,css:``,hidden:``,js:``,tasks:[{message:"Объявите функцию <code>calculateMiles</code> с двумя параметрами: <code class='keytext'>distance</code> и <code class='keytext'>isBusinessClass</code>",check:(o)=>~getF(o.calculateMiles).search(/function\(distance,isBusinessClass\)\{\S*\}/)},{message:"Добавьте проверку класса перелёта. Если летим бизнесом, функция возвращает <code class='keyvalue'>distance</code> <code class='keyword'>*</code> <code class='keytext'>0.22</code> миль.",check:(o)=>{var f=o.calculateMiles;if(typeof f==='function')return f(100,true)===22&&f(1000,true)===220&&f(1000,false)!==220&&f(150,true)===33}},{message:"Если класс эконом, то вернём <code class='keyvalue'>distance</code> <code class='keyword'>*</code> <code class='keytext'>0.18</code> миль.",check:(o)=>{var f=o.calculateMiles;if(typeof f==='function')return f(100,false)===18&&f(1000,false)===180&&f(1000,true)===220&&f(150,false)===27}}],blocked:"4",editorOff:"8"},
"lesson1121":{theory:`<div><h1>Пиши, упрощай</h1><p>Помните, мы говорили о том, что функция может возвращать результат своей работы и подставляли вызов функции сразу в выражение? Примерно так:</p><pre>console.log('За перелёт получим ' + calculateMiles(4125) + ' миль');\n</pre><p>А сейчас давайте напишем код более грамотно.</p><p>Раз функция возвращает значение, которое можно использовать где-то ещё (подставить в строку, добавить в математическую операцию), почему бы не записать результат работы этой функции в переменную и использовать именно её? Так код станет удобней читать и править.</p><p>Представьте большую программу с кодом на сотни строк. Вы несколько раз используете вызов функции внутри каких-то выражений и программа работает. А потом вы понимаете, что надо вызвать эту же функцию с другими аргументами, и вам или вашему коллеге приходится искать по всему коду эти вызовы функции и их исправлять. А если вы что-то пропустите, программа будет работать некорректно.</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n    if (isBusinessClass) {\n        return distance * 0.22;\n    } else {\n        return distance * 0.18;\n    }\n};\n`,tasks:[{message:`После определения функции, создайте переменную <code class='keyvalue'>milesEconom</code>, которая равна результату выражения <code>calculateMiles(<code class='keytext'>3000, false</code>)</code>;`,check:(o)=>o.milesEconom===o.calculateMiles(3000,false)},{message:`Создайте ещё одну переменную <code class='keyvalue'>milesBusiness</code>, которая равна результату <code>calculateMiles(<code class='keytext'>3000, true</code>)</code>;`,check:(o)=>o.milesBusiness===o.calculateMiles(3000,true)},{message:"Выведите в консоль сообщение <code class='keytext'>'Эконом-классом Кексофлота накопишь ' <code class='keyword'>+</code> <code class='keyvalue'>milesEconom</code> <code class='keyword'>+</code> ' миль'</code>",check:(o)=>~o.log.indexOf('Эконом-классом Кексофлота накопишь 540 миль')},{message:"Ниже выведите в консоль сообщение <code class='keytext'>'Бизнес-классом Кексофлота накопишь ' <code class='keyword'>+</code> <code class='keyvalue'>milesBusiness</code> <code class='keyword'>+</code> ' миль'</code>",check:(o)=>~o.log.indexOf('Бизнес-классом Кексофлота накопишь 660 миль')}],blocked:"4",editorOff:"8"},
"lesson1122":{theory:`<div><h1>Отбрось всё лишнее</h1><p>Количество бонусных миль в Кексофлоте зависит и от класса, и от расстояния. Чтобы завершить программу, можно в каждую ветку проверки на класс перелёта добавить проверки на расстояние. Но такой вариант выглядит громоздко.</p><p>Логика расчёта процентов довольно сложная, а хочется описать её максимально просто и изящно. Поэтому перед добавлением нового условия давайте изменим структуру существующего кода, но так, чтобы он работал как прежде. То есть займёмся рефакторингом.</p><p>Посмотрим на код <code>calculateMiles</code>. Внутри у нас два выхода из функции:</p><pre>var calculateMiles = function (distance, isBusinessClass) {\n  if (isBusinessClass) {\n    <mark>return …;</mark>\n  } else {\n    <mark>return …;</mark>\n  }\n};\n</pre><p>Получается, если класс эконом, программа в любом случае не зайдёт внутрь первой ветки условия и пойдёт дальше. Поэтому ветка <code>else</code> здесь необязательна, её можно опустить.</p><pre>var calculateMiles = function (distance, isBusinessClass) {\n  if (isBusinessClass) {\n    <mark>return …;</mark>\n  }\n  <mark>return …;</mark>\n};\n</pre><div><span>Кстати,</span><p>Разработчики рефакторят свой код для того, чтобы он был понятен коллегам и самому автору через какое-то время, легко поддерживался, не содержал в себе повторов, огромных сложных конструкций и так далее. Здесь, как в школе: сначала пишем в черновик, пробуем, зачёркиваем, пробуем снова, пока не придём к решению, а потом аккуратно выводим в чистовик.</p><p>При этом рефакторингом занимаются все, даже самые крутые рок-звёзды из мира разработки.</p></div></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n  if (isBusinessClass) {\n    return distance * 0.22;\n  } else {\n    return distance * 0.18;\n  }\n  // Перенесите код сюда\n};\n\nvar milesEconom = calculateMiles(3000, false);\nvar milesBusiness = calculateMiles(3000, true);\n\nconsole.log('Эконом-классом Кексофлота накопишь ' + milesEconom + ' миль');\nconsole.log('Бизнес-классом Кексофлота накопишь ' + milesBusiness + ' миль');\n`,tasks:[{message:"Перенесите код из блока <code class='keyword'>else</code> вниз, за оператор условия.",check:(o)=>{if(o.hA)return true;if(!~getF(o.calculateMiles).search(/else\{\S*\w+\S*\}/))Academy.vars.hA=true}},{message:"Удалите блок <code class='keyword'>else { }</code>",check:(o)=>!~getF(o.calculateMiles).indexOf('else')}],blocked:"4",editorOff:"8"},
"lesson1123":{theory:`<div><h1>Сделай мне красиво</h1><p>Первый шаг рефакторинга сделан. Самое главное, что функция работает так же, как и до рефакторинга. Значит можно двигаться дальше. Смотрите, в функции дублируется код для расчёта миль. Выражения отличаются только значением процентов:</p><pre>var calculateMiles = function (distance, isBusinessClass) {\n  if (isBusinessClass) {\n    return <mark>distance * 0.22</mark>;\n  }\n  return <mark>distance * 0.18</mark>;\n};</pre><p>Давайте взглянем на решение с другой стороны: что если в условиях считать процент, а не дублировать расчёт миль? Мы можем переформулировать задачу так, что базовый процент равен 18, а если класс перелёта бизнес, то процент увеличивается на 4. Затем в конце функции один раз считаем и возвращаем мили.</p><pre>var calculateMiles = function (distance, isBusinessClass) {\n  <mark>// Вводим процент</mark>\n  if (isBusinessClass) {\n    <mark>// Изменяем процент</mark>\n  }\n  <mark>// Рассчитываем и возвращаем мили</mark>\n};\n</pre><p>Второй шаг рефакторинга такой: создаём переменную <code>percent</code>, которая будет меняться в зависимости от условия, а возвращать из функции будем результат выражения <code>distance * percent</code>.</p><p>Так код станет понятней, да и точка выхода из функции будет только одна. Функцию станет проще читать, потому что условия для изменения процента теперь можно делать не вложенными, а последовательными.</p><p><span>Кстати,</span> точка выхода из функции — место, где функция прекращает свою работу и отдаёт результат наружу.</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n    if (isBusinessClass) {\n        return distance * 0.22;\n    }\n    return distance * 0.18;\n};\n\nvar milesEconom = calculateMiles(3000, false);\nvar milesBusiness = calculateMiles(3000, true);\n\nconsole.log('Эконом-классом Кексфолота накопишь ' + milesEconom + ' миль');\nconsole.log('Бизнес-классом Кексфолота накопишь ' + milesBusiness + ' миль');\n`,tasks:[{message:`В теле функции, в самом начале, на строчке <code class='keytext'>2</code>, создайте переменную <code class='keyvalue'>percent</code>, равную <code class='keytext'>0.18</code>`,check:(o)=>~getF(o.calculateMiles).search(/(var|let)percent=0?\.18\S*if\(isBusinessClass\)/)},{message:"Внутри условия вместо расчёта миль увеличивайте переменную <code class='keyvalue'>percent</code> на <code class='keytext'>0.04</code>",check:(o)=>~getF(o.calculateMiles).search(/if\(isBusinessClass\)\{\S*percent(\+=0?\.04|=percent\+0?\.04|=0?\.04\+percent)\S*\}/)},{message:"Замените выражение, которое возвращает функция на <code class='keyvalue'>distance <code class='keyword'>*</code> percent</code>",check:(o)=>~getF(o.calculateMiles).search(/return(distance\*percent|percent\*distance)/)}],blocked:"4",editorOff:"8"},
"lesson1124":{theory:`<div><h1>Просто добавь процент</h1><p>Второй шаг рефакторинга позади. В консоли всё те же результаты: 660 миль и 540 миль. Значит логику мы не испортили и рефакторинг прошёл успешно.</p><p>Благодаря тому, что мы отрефакторили наш код, вписать в функцию ещё один <code>if</code> совсем несложно:</p><pre>var calculateMiles = function (distance, isBusinessClass) {\n  var percent = 0.18;\n  if (isBusinessClass) {\n    percent += 0.04;\n  }\n  if (distance &gt; 3500) {\n    <mark>// Ещё раз изменяем процент</mark>\n  }\n  return distance * percent;\n};\n</pre><p>А что будет, если мы не введём переменную процента и не сократим количество выходов из функции?</p><p>Код <code>calculateMiles</code> будет выглядеть очень страшно. Как-то так:</p><pre>var calculateMiles = function (distance, isBusinessClass) {\n  if (isBusinessClass &amp;&amp; distance &gt; 3500) {\n    return distance * 0.37;\n  }\n  if (isBusinessClass &amp;&amp; distance &lt;= 3500) {\n    return distance * 0.22;\n  }\n  if (!isBusinessClass &amp;&amp; distance &gt; 3500) {\n    return distance * 0.33;\n  }\n  return distance * 0.18;\n};\n</pre><p>Или не менее страшно. Вот так:</p><pre>var calculateMiles = function (distance, isBusinessClass) {\n  if (isBusinessClass) {\n    if (distance &gt; 3500) {\n      return distance * 0.37;\n    } else {\n      return distance * 0.22;\n    }\n  } else {\n    if (distance &gt; 3500) {\n      return distance * 0.33;\n    } else {\n      return distance * 0.18;\n    }\n  }\n};\n</pre><p>И это только для двух условий, влияющих на расчёт миль. Представьте, каким громоздким станет код, если появится ещё одно или два новых условия расчёта миль (что в реальной практике встречается часто).</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n    var percent = 0.18;\n    if (isBusinessClass) {\n        percent += 0.04;\n    }\n    return distance * percent;\n};\n\nvar milesEconom = calculateMiles(3000, false);\nvar milesBusiness = calculateMiles(3000, true);\n\nconsole.log('Эконом-классом Кексфолота накопишь ' + milesEconom + ' миль');\nconsole.log('Бизнес-классом Кексфолота накопишь ' + milesBusiness + ' миль');\n`,tasks:[{message:`В функции <code>calculateMiles</code> после проверки класса перелёта, добавьте ещё одну проверку. Если расстояние больше <code class='keytext'>3500</code> км, процент увеличивается ещё на <code class='keytext'>0.15</code>`,check:(o)=>~getF(o.calculateMiles).search(/if\(isBusinessClass\)\S*\}\S*if\((distance>3500|3500<distance)\)\{\S*percent(\+=0?\.15|=percent\+0?\.15|=0?\.15\+percent)\S*\}/)},{message:`Увеличьте расстояние в обоих вызовах функции до <code class='keytext'>10000</code>, чтобы убедиться, что количество миль увеличилось.`,check:()=>{var j=getJ();return ~j.indexOf('calculateMiles(10000,false)')&&~j.indexOf('calculateMiles(10000,true)')}}],blocked:"4",editorOff:"8"},
"lesson1125":{theory:`<div><h1>Позови меня тихо по имени</h1><p>Мяу!</p><p>Знаешь, я хоть и деловой кот, но и мне не чужды простые человеческие мечты. Я очень хочу повидать мир, посетить много далёких городов, например, Токио. Там всё, что я люблю: рыба, природа и технологии. Давай-ка выясним, как мне побыстрей обстряпать это дельце?</p><p>Впереди у меня много командировок в два города: в испанскую Валенсию и португальский Лиссабон.</p><p>Полётами в какой из городов я быстрее накоплю мили в Токио? Мне нужно 15000 миль. В Валенсию полечу бизнесом, а вот в Лиссабон придётся тащиться экономом.</p><p>Жду от тебя ответа! До связи!</p></blockquote><p>Мечты должны сбываться, особенно, если это мечты босса!</p><p>Перед нами новая задача и новая программа. Если задуматься, функция подсчёта миль, которую мы написали раньше, нам здесь очень пригодится. Сначала с её помощью мы узнаем сколько миль можно получить с одного перелёта, а затем выясним сколько таких полётов нужно совершить, чтобы накопить <code>15000</code> миль до Токио. Кекс хочет слетать и в другие города, но сначала мы решим задачу на одном примере, а потом легко масштабируем решение и для других расстояний.</p><p>Мы создадим ещё одну функцию, которая будет считать количество полётов, а затем из неё вызовем нашу первую функцию с подсчётом миль и воспользуемся полученным значением.</p><p>Звучит сложней, чем выглядит на самом деле. Хороший код всегда состоит из множества частей, каждая из которых занимается только своей задачей. Как у нас: одна функция считает мили, а другая будет считать полёты. В таком случае очень удобно использовать одну функцию для решения задач другой. Например, чтобы посчитать количество полётов, нам понадобится сначала узнать количество миль, которое Кекс получит за один полёт по направлению. А как это сделать? Вызвать функцию <code>calculateMiles</code>, записать результат в переменную и использовать в дальнейших вычислениях в функции подсчёта полётов.</p><p>Давайте закрепим на практике!</p><p>Создадим функцию <code>calculateFlights</code>. Пока рассчитаем полёты для первого варианта, полёта в Валенсию, расстояние туда составляет <code>3118</code> км. Напишем функцию за несколько шагов, сначала просто протестируем вызов одной функции из другой.</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n    var percent = 0.18;\n    if (isBusinessClass) {\n        percent += 0.04;\n    }\n    if (distance > 3500) {\n        percent += 0.15;\n    }\n    return distance * percent;\n};\n`,tasks:[{message:`После функции <code>calculateMiles</code> объявите функцию <code>calculateFlights</code> c двумя параметрами <code class='keytext'>distance</code> и <code class='keytext'>isBusinessClass</code>`,check:(o)=>~getF(o.calculateFlights).search(/function\(distance,isBusinessClass\)\{\S*\}/)},{message:`Внутри новой функции объявите переменную <code class='keyvalue'>miles</code>, которая равна результату работы функции <code>calculateMiles(<code class='keytext'>distance, isBusinessClass</code>)</code>`,check:(o)=>~getF(o.calculateFlights).search(/(var|let)miles=calculateMiles\(distance,isBusinessClass\)/)},{message:"Затем выведите в консоль значение переменной <code class='keytext'>'Мили за перелёт: '</code> <code class='keyword'>+</code> <code class='keyvalue'>miles</code>",check:(o)=>~getF(o.calculateFlights).search(/(var|let)miles=\S*console\.log\(('|"|`)Милизаперелёт:\2\+miles\)/)},{message:"Внизу, после объявления всех функций, вызовите функцию <code>calculateFlights(<code class='keytext'>3118, true</code>)</code>;",check:()=>~getJ().search(/calculateFlights=\S*calculateFlights\(3118,true\)/)}],blocked:"4",editorOff:"8"},
"lesson1126":{theory:`<div><h1>Вижу цель</h1><p>Теперь, когда мы знаем количество миль за один полёт, ничего не мешает нам узнать, сколько раз придётся слетать по одному маршруту, чтобы заполучить поездку в Токио.</p><p>Добавим для функции <code>calculateFlights</code> ещё один параметр, который мы пока не использовали. Он будет содержать количество необходимых миль. Сейчас это мили до Токио, но вдруг Кекс захочет накопить на полёт ещё куда-нибудь? Достаточно будет поменять значение аргумента и вызвать функцию.</p><p>Раз мы делаем универсальную программу, то имя нового параметра тоже должно быть универсальным. Поэтому название вроде <code>milesToTokyo</code> нам не подойдёт, оно слишком конкретное и не переиспользуемое. Выберем <code>milesTarget</code>. Такое имя подходит лучше, потому что с таким параметром мы сможем посчитать количество полётов хоть до Сиэтла.</p><p>Чтобы получить количество полётов нам нужно разделить <code>milesTarget</code> на мили, накопленные с одного полёта. Обратите внимание, что результат может оказаться не целым числом. Так как речь идёт о полётах, не учитывать дробную часть при округлении неправильно. Например, если необходимо <code>25.2</code> полётов для накопления <code>15000</code> миль, это значит, что в итоге перелётов должно быть <code>26</code>. Иначе мы не доберём совсем немного миль. Поэтому в нашей задаче мы округлим результат вычислений с помощью <code>Math.ceil()</code>.</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n    var percent = 0.18;\n    if (isBusinessClass) {\n        percent += 0.04;\n    }\n    if (distance > 3500) {\n        percent += 0.15;\n    }\n    return distance * percent;\n};\n\nvar calculateFlights = function (distance, isBusinessClass) {\n    var miles = calculateMiles(distance, isBusinessClass);\n    console.log('Мили за перелёт: ' + miles);\n};\n\ncalculateFlights(3118, true);\n`,tasks:[{message:`Заведите в функции <code>calculateFlights</code> третий параметр <code class='keytext'>milesTarget</code> и передайте в вызове функции <code>calculateFlights</code> третий аргумент <code class='keytext'>15000</code>`,check:(o)=>~getJ().search(/calculateFlights=function\(distance,isBusinessClass,milesTarget\)\{\S*\}\S*calculateFlights\(3118,true,15000\)/)},{message:`Внутри функции <code>calculateFlights</code>, после вывода миль в консоль, объявите переменную <code class='keyvalue'>flights</code>, которая равна <code class='keyvalue'>milesTarget <code class='keyword'>/</code> miles</code>`,check:(o)=>{if(o.hA)return true;if(~getF(o.calculateFlights).search(/console\.log\S*(var|let)flights=milesTarget\/miles/))Academy.vars.hA=true}},{message:"Выведите количество полётов в консоль <code class='keytext'>'Количество полётов: '</code> <code class='keyword'>+</code> <code class='keyvalue'>flights</code>",check:(o)=>~getF(o.calculateFlights).search(/(var|let)flights=\S*console\.log\(('|"|`)Количествополётов:\2\+flights\)/)},{message:"Округлите число полётов в большую сторону <code>Math.ceil(<code class='keytext'>milesTarget <code class='keyword'>/</code> miles</code>)</code>",check:(o)=>~getF(o.calculateFlights).search(/flights=Math\.ceil\((milesTarget\/miles|flights)\)/)}],blocked:"4",editorOff:"8"},
"lesson1127":{theory:`<div><h1>Сколько вешать в полётах?</h1><p>Теперь у нас есть функция, которая считает за сколько полётов по одному и тому же маршруту можно накопить необходимое количество миль.</p><p>Чтобы узнать, как Кексу скорее оказаться в Токио, надо сравнить количество полётов по каждому из направлений. Для этого нам нужно вызвать функцию <code>calculateFlights</code> дважды, для полётов в Валенсию и Лиссабон, с одинаковым значением третьего аргумента (<code>15000</code> миль до Токио).</p><p>Теперь, чтобы понять, что выгодней, давайте выясним, сколько раз Кексу нужно смотаться по работе в Лиссабон, чтобы, наконец оказаться на отдыхе в желанном Токио? Расстояние до столицы Португалии <code>3617</code> км.</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n    var percent = 0.18;\n    if (isBusinessClass) {\n        percent += 0.04;\n    }\n    if (distance > 3500) {\n        percent += 0.15;\n    }\n    return distance * percent;\n};\n\nvar calculateFlights = function (distance, isBusinessClass, milesTarget) {\n    var miles = calculateMiles(distance, isBusinessClass);\n    console.log('Мили за перелёт: ' + miles);\n    var flights = Math.ceil(milesTarget / miles);\n    console.log('Количество полётов: ' + flights);\n};\n\ncalculateFlights(3118, true, 15000);\n`,tasks:[{message:"Внутри функции <code>calculateFlights</code> удалите выводы значений в <code class='keytext'>консоль</code>.",check:(o)=>!~getF(o.calculateFlights).indexOf('console.log')},{message:"Верните c помощью <code class='keyword'>return</code> из функции <code>calculateFlights</code> количество полётов.",check:(o)=>~getF(o.calculateFlights).search(/return(flights|Math\.ceil\(milesTarget\/miles\))/)},{message:`Замените вызов функции <code>calculateFlights(<code class='keytext'>3118, true, 15000</code>)</code> на сообщение в консоль <code class='keytext'>'Необходимое количество полётов в бизнес-классе до Валенсии: '</code> <code class='keyword'>+</code>  <code>calculateFlights(<code class='keytext'>3118, true, 15000</code>)</code></code>`,check:()=>~getJ().search(/console\.log\(('|"|`)Необходимоеколичествополётоввбизнес-класседоВаленсии:\1\+calculateFlights\(3118,true,15000\)\)/)},{message:`Ниже, добавьте ещё одно сообщение <code class='keytext'>'Необходимое количество полётов в экономе до Лиссабона: '</code> <code class='keyword'>+</code> <code>calculateFlights(<code class='keytext'>3617, false, 15000</code>)</code>`,check:()=>~getJ().search(/console\.log\(('|"|`)НеобходимоеколичествополётоввэкономедоЛиссабона:\1\+calculateFlights\(3617,false,15000\)\)/)}],blocked:"4",editorOff:"8"},
"lesson1128":{theory:`<div><h1>Немного приберёмся</h1><p>Отрефакторим наш код, а уже затем закончим писать программу для Кекса.</p><p>Зачем снова рефакторинг?</p><p>Дело в том, что дальше нужно будет сравнить полученные результаты и вывести рекомендации для босса. Получается, нам придётся несколько раз использовать результаты работы функции <code>calculateFlights</code>. Поэтому логично и правильно записать эти результаты в переменные и использовать их дальше. Если мы вдруг захотим получить данные для других городов, мы просто изменим значения аргументов в одном единственном месте, а не по всему коду.</p><p>Как лучше всего назвать переменные, которые содержат в себе количество полётов до Лиссабона и Валенсии? Первое, что приходит на ум, дать переменным конкретные названия: <code>flightsToValencia</code> и <code>flightsToLisbon</code>, но такие название слишком частные. Если Кекс захочет полететь в какой-нибудь канадский Виннипег вместо Валенсии, переменную придётся переименовывать. И так каждый раз, когда направление полёта поменяется.</p><p>Можно отталкиваться не от направления, а класса перелёта, и назвать переменные <code>flightsEconom</code> и <code>flightsBusiness</code>. Такой вариант тоже не самый лучший, потому что мы летаем в разные города, меняется не только класс, но и расстояния.</p><p>Назовём переменные максимально просто: <code>flightsVariant1</code> и <code>flightsVariant2</code>. Тогда внутри у них могут быть любые расстояния и классы перелёта.</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n    var percent = 0.18;\n    if (isBusinessClass) {\n        percent += 0.04;\n    }\n    if (distance > 3500) {\n        percent += 0.15;\n    }\n    return distance * percent;\n};\n\nvar calculateFlights = function (distance, isBusinessClass, milesTarget) {\n    var miles = calculateMiles(distance, isBusinessClass);\n    var flights = Math.ceil(milesTarget / miles);\n    return flights;\n};\n\nconsole.log('Необходимое количество полётов в бизнес-классе до Валенсии: ' + calculateFlights(3118, true, 15000));\nconsole.log('Необходимое количество полётов в экономе до Лиссабона: ' + calculateFlights(3617, false, 15000));\n`,tasks:[{message:`Ниже, после объявления функции подсчёта полётов, запишите <code>calculateFlights(<code class='keytext'>3118, true, 15000</code>)</code> в новую переменную <code class='keyvalue'>flightsVariant1</code>`,check:(o)=>o.flightsVariant1===o.calculateFlights(3118,true,15000)},{message:"Замените <code>calculateFlights(<code class='keytext'>3118, true, 15000</code>)</code> в выводе сообщения на <code class='keyvalue'>flightsVariant1</code>",check:()=>~getJ().search(/console\.log\(('|"|`)Необходимоеколичествополётоввбизнес-класседоВаленсии:\1\+flightsVariant1\)/)},{message:"Результат вызова функции <code>calculateFlights(<code class='keytext'>3617, false, 15000</code>)</code> запишите в переменную <code class='keyvalue'>flightsVariant2</code>",check:(o)=>o.flightsVariant2===o.calculateFlights(3617,false,15000)},{message:"Замените <code>calculateFlights(<code class='keytext'>3617, false, 15000</code>)</code> в выводе сообщения на <code class='keyvalue'>flightsVariant2</code>",check:()=>~getJ().search(/console\.log\(('|"|`)НеобходимоеколичествополётоввэкономедоЛиссабона:\1\+flightsVariant2\)/)}],blocked:"4",editorOff:"8"},
"lesson1129":{theory:`<div><h1>Кто быстрей?</h1><p>Осталось совсем немного!</p><p>Сейчас мы знаем результаты и для Валенсии, и для Лиссабона. Осталось добавить код, который сравнит их и скажет, как Кексу быстрее оказаться в заветном Токио. Используем условия <code>if...else</code>. Чем меньше полётов надо потратить на накопление миль, тем лучше.</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n    var percent = 0.18;\n    if (isBusinessClass) {\n        percent += 0.04;\n    }\n    if (distance > 3500) {\n        percent += 0.15;\n    }\n    return distance * percent;\n};\n\nvar calculateFlights = function (distance, isBusinessClass, milesTarget) {\n    var miles = calculateMiles(distance, isBusinessClass);\n    var flights = Math.ceil(milesTarget / miles);\n    return flights;\n};\n\nvar flightsVariant1 = calculateFlights(3118, true, 15000);\nvar flightsVariant2 = calculateFlights(3617, false, 15000);\n\nconsole.log('Необходимое количество полётов в бизнес-классе до Валенсии: ' + flightsVariant1);\nconsole.log('Необходимое количество полётов в экономе до Лиссабона: ' + flightsVariant2);\n`,tasks:[{message: "В конце программы добавьте проверку, что <code class='keyvalue'>flightsVariant1</code> больше <code class='keyvalue'>flightsVariant2</code>",check:()=>~getJ().search(/(var|let)flightsVariant1\S*if\(flightsVariant(1>flightsVariant2|2<flightsVariant1)\)\{\S*\}/)},{message:`Если проверка выполняется, выведите в консоль сообщение <code class='keytext'>'Быстрей накопишь полётами в экономе до Лиссабона! Количество полётов: '</code> <code class='keyword'>+</code>  <code class='keyvalue'>flightsVariant2</code>`,check:()=>~getJ().search(/if\(flightsVariant\S*\{\S*console\.log\(('|"|`)БыстрейнакопишьполётамивэкономедоЛиссабона!Количествополётов:\1\+flightsVariant2\)\S*\}/)},{message:`Иначе выведите сообщение <code class='keytext'>'Быстрей накопишь полётами в бизнесе до Валенсии! Количество полётов: '</code> <code class='keyword'>+</code> <code class='keyvalue'>flightsVariant1</code>`,check:()=>~getJ().search(/if\(flightsVariant\S*\}else\{\S*console\.log\(('|"|`)БыстрейнакопишьполётамивбизнеседоВаленсии!Количествополётов:\1\+flightsVariant1\)\S*\}/)}],blocked:"4",editorOff:"8"},
"lesson1130":{theory:`<div><h1>Копим на кругосветку</h1><p>Мы узнали, что мили до Токио проще накопить полётами до Лиссабона в экономе. А что с остальными городами? Кекс предупреждал, что Токио — только часть его плана. Кроме Токио Кекс хочет бесплатно слетать в Саскатун (3000 миль) и Асунсьон (7500 миль).</p><p>Конечно, мы не будем вызывать функцию <code>calculateFlights</code> самостоятельно для каждого расстояния. Мы запишем все мили в массив (не забудем добавить туда Токио) и будем его перебирать, вызывая на каждой итерации функцию <code>calculateFlights</code> для полётов в Валенсию и Лиссабон. В функцию будем передавать текущий элемент массива — необходимое количество миль для полёта в какой-то город из списка Кекса.</p><p>Чем удобно использование массива и цикла? Мы можем масштабировать решение на любое количество городов. Будь их хоть 2, хоть 10 или даже 100. Цикл будет перебирать массив, вызывать функцию для подсчёта полётов, а затем сравнивать результаты. И так для каждого элемента массива.</p><p>Давайте добавим массив с циклом и, наконец, скажем Кексу, как ему копить на путешествия его мечты. Скорее, Кекс уже заждался!</p></div>`,html:``,css:``,hidden:``,js:`var calculateMiles = function (distance, isBusinessClass) {\n    var percent = 0.18;\n    if (isBusinessClass) {\n        percent += 0.04;\n    }\n    if (distance > 3500) {\n        percent += 0.15;\n    }\n    return distance * percent;\n};\n\nvar calculateFlights = function (distance, isBusinessClass, milesTarget) {\n    var miles = calculateMiles(distance, isBusinessClass);\n    var flights = Math.ceil(milesTarget / miles);\n    return flights;\n};\n\n// Добавляйте массив и цикл сюда\n\nvar flightsVariant1 = calculateFlights(3118, true, 15000);\nvar flightsVariant2 = calculateFlights(3617, false, 15000);\n\nconsole.log('Необходимое количество полётов в бизнес-классе до Валенсии: ' + flightsVariant1);\nconsole.log('Необходимое количество полётов в экономе до Лиссабона: ' + flightsVariant2);\n\nif (flightsVariant1 > flightsVariant2) {\n    console.log('Быстрей накопишь полётами в экономе до Лиссабона! Количество полётов: ' + flightsVariant2);\n} else {\n    console.log('Быстрей накопишь полётами в бизнесе до Валенсии! Количество полётов: ' + flightsVariant1);\n}\n`,tasks:[{message:`После функции <code>calculateFlights</code> создайте переменную <code class='keyvalue'>targets</code>, которая содержит массив <code class='keyvalue'>[<code class='keytext'>3000, 7500, 15000</code>]</code>`,check:(o)=>{var m=o.targets;return Array.isArray(m)&&~m.indexOf(3000)&&~m.indexOf(7500)&&~m.indexOf(15000)&&m.length===3}},{message:`После переменной <code class='keyvalue'>targets</code> создайте цикл <code class='keyword'>for</code>, который перебирает массив <code class='keyvalue'>targets</code> с самого <code class='keytext'>первого</code> элемента до <code class='keytext'>последнего</code> с помощью счётчика <code class='keyvalue'>i</code>`,check:()=>~getJ().search(/(var|let)targets=\S*for\((var|let)i=0;i<targets\.length;i(\+\+|\+=1|=i\+1)\)\{\S*\}/)},{message:"Перенесите <code class='keytext'>внутрь цикла</code> весь код, который записан ниже этого цикла.",check:()=>~getJ().search(/for\S*i<targets\.length\S*flightsVariant1=\S*flightsVariant2=\S*console\.log\S*\}\S*console\.log\S*\}\}/)},{message:"В вызовах функции <code>calculateFlights</code>, замените последний аргумент на <code class='keytext'>текущий</code> элемент массива <code class='keyvalue'>targets</code>",check:()=>{var j=getJ();return ~j.indexOf('calculateFlights(3118,true,targets[i])')&&~j.indexOf('calculateFlights(3617,false,targets[i])')}}],blocked:"4",editorOff:"8"},
"lesson1131":{theory:`<section><h1>Конспект «Функции». 2 часть</h1><pre>// Функция подсчёта миль\n\nvar calculateMiles = function (distance, isBusinessClass) {\n  var percent = 0.18;\n  if (isBusinessClass) {\n    percent += 0.04;\n  }\n  if (distance &gt; 3500) {\n    percent += 0.15;\n  }\n  return distance * percent;\n};\n\n\n// Функция, которая считает количество полётов\n\nvar calculateFlights = function (distance, isBusinessClass, milesTarget) {\n  // Вызываем одну фукнцию из другой\n  var miles = calculateMiles(distance, isBusinessClass);\n  var flights = Math.ceil(milesTarget / miles);\n  return flights;\n};\n\n\n// Массив миль, которые нужно накопить\n\nvar targets = [1500, 3000, 5000, 7500, 10000, 15000];\n\n\n// Цикл, в котором выясняется, какими перелётами мили накопятся быстрей\n\nfor (var i = 0; i &lt; targets.length; i++) {\n  var flightsVariant1 = calculateFlights(3118, true, targets[i]);\n  var flightsVariant2 = calculateFlights(3617, false, targets[i]);\n\n  console.log('Необходимое количество полётов в бизнес-классе до Валенсии: ' + flightsVariant1);\n  console.log('Необходимое количество полётов в экономе до Лиссабона: ' + flightsVariant2);\n\n  if (flightsVariant1 &gt; flightsVariant2) {\n    console.log('Быстрей накопишь полётами в экономе до Лиссабона! Количество полётов: ' + flightsVariant2);\n  } else {\n    console.log('Быстрей накопишь полётами в бизнесе до Валенсии! Количество полётов: ' + flightsVariant1);\n  }\n}\n</pre><br></section>`,html:``,css:``,hidden:``,js:`let numbers = [5, 7, 10, 15];\n\nlet findMax = function() {\n\n}\n\nlet maxNumber = findMax(numbers);`,tasks:[{message:`Перепишите функцию <code>findMax</code> так, чтобы она принимала в качестве аргумента <code class='keytext'>массив</code> чисел, искала среди них максимальное и возвращала это <code class='keytext'>максимальное число</code> (если массив содержит несколько максимальных чисел, то функция должна возвращать только число в единственном экземпляре).`,check:(o)=>{var f=o.findMax;if(typeof f==='function'){var d=[{m:[1,2,3,4,5],r:5},{m:[5,15,22,7,-5,14,-21,-11243,55],r:55},{m:[-2,-1,-12],r:-1},{m:[0,-1,0,0,0],r:0},{m:[2],r:2}];for(var i=0;i<d.length;i++){var r=f(d[i].m);if(r!=d[i].r)return false;};if(!o.hA){Academy.vars.hA=true;var l=Academy.vars.log;for(var i=0;i<d.length;i++){l.push('Вызываем findMax( ['+d[i].m +'] ), ожидаем '+d[i].r+'.');l.push('Успех!');};l.push('Все проверки пройдены!');printLog('Проверка задания');};return true}}}],blocked:"4",editorOff:"9"},
"lesson1132":{theory:`<div><h1>Восьмая программа: «Деньги к деньгам»</h1><p>Вы готовы написать ещё одну программу для босса. Ему понравилось копить воздушные мили и он захотел поднакопить деньжат для новых направлений бизнеса. Естественно, отправился в банк, разузнал про все условия и теперь просит программу для расчёта депозита. Вот техническое задание:</p><blockquote><p>Мяу! Мне нужно посчитать, сколько я заработаю денег на вкладах с разными условиями. Оформи программу, как функцию <code>calculateDeposit</code> с четырьмя параметрами:</p><ol><li>начальная сумма депозита;</li><li>процент годовых (число от 0 до 100);</li><li>срок вклада в месяцах;</li><li>с капитализацией процентов или нет (флаг с булевым значением).</li></ol><p><b>Функция должна возвращать итоговую сумму депозита</b>, округлённую до рублей с помощью <code>Math.round()</code>. Название параметров используй любые.</p><p>Если вклад простой, то процент годовых делится на 12 и умножается на срок вклада, а затем начальная сумма увеличивается на посчитанный процент.</p><p>Вклад с капитализацией считается сложнее: каждый месяц к сумме депозита прибавляются накопленный за месяц процент годовых (не забывай делить процент на 12), а процент следующего месяца считается уже от увеличенной суммы депозита.</p></blockquote><p>Если у вас возникли сложности с подсчётом процентов по вкладам, загляните в подсказку.</p><p>Вкладываем 1000 рублей под 8% годовых на 3 месяца.</p><p>Если вклад простой, то итоговая сумма будет равна:</p><pre>// Общий процент\n(0.08 / 12) * 3 * 1000 = 20 рублей\n// Итоговая сумма депозита\n1000 + 20 = 1020 рублей\n</pre><p>Если вклад с капитализацией, то итоговая сумма будет равна:</p><pre>// Сумма после первого месяца\n1000 + (0.08 / 12) * 1000 = 1007 рублей\n// Сумма после второго месяца\n1007 + (0.08 / 12) * 1007 = 1014 рублей\n// Сумма после третьего месяца (итоговая сумма)\n1014 + (0.08 / 12) * 1014 = 1021 рубль\n</pre></div>`,html:``,css:``,hidden:``,js:`var calculateDeposit = function () {\n\n};\n`,tasks:[{message:`<button onclick="fH2()">Проверить!</button><h3 class="test-header">Техническое задание</h3><div class="test-container"><p><code class='keyword'>Мяу!</code> Мне нужно посчитать, сколько я заработаю денег на вкладах с разными условиями. Оформи программу, как функцию <code>calculateDeposit</code> с четырьмя параметрами:</p><ol><li>начальная <code class='keytext'>сумма</code> депозита;</li><li><code class='keytext'>процент</code> годовых (число от <code class='keytext'>0</code> до <code class='keytext'>100</code>);</li><li><code class='keytext'>срок</code> вклада в месяцах;</li><li>с <code class='keytext'>капитализацией</code> процентов или нет (флаг с булевым значением).</li></ol><p>Функция должна возвращать <code class='keytext'>итоговую сумму</code> депозита, округлённую до рублей с помощью <code>Math.round()</code>. Название параметров используй любые.</p><p>Если вклад простой, то процент годовых делится на <code class='keytext'>12</code> и умножается на срок вклада, а затем начальная сумма увеличивается на посчитанный процент.</p><p>Вклад с капитализацией считается сложнее: каждый месяц к сумме депозита прибавляются накопленный за месяц процент годовых (не забывай делить процент на <code class='keytext'>12</code>), а процент следующего месяца считается уже от увеличенной суммы депозита.</p></div><p class="task-press-button">Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1133":{theory:`<div><h1>Девятая программа: «Вечный вопрос»</h1><p>Программа расчёта вкладов показала две вещи:</p><ol><li>При прочих равных условиях вклад с капитализацией процентов выгоднее, чем вклад с простыми процентами.</li><li>Банкиры не дураки, поэтому предлагают разные проценты для разных типов вклада.</li></ol><p>Вот почему выбрать наиболее выгодный вклад не так-то просто. К счастью, эту задачу можно автоматизировать и быстро сравнивать вклады с разными условиями. Впрочем, вот традиционное техническое задание:</p><blockquote><p>Мяу! Мне нужна программа для сравнения вкладов. Я указываю параметры вкладов в переменных:</p><ol><li><code>initialAmount</code> — исходный размер депозита,</li><li><code>depositDuration</code> — срок депозита в месяцах,</li><li><code>simplePercent</code> — процентная ставка для депозита с простыми процентами,</li><li><code>complexPercent</code> — процентная ставка для депозита с капитализацией процентов.</li></ol><p>Программа должна рассчитывать итоговый размер вклада для депозитов с простыми и капитализируемыми процентами, а затем сохранять рекомендации в две переменных:</p><ol><li><code>recommendedType</code> — рекомендуемый тип депозита. Записывай в эту переменную строку <code>'simple'</code>, если рекомендуешь простой депозит, и строку <code>'complex'</code>, если депозит с капитализацией процентов выгоднее.</li><li><code>finalAmount</code> — итоговый размер депозита.</li></ol></blockquote><p>Задача может показаться сложной и трудоёмкой, но это не так, ведь половину решения вы уже написали в прошлом задании. Ваша функция для расчёта процентов уже написана и протестирована, а значит, работает как надо. Осталось только скопировать её из прошлого задания, вызвать с нужными аргументами (для вклада с простыми процентами и вклада с капитализацией), сравнить результаты и определить, что выгодней.</p><p>Да здравствует повторное использование кода!</p><p>Эту задачу надо решить с помощью использования функции compareDeposits, так как Кекс, как и в других главах курса, будет менять значения переменных, проверяя ваше решение. У вас уже есть проверенная функция, можно использовать её, чтобы ускорить решение. Вам придётся вызывать эту функцию самостоятельно и передавать ей значения из входных переменных. А это вы уже умеете.</p></div>`,html:``,css:``,hidden:``,js:`var initialAmount = 50000;\nvar depositDuration = 12;\nvar simplePercent = 7;\nvar complexPercent = 6;\nvar recomendedType;\nvar finalAmount;\n\nvar compareDeposits = function(initialAmount, depositDuration, simplePercent, complexPercent) {\n\n}\n`,tasks:[{message:`<button onclick="fH3()">Проверить!</button><h3 class="test-header">Техническое задание</h3><div class="test-container"><p><code class='keyword'>Мяу!</code> Мне нужна программа для сравнения вкладов. Оформить её в виде функции <code>compareDeposits</code>. Передавать в неё параметры:</p><ol><li><code class='keytext'>initialAmount</code> — исходный размер депозита,</li><li><code class='keytext'>depositDuration</code> — срок депозита в месяцах,</li><li><code class='keytext'>simplePercent</code> — процентная ставка для депозита с простыми процентами,</li><li><code class='keytext'>complexPercent</code> — процентная ставка для депозита с капитализацией процентов.</li></ol><p>Программа должна рассчитывать итоговый размер вклада для депозитов с простыми и капитализируемыми процентами, возвращать <code class='keyword'>массив</code>, первым элементом которого будет рекомендуемый тип депозита, а вторым итоговый размер депозита; затем сохраняй рекомендации в две переменных:</p><ol><li><code class='keyvalue'>recommendedType</code> — рекомендуемый тип депозита. Записывай в эту переменную строку <code class='keytext'>'simple'</code>, если рекомендуешь простой депозит, и строку <code class='keytext'>'complex'</code>, если депозит с капитализацией процентов выгоднее.</li><li><code class='keyvalue'>finalAmount</code> — итоговый размер депозита.</li></ol><p>Округляйте итоговый размер депозита с помощью функции <code>Math.round()</code>.</p></div><p class="task-press-button">Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1134":{theory:`<div><h1>Калькулятор</h1><p>Кекс задумал обзавестись собственным приложением — калькулятором для подсчёта прибыли веб-студии. Он придумал дизайн, иконку приложения, а за реализацией, конечно, пришёл к вам. Вам нужно написать главное в таком приложении — код, который сможет распознавать ввод пользователя и совершать математические операции.</p><blockquote><p>Мяу! Напиши функцию <code>calculate</code>, которая будет распознавать пользовательский ввод, совершать математические операции и <b>возвращать результат</b>.</p><p>Параметры функции — <code>firstNumber</code>, <code>secondNumber</code> и <code>operator</code>.</p><p>Параметры <code>firstNumber</code>, <code>secondNumber</code> — операнды, параметр <code>operator</code> - оператор.</p><p>Все значения приходят в виде строк, в том числе и операторы. В третьем параметре содержится один из операторов: сложение (<code>'+'</code>), вычитание (<code>'-'</code>), умножение (<code>'*'</code>), деление (<code>'/'</code>).</p><p>В зависимости от оператора программа должна совершать разные операции: складывать первое число со вторым, вычитать из первого числа второе, умножать первое на второе, делить первое на второе.</p><p>Не забудь сделать из строк с числами настоящие числа.</p></blockquote><p>Если не привести строку с числом к числу, то результатом будет не число, как ожидается от калькулятора, а строка. Произойдёт конкатенация строк:</p><pre>console.log('17' + '2');\n// Выведет строку '172'\n</pre><p>Чтобы из строки с числом сделать число, можно воспользоваться встроенной в JavaScript функцией <code>parseInt</code>. Она принимает на вход два аргумента: строку с числом и число, которое указывает на систему счисления для этой строки. Функция <code>parseInt</code> возвращает число, полученное из переданной строки, в указанной системе счисления.</p><pre>parseInt('17', 10);   // Вернёт 17\nparseInt('10001', 2); // Вернёт 17\nparseInt('11', 16);   // Вернёт 17\n</pre><p>В этой задаче мы работаем с числами <b>десятичной системы счисления</b>, поэтому передавайте вторым аргументом в <code>parseInt</code> число <code>10</code>.</p><p>Как и с любой другой функцией, результат работы <code>parseInt</code> можно сразу использовать в вычислениях:</p><pre>console.log(<mark>parseInt('122', 10) + parseInt('8', 10)</mark>);\n// Выведет число 130\n</pre></div>`,html:``,css:``,hidden:``,js:``,tasks:[{message:`<button onclick="fH4()">Проверить!</button><h3 class="test-header">Техническое задание</h3><div class="test-container"><p><code class='keyword'>Мяу!</code> Напиши функцию <code>calculate</code>, которая будет распознавать пользовательский ввод, совершать математические операции и возвращать результат.</p><p>Параметры функции — <code class='keytext'>firstNumber</code>, <code class='keytext'>secondNumber</code> и <code class='keytext'>operator</code>. Параметры <code class='keytext'>firstNumber</code>, <code class='keytext'>secondNumber</code> — операнды, параметр <code class='keytext'>operator</code> - оператор.</p><p>Все значения приходят в виде <code class='keytext'>строк</code>, в том числе и операторы. В третьем параметре содержится один из операторов: сложение (<code class="keyword">'+'</code>), вычитание (<code class="keyword">'-'</code>), умножение (<code class='keyword'>'*'</code>), деление (<code class="keyword">'/'</code>).</p><p>В зависимости от оператора программа должна совершать разные операции: складывать первое число со вторым, вычитать из первого числа второе, умножать первое на второе, делить первое на второе.</p><p>Не забудь сделать из <code class='keytext'>строк</code> с числами <code class='keytext'>настоящие числа</code>.</p></div><p class="task-press-button">Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
"lesson1135":{theory:`<div><h1>Как ты мне дорог</h1><p>Вы уже считали зарплату нетто для будущих сотрудников Кекса. Там вычисления были примерными, теперь Босс хочет конкретики. Он хочет знать в какую сумму компании обходится каждый сотрудник.</p><blockquote><p>Мяу! Напиши функцию <code>calculateExpenses</code>, которая вычисляет ежемесячные затраты компании на сотрудника из «чистой» зарплаты работника.</p><p>Функция должна принимать параметр <code>netSalary</code> — это «чистая» зарплата после вычета налогов.</p><p>В переменную <code>incomeTax</code> записан размер НДФЛ <b>в процентах</b>.</p><p>В переменной <code>contributions</code> указан общий размер взносов <b>в процентах</b>.</p><p>Функция должна возвращать общие затраты компании на сотрудника. Округляй результат вычислений с помощью <code>Math.round()</code>.</p></blockquote><p>Разберёмся на примере, как устроены затраты работодателя на одного сотрудника. Если «чистая» зарплата сотрудника <code>87</code> тысяч, то работодатель тратит <code>100</code> тысяч — <code>87</code> работнику и <code>13</code> в налоговую (НДФЛ <code>13%</code>). Это «грязная» зарплата. Ещё нужно заплатить различные взносы, это около <code>30%</code> от «грязной» зарплаты сотрудника. Получается такой список:</p><pre>// «Грязная» зарплата\n100000\n\n// «Чистая» зарплата\n100000 - (100000 / 100 * 13) = 87000\n\n// Взносы\n100000 / 100 * 30 = 30000\n\n// Все затраты работодателя\n100000 + 30000 = 130000\n</pre><p>В задаче нам нужно найти все затраты работодателя, в примере выше это <code>130000</code>.</p><p>Будьте внимательны в расчётах, тратить деньги — не самое приятное занятие для Босса.</p></div>`,html:``,css:``,hidden:``,js:`var incomeTax = 13;\nvar contributions = 30;\n`,tasks:[{message:`<button onclick="fH5()">Проверить!</button><h3 class="test-header">Техническое задание</h3><div class="test-container"><p>Напиши функцию <code>calculateExpenses</code>, которая вычисляет ежемесячные затраты компании на сотрудника из «чистой» зарплаты работника.</p><p>Функция должна принимать параметр <code class='keytext'>netSalary</code> – это «чистая» зарплата после вычета налогов.</p><p>В переменную <code>incomeTax</code> записан размер НДФЛ в процентах.</p><p>В переменной <code class='keyvalue'>contributions</code> указан общий размер взносов в процентах.</p><p>Функция должна возвращать <code class='keytext'>общие затраты</code> компании на сотрудника. Округляй результат вычислений с помощью <code>Math.round()</code>.</p></div><p class="task-press-button">Нажмите кнопку <code class="keyclass">Проверить</code>, чтобы проверить задание.</p>`,check:(o)=>{document.querySelector('#lesson-tasks ul').classList.add('test-list');return o.hA}}],blocked:"4",editorOff:"8"},
};
hL();